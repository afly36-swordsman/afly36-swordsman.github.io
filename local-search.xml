<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>码农日记（二）</title>
    <link href="/2024/04/10/Programming2/"/>
    <url>/2024/04/10/Programming2/</url>
    
    <content type="html"><![CDATA[<h2 id="c与c语言的区别">C++与C语言的区别</h2><p>C++是C语言的超集（但网上很多文章说这是不对的），这意味着几乎所有的C程序都可以在C++编译器中编译和运行。然而，C++引入了许多新的概念和特性，使得两种语言在一些关键点上有显著的区别。以下是C和C++的一些主要区别。</p><p>面向对象编程：C++支持面向对象编程（OOP），包括类、对象、继承、封装、多态等特性。这使得C++更适合大型软件项目，因为OOP可以提高代码的重用性和可读性。C语言是一种过程性语言，没有这些特性。</p><p>STL（Standard TemplateLibrary）：C++提供了STL，这是一套强大的模板类和模板函数的库，包括列表、向量、队列、栈、关联数组等。这些可以大大提高开发效率。C语言没有内置的数据结构库。</p><p>异常处理：C++提供了异常处理机制，可以更优雅地处理错误情况。C语言处理错误通常依赖于函数返回值。</p><p>构造函数和析构函数：C++支持构造函数和析构函数，这些特殊的函数允许对象在创建和销毁时执行特定的代码。C语言没有这个概念。</p><p>运算符重载：C++允许运算符重载（本质上仍是函数的重载），这意味着开发者可以更改已有运算符的行为，或者为用户自定义类型添加新的运算符。C语言不支持运算符重载。</p><p>例如，如果我们要创建一个复数类并对其进行算术运算，C++的面向对象和运算符重载特性就非常有用。我们可以定义一个复数类，然后重载+、-、*运算符以执行复数的加法、减法和乘法。这样，我们就可以像处理内置类型一样处理复数对象。反观C语言，我们需要定义结构体来存储复数，并且需要写一堆函数来处理复数的加法、减法和乘法，很不方便。</p><h2 id="c和java的核心区别">C++和Java的核心区别</h2><p>C++和Java都是广泛使用的编程语言，但它们在设计理念、功能和用途上有很大的不同。以下是C++和Java的几个核心区别：</p><p>运行环境：Java是一种解释型语言，它的代码在JVM（Java虚拟机）上运行，这使得Java程序可以在任何安装有JVM的平台上运行，实现了“一次编写，到处运行”的理念。而C++是一种编译型语言，其代码直接编译成目标机器的机器码运行，因此需要针对特定平台编译。</p><p>内存管理：Java有自动内存管理和垃圾回收机制，程序员不需要直接管理内存。而在C++中，程序员需要手动进行内存的分配和释放，这提供了更大的控制力，但同时也增加了内存泄漏的风险。</p><p>面向对象编程：Java是一种纯面向对象的编程语言，所有的代码都需要包含在类中。与此不同，C++支持面向对象编程，但它也允许过程式编程（兼容C）。</p><p>错误处理：Java使用异常处理机制进行错误处理，而C++既支持异常处理，也支持通过返回值进行错误处理（C的机制）。</p><p>多线程：Java内置了对多线程的支持，而C++在C++11标准之后才引入了对多线程的支持。</p><p>性能：因为C++的代码直接编译为机器码，所以它通常比Java程序运行得更快。但是，Java的跨平台能力和内置的垃圾回收机制使其在开发大型企业级应用时更具优势。</p><p>例如，如果你正在开发一个需要直接访问硬件，或者需要高性能数学计算的应用（比如游戏、图形渲染、科学计算），C++可能是一个更好的选择。而如果你正在开发一个大型的企业级web应用，Java的跨平台能力、内置的垃圾回收和强大的类库可能会更有优势。</p><h2 id="编译型和解释型的区别">编译型和解释型的区别</h2><p>原文链接：<ahref="https://blog.csdn.net/DaJian35/article/details/81368548">一文了解编译型语言和解释型语言之区别</a>。</p><p>编译型语言的定义：编译型语言首先是将源代码编译生成机器指令，再由机器运行机器码（二进制）。</p><p>解释型语言的定义：解释型语言的源代码不是直接翻译成机器指令，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。</p><p>打个比方：</p><p>编译型相当于用中英文词典（翻译器）将一本英文书一次性翻译（编译）成一本中文书，以后查看直接就是中文了。可想而知，以后读书（运行）会非常非常方便。C、C++都是编译型语言，在执行前一定要先编译一下，通过编译器去生成一个类似.exe 的二进制文件。如果发现语法错误，就会发出编译不通过的提示。</p><p>解释型相当于用中英文词典（翻译器）将一本英文书读一段翻译一段（解释）变成中文。以后查看时还是需要重新翻译。这样效率会低一些，必须依赖解释器，但是跨平台性好，只要有解释器就可以运行代码。像Matlab、Python等都是一边执行一边解释的语言，解释是一句一句的翻译，从而不需要预先进行编译，所以称之为解释型语言。</p><p>扩展：编译型和解释型的定义是对立存在的，但也可以在一个语言中同时存在。比如java 语言同时兼有编译型和解释型两种特点。整个流程如下：</p><p>将源代码（.java 文件）编译生成字节码（.class 文件），再通过 JVM（java虚拟机）运行生成机器指令，由机器运行机器码。注意，此处生成机器语言前的操作是解释型，每次运行都要重新解释。因此，此处表明java 是解释型语言。</p><p>但是，部分 JVM（java 虚拟机）有一种 JIT（Just intime）机制，能够将部分已经解释（“翻译”）的常用机器指令保存起来。下次不需要重新解释这部分了，直接运行即可。此时java 是编译型语言。</p><p>关于移植性：</p><p>编译性语言例如C语言：用C语言开发了程序后，需要通过编译器把程序编译成机器语言（即计算机识别的二进制文件，因为不同的计算机操作系统可能不同，识别的二进制文件也是不同的），所以C语言程序进行移植后，要重新编译。</p><p>解释性语言例如Java语言：Java程序首先通过编译器编译成.class文件，如果在Windows平台上运行，则通过Windows平台上的Java虚拟机（JVM）进行解释。如果运行在Linux平台上，则通过Linux平台上的Java虚拟机进行解释执行。所以说能跨平台，前提是平台上必须要有相匹配的JVM。如果没有JVM，则不能进行跨平台。</p><h2 id="c变量的声明和定义">C++变量的声明和定义</h2><p>在C++中，变量的声明和定义是两个不同的概念。</p><p>声明是告诉编译器某个变量的存在，以及它的类型。声明并不分配存储空间。例如，外部变量的声明<code>extern int a;</code>，这里只是告诉编译器有一个类型为int的变量a存在，具体的a在哪里定义的，编译器此时并不知道。</p><p>定义是声明的延伸，除了声明变量的存在和类型以外，还分配了存储空间。例如，<code>int a;</code>就是一个定义，编译器在这里为a分配了足够的存储空间来存储一个整数。</p><p>在C++中，一个变量可以被声明多次，但只能被定义一次。例如，我们可以在多个文件中声明同一个变量，但只能在一个文件中定义它。如果在多个地方定义同一个变量，编译器会报错。</p><p>举个例子，假设我们正在编写一个大型程序，这个程序有一个全局变量需要在多个文件中使用。我们可以在一个文件中定义这个变量，然后在其他需要使用这个变量的文件中声明它。这样，所有的文件都可以访问到这个变量，但只有一个文件（定义它的那个文件）负责管理它的存储空间。</p><h2 id="静态链接和动态链接">静态链接和动态链接</h2><p>静态链接和动态链接是两种不同的程序链接方式，它们主要的区别在于链接的时间和方式。</p><p>静态链接：在静态链接中，所有代码（包括程序本身的代码和它依赖的库的代码）都会在编译时期被合并为一个可执行文件。这个可执行文件包含了程序运行所需的所有信息，因此它不依赖于任何外部的库文件。静态链接的优点是部署简单，因为不需要额外的依赖，只需要一个文件就可以运行。缺点是可执行文件通常会比动态链接的大，因为它包含了所有需要的代码，而且如果库更新，程序需要重新编译和链接。</p><p>动态链接：在动态链接中，程序的代码和它依赖的库的代码被分开。程序的可执行文件只包含了程序本身的代码和一些标记，这些标记表示程序在运行时需要链接到哪些库。当程序运行时，操作系统会负责加载这些库并进行链接。动态链接的优点是可执行文件更小，因为它不包含库的代码，而且多个程序可以共享同一份库，节省内存。此外，如果库更新，只需要替换库文件，程序无需重新编译和链接。缺点是部署稍微复杂一些，因为需要确保运行环境中有所需的库文件。</p><p>例如，假设我们有一个程序，它使用了一个数学库。如果我们静态链接这个库，那么所有的数学函数都会被包含在我们的可执行文件中，我们可以将这个文件复制到任何地方运行。如果我们动态链接这个库，那么我们的可执行文件就会小得多，但如果我们想在另一台机器上运行这个程序，我们就需要确保那台机器上也安装了这个数学库。</p><h2 id="宏定义函数和typedef">宏定义、函数和typedef</h2><h3 id="宏定义和函数">宏定义和函数</h3><p>宏定义（#define）和函数是两种常见的在C++中编写代码的方式，但它们有一些重要的区别：</p><p>编译阶段：宏定义是在预处理阶段展开的，而函数是在编译阶段处理的。这意味着使用宏定义的代码在编译前就已经被预处理器替换掉了，而函数在编译阶段会生成对应的函数调用。</p><p>类型检查：函数在编译时会进行类型检查，而宏定义不会。这可能会导致宏定义在使用时出现错误，而在编译阶段并不会被发现。</p><p>效率：由于宏定义在预处理阶段就被替换，因此它没有函数调用的开销（如堆栈操作），所以在某些情况下可能更快。然而，过度使用宏定义可能会导致编译后的代码体积增大，因为每次使用宏都会插入一份宏的代码副本。</p><p>封装：函数提供了更好的封装，使得代码更易于阅读和维护。而宏定义由于其替换性质，可能会在复杂的表达式中产生不易察觉的错误。</p><h3 id="宏定义和typedef">宏定义和typedef</h3><p>宏定义 #define在编译期间将宏展开，并替换宏定义中的代码。预处理器只进行简单的文本替换，不涉及类型检查。宏定义可以用来替换数据类型、值或者代码。宏定义没有作用域限制，只要在宏定义之后的地方，就可以使用宏，通常用于定义常量、简单的表达式或简单的代码片段。宏定义不支持模板，因此不能用于定义模板类型别名。</p><p>typedef是一种类型定义关键字，用于为现有类型创建新的名称（别名）。与宏定义不同，typedef是在编译阶段处理的，有更严格的类型检查。typedef 遵循 C++的作用域规则，可以受到命名空间、类等结构的作用域限制，通常用于定义复杂类型的别名，使代码更易读和易于维护。typedef可以与模板结合使用，但在 C++11 之后，推荐使用 using关键字定义模板类型别名。</p><h2 id="c文件操作">C++文件操作</h2><h3 id="文件和文件流对象">文件和文件流对象</h3><figure><img src="/img/stage2/006.jpg" alt="文件和文件流对象" /><figcaption aria-hidden="true">文件和文件流对象</figcaption></figure><h3 id="文本文件和二进制文件的读写">文本文件和二进制文件的读写</h3><figure><img src="/img/stage2/007.jpg" alt="文本文件和二进制文件的读写操作" /><figcaptionaria-hidden="true">文本文件和二进制文件的读写操作</figcaption></figure><h3 id="文件定位eof和字符串流">文件定位、EOF和字符串流</h3><figure><img src="/img/stage2/008.jpg" alt="文件定位、EOF和字符串流" /><figcaption aria-hidden="true">文件定位、EOF和字符串流</figcaption></figure><h3 id="二进制和文本的区别">二进制和文本的区别</h3><p>用文本码形式输出的数据是与字符一一对应的，一个字节代表一个字符，可以直接在屏幕上显示或打印出来。这种方式使用方便，比较直观，便于阅读，便于对字符逐个进行输入输出。但一般占用存储空间较多，而且要花费时间转换。</p><p>用二进制形式输出数值，可以节省外存空间，而且不需要转换时间，但一个字节并不对应一个字符，不能直接显示文件中的内容。如果在程序运行过程中有些中间结果数据暂时保存在磁盘文件中，以后又需要输入到内存，这时用二进制文件保存是最合适的。如果是为了能显示和打印以供阅读，则应按文本形式输出。此时得到的是文本文件，它的内容可以直接在显示屏上观看。</p><h3 id="综合应用">综合应用</h3><p>学校要输入5位学生的信息，将他们的信息存到磁盘文件中，并将第1、3、5位学生数据读入程序显示。第3位学生录入信息有误，需要对其进行修改后存入磁盘文件的原来位置。最后，从磁盘文件读取5位学生的信息并显示。</p><div class="code-wrapper"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>using namespace std;<span class="hljs-keyword">struct</span> student &#123;  <span class="hljs-comment">// 结构体</span>    <span class="hljs-type">int</span> num;    <span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];    <span class="hljs-type">float</span> score;&#125;;<span class="hljs-type">int</span> main() &#123;    <span class="hljs-comment">// 定义结构体数组存入学生的信息</span>    student stu[<span class="hljs-number">5</span>] = &#123;        <span class="hljs-number">1001</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">97</span>,        <span class="hljs-number">1002</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">85.5</span>,        <span class="hljs-number">1008</span>, <span class="hljs-string">&quot;王六&quot;</span>, <span class="hljs-number">54.5</span>,        <span class="hljs-number">1004</span>, <span class="hljs-string">&quot;三体人&quot;</span>, <span class="hljs-number">73</span>,        <span class="hljs-number">1005</span>, <span class="hljs-string">&quot;秦始皇&quot;</span>, <span class="hljs-number">99.3</span>    &#125;;    <span class="hljs-comment">// 用 fstream 类定义输入输出二进制文件流对象 iofile</span>    fstream iofile(<span class="hljs-string">&quot;D:/Others/Afly/Temporary/file.txt&quot;</span>, ios::<span class="hljs-keyword">in</span>|ios::<span class="hljs-keyword">out</span>|ios::binary);    <span class="hljs-keyword">if</span>(!iofile) &#123;        <span class="hljs-comment">// 标准错误流 cerr 不经过缓冲区直接向显示器输出错误信息</span>        cerr &lt;&lt; <span class="hljs-string">&quot;open error!&quot;</span> &lt;&lt; endl;        abort();  <span class="hljs-comment">// 不进行任何清理工作，直接终止程序</span>    &#125;    <span class="hljs-comment">// 向磁盘文件写入5个学生的信息</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++) &#123;        <span class="hljs-comment">// 将 &amp;stu[i] 作为开头指向的 sizeof(stu[i]) 字节的信息写入 iofile 流对象对应的磁盘文件中</span>        iofile.write((<span class="hljs-type">char</span>*)&amp;stu[i], <span class="hljs-keyword">sizeof</span>(stu[i]));    &#125;    student stud[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 存放从磁盘文件中读入的数据</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i+=<span class="hljs-number">2</span>) &#123;        <span class="hljs-comment">// 利用 seekg 函数将文件指针从开头向后移动 i*sizeof(stud[i]) 个字节，定位到索引i的位置</span>        iofile.seekg(i*<span class="hljs-keyword">sizeof</span>(stud[i]), ios::beg);        <span class="hljs-comment">// 将 iofile 对应文件中大小为 sizeof(stud[0]) 的（3个）数据读入 &amp;stud 指向的内存中</span>        iofile.read((<span class="hljs-type">char</span>*)&amp;stud[i/<span class="hljs-number">2</span>], <span class="hljs-keyword">sizeof</span>(stud[<span class="hljs-number">0</span>]));        <span class="hljs-comment">// 输出第1、3、5位学生的信息</span>        cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个学生: &quot;</span> &lt;&lt; stud[i].num &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stud[i].name &lt;&lt; <span class="hljs-string">&quot; &quot;</span>        &lt;&lt; stud[i].score &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;    <span class="hljs-comment">// 修改第3位学生的信息</span>    stud[<span class="hljs-number">2</span>].num = <span class="hljs-number">1003</span>;    stud[<span class="hljs-number">2</span>].name = <span class="hljs-string">&quot;王者荣耀&quot;</span>;  <span class="hljs-comment">// 会报错，字符数组不允许这样赋值</span>    strcpy(stud[<span class="hljs-number">2</span>].name, <span class="hljs-string">&quot;王者荣耀&quot;</span>);  <span class="hljs-comment">// 正确</span>    stud[<span class="hljs-number">2</span>].score = <span class="hljs-number">60</span>;    <span class="hljs-comment">// 定位第3位学生的信息存储位置</span>    iofile.seekp(<span class="hljs-number">2</span>*<span class="hljs-keyword">sizeof</span>(stud[<span class="hljs-number">2</span>]), ios::beg);    <span class="hljs-comment">// 把第3位学生修改后的信息存入磁盘文件中（更新数据）</span>    iofile.write((<span class="hljs-type">char</span>*)&amp;stud[<span class="hljs-number">2</span>], <span class="hljs-keyword">sizeof</span>(stud[<span class="hljs-number">2</span>]));    iofile.seekg(<span class="hljs-number">0</span>, ios::beg);  <span class="hljs-comment">// 重新定位文件开头</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++) &#123;        <span class="hljs-comment">// 读取5个学生的信息</span>        iofile.read((<span class="hljs-type">char</span>*)&amp;stu[i], <span class="hljs-keyword">sizeof</span>(stu[i]));        <span class="hljs-comment">// 打印输出</span>        cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个学生: &quot;</span> &lt;&lt; stud[i].num &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stud[i].name &lt;&lt; <span class="hljs-string">&quot; &quot;</span>        &lt;&lt; stud[i].score &lt;&lt; endl;    &#125;    iofile.close();  <span class="hljs-comment">// 关闭文件</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>注意：编码方式不同可能会导致乱码问题。</p><h2 id="c泛型编程-模板">C++泛型编程: 模板</h2><p>泛型（generictype）就是不使用具体数据类型（如int、double、float等），而是使用一种通用类型来进行程序设计，泛泛的描述一下数据，相当于一种占位符，这个方法可以大规模的减少程序代码的编写量。使用泛型进行编程就叫泛型编程。总之，泛型也是一种数据类型，是用来代替所有类型的“通用类型”。在C++中，泛型的实现就是模板（Template）。</p><h3 id="模板的基础">模板的基础</h3><p>模板是C++实现参数化多态的工具，是一个比较新的重要特性。模板有两类：函数模板、类模板。使用模板可以为函数或类声明一种“一般模式”，使得类中的某些数据成员或成员函数的参数、返回值可取任意类型。具体的类型在调用函数或者定义对象时确定。模板可以实现类型的参数化，即把类型定义为参数，从而实现代码的可重用性。如果类的数据成员类型不能确定时，就必须将此类声明为模板，代表这一类的类。</p><p>模板就是把功能相似、仅数据类型不同的函数或类设计为通用的函数模板或类模板（蓝图），提供给用户。像函数重载，需要写很多个不同参数类型或个数的函数，而定义模板，只需要写一个，大大提高代码重用率。而且函数模板也可以重载。</p><p><font color="purple">传入不同的模板参数，函数模板会生成不同的模板函数，类模板则生成不同的模板类。</font></p><p>模板定义以关键字 template 开始，后接模板参数列表，用 "&lt;&gt;"括起来。template标志着模板声明的开始，告诉C++编译器要声明模板了，不能随便报错。</p><p>模板形参类型的关键字有两个：typename、class。这两个类型关键字的作用完全一样，typename的引入主要是想区分函数模板和类模板，一般约定：typename用于函数模板的创建，class用于类模板的创建。实际上，二者完全可以相互替换。</p><h3 id="函数模板">函数模板</h3><p>函数模板就是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟类型（通用类型参数）来代表。</p><p>函数模板是一种模板，是模板函数的抽象，定义中要用到通用类型参数；模板函数是实实在在的函数，是函数模板的实例，具有程序代码，占用内存空间，是实际存在的。在调用函数模板时，编译系统会根据实参的类型取代模板中的虚拟类型，从而生产相应的具体模板函数，然后实现功能。</p><p>函数模板不允许自动类型转换，而普通函数可以，比如在普通函数中，若存在较小的数据类型和较大的数据类型同时参与运算时，小的会自动（隐式的）转为大的，例如bool、char 可以转为int。C++编译器优先考虑普通函数，如果普通函数不匹配，或者说函数模板更匹配实参数据类型，那么才选择模板。函数模板可以隐式实例化，也可以显式实例化。如果要限定编译器使用模板而不使用普通函数，那么需要显式实例化。</p><p>使用示例：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 定义模板</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fswap</span><span class="hljs-params">(T&amp; x, T&amp; y)</span> </span>&#123;    T temp;    temp = x; x = y; y = temp;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 参数名 T 在不同模板间可以重复使用</span><span class="hljs-function">T <span class="hljs-title">fadd</span><span class="hljs-params">(T a, T b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a+b;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fadd</span><span class="hljs-params">(T1 a, T2 b)</span> </span>&#123;  <span class="hljs-comment">// 模板的重载</span>    <span class="hljs-keyword">return</span> a+b;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">6</span>; <span class="hljs-type">char</span> z = <span class="hljs-string">&#x27;a&#x27;</span>;    <span class="hljs-type">float</span> m = <span class="hljs-number">3.5</span>, n = <span class="hljs-number">6.7</span>;    <span class="hljs-built_in">fadd</span>(x, y);  <span class="hljs-comment">// 11</span>    <span class="hljs-built_in">fadd</span>(m, n);  <span class="hljs-comment">// 10.2</span>    <span class="hljs-comment">// 已经重载了混合类型数据计算的加法函数</span>    <span class="hljs-built_in">fadd</span>(x, m);  <span class="hljs-comment">// 若没有 fadd(T1 a, T2 b) 函数会报错: 不允许为同一个模板类型形参指定两种不同的类型</span>    <span class="hljs-built_in">fadd</span>(z, y);  <span class="hljs-comment">// 若没有 fadd(T1 a, T2 b) 函数会报错: 因为函数模板不能实现自动类型转换</span>    <span class="hljs-built_in">fswap</span>(&amp;x, &amp;y);  <span class="hljs-comment">// 错误: 实参赋给形参时, 左右值类型不匹配, 赋值失败</span>    <span class="hljs-built_in">fswap</span>(x, y);  <span class="hljs-comment">// 隐式调用, 自动数据类型推导</span>    <span class="hljs-built_in">fswap</span>&lt;<span class="hljs-type">int</span>&gt; (x, y);  <span class="hljs-comment">// 显式类型调用 (实例化)</span>    fswap&lt;&gt; (x, y);  <span class="hljs-comment">// 显式调用模板</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/* 还可以这样定义函数模板 */</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">fadd</span><span class="hljs-params">(T a, <span class="hljs-type">int</span> b)</span> </span>&#123;  <span class="hljs-comment">// 形参类型可由用户自定义</span>    <span class="hljs-keyword">return</span> a+b;&#125;</code></pre></div><h3 id="类模板的使用">类模板的使用</h3><p>类模板的定义和使用与函数模板类似。</p><p>类模板的参数可以是类型参数（由关键字typename或class修饰的参数，如T），也可以是非类型参数（某些内置类型，如inta）。注意：非类型形参在模板定义的内部是常量，且只能是整型、指针和引用。比如int、double&amp;、float* 是可以的，但 double、string等不行。调用非类型模板形参的实参必须是常量表达式（能在编译时计算出结果），全局对象的地址、const类型变量、sizeof() 结果都是常量表达式，可以作为实参。</p><p>若全局域有变量名与类模板中的模板参数名相同，那么该变量会被隐藏。模板参数名不能是类中成员的名字，同一个模板参数名在模板参数表中只能出现一次。不同的类模板声明中，模板参数名可以重复使用。</p><p>类模板形参列表中 class T 是形参，实参值被提供给 T后，系统将会根据实参的具体类型创建一个模板类，该类是真实存在的，这个过程叫类模板的实例化。函数模板的实例化是编译程序在处理函数调用时自动完成的，而类模板的实例化须由程序员在程序中显式的指定。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;  <span class="hljs-comment">// 定义模板</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Compare</span>(T a, T b) &#123;  <span class="hljs-comment">// 模板内定义数据成员</span>        c_x = a; c_y = b;    &#125;    <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (c_x &gt; c_y) ? c_x : c_y;    &#125;    <span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:    T c_x, c_y;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;  <span class="hljs-comment">// 在类模板外定义成员函数</span>T Compare&lt;T&gt;::<span class="hljs-built_in">min</span>() &#123;    <span class="hljs-keyword">return</span> (c_x &lt; c_y) ? c_x : c_y;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> size = <span class="hljs-number">1</span>&gt;  <span class="hljs-comment">// 缺省参数 (指定缺省值/默认值, 是常量)</span><span class="hljs-keyword">class</span> Myclass1 &#123;<span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 无构造函数, 仅作为例子</span>    T <span class="hljs-built_in">func</span>(T a) &#123;        <span class="hljs-keyword">return</span> a + size;    &#125;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> size&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass2</span> &#123;  <span class="hljs-comment">// size 在该类中是个常量</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">T <span class="hljs-title">func</span><span class="hljs-params">(T a)</span> </span>&#123;        <span class="hljs-keyword">return</span> a + size;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Compare&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>)</span></span>;  <span class="hljs-comment">// 必须显式指定形参类型进行类模板的实例化</span>    cmp.<span class="hljs-built_in">max</span>();  <span class="hljs-comment">// 返回: 7</span>    cmp.<span class="hljs-built_in">min</span>();  <span class="hljs-comment">// 返回: 5</span>    Myclass1&lt;<span class="hljs-type">int</span>&gt; mc1;  <span class="hljs-comment">// size 取默认值: 1</span>    cout &lt;&lt; mc1.<span class="hljs-built_in">func</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出: 6 (5 + 1)</span>    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>; <span class="hljs-type">const</span> <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;    Myclass2&lt;<span class="hljs-type">int</span>, x&gt; mc2;  <span class="hljs-comment">// 错误: x 不是常量</span>    Myclass2&lt;<span class="hljs-type">int</span>, y&gt; mc2;  <span class="hljs-comment">// 正确, y 是常量</span>    Myclass2&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; mc2;  <span class="hljs-comment">// 正确, 2 是常量 (字面量)</span>    cout &lt;&lt; mc2.<span class="hljs-built_in">func</span>(<span class="hljs-number">8</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出: 10 (8 + 2)</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><h3 id="模板的特化">模板的特化</h3><p>模板参数在某种特定类型下的具体实现叫模板的特化，有时也叫模板的具体化（我个人认为这个名字不好，模板实例化又何尝不是一种具体化呢？）。</p><p>模板特化分别包括：函数模板的特化和类模板的特化。</p><p>函数模板的特化，发生在函数模板需要对某些类型进行特别处理的时候。看下面这个例子：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">/* 常见类型如 int char double 等数据的比较 */</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(T a, T b)</span> </span>&#123;    <span class="hljs-keyword">return</span> (a == b);&#125;<span class="hljs-comment">/* 对 char* 类型字符串进行比较, 就需要对函数模板进行特化 */</span><span class="hljs-keyword">template</span> &lt;&gt;  <span class="hljs-comment">// 特化标志</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(<span class="hljs-type">char</span>* t1, <span class="hljs-type">char</span>* t2)</span> </span>&#123;  <span class="hljs-comment">// 写法 1</span><span class="hljs-type">bool</span> <span class="hljs-built_in">comp</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-type">char</span>* t1, <span class="hljs-type">char</span>* t2) &#123;  <span class="hljs-comment">// 写法 2</span>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(t1, t2) == <span class="hljs-number">0</span>);  <span class="hljs-comment">// 等于 0 表示两字符串相同</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">/* 字符串比较测试 */</span>    string s1 = <span class="hljs-string">&quot;123&quot;</span>, s2 = <span class="hljs-string">&quot;123&quot;</span>;    cout &lt;&lt; (s1 == s2) &lt;&lt; endl;  <span class="hljs-comment">// 1</span>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello&quot;</span>, str2[] = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-comment">// str1、str2 代表数组地址, 下面写法表示将两个地址进行比较, 而不是对数组中字符串比较</span>    cout &lt;&lt; (str1 == str2) &lt;&lt; endl;  <span class="hljs-comment">// 0</span>    <span class="hljs-comment">// 利用特化的函数模板进行实例化, 以实现特殊的要求</span>    cout &lt;&lt; <span class="hljs-built_in">comp</span>(str1, str2) &lt;&lt; endl;  <span class="hljs-comment">// 1</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>同理，类模板中需要对某些类型进行特别处理时，可以使用类模板的特化。需要注意的是，进行类模板的特化时，需要特化所有的（涉及通用类型参数的）成员变量和成员函数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Comp</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a, T b)</span> </span>&#123;        <span class="hljs-keyword">return</span> (a == b);    &#125;&#125;;<span class="hljs-comment">/* 下面这种定义, 是比较规范的, 不会漏掉某些数据成员 */</span><span class="hljs-keyword">template</span> &lt;&gt;  <span class="hljs-comment">// 特化标志</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comp</span>&lt;<span class="hljs-type">char</span>*&gt; &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> *t1, <span class="hljs-type">char</span> *t2)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(t1, t2) == <span class="hljs-number">0</span>);    &#125; &#125;;<span class="hljs-comment">/* 下面这种定义是简化写法, 涉及通用类型参数(T)的数据成员已被全部特化, 也是可行的 */</span><span class="hljs-keyword">template</span> &lt;&gt;  <span class="hljs-comment">// 特化标志</span><span class="hljs-type">bool</span> Comp&lt;<span class="hljs-type">char</span>*&gt;::<span class="hljs-built_in">fun</span>(<span class="hljs-type">char</span>* t1, <span class="hljs-type">char</span>* t2) &#123;    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(t1, t2) == <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello&quot;</span>;    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hello&quot;</span>;    Comp&lt;<span class="hljs-type">int</span>&gt; c1; Comp&lt;<span class="hljs-type">char</span>*&gt; c2;    c1.<span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 返回: 0</span>    c2.<span class="hljs-built_in">fun</span>(str1, str2);  <span class="hljs-comment">// 返回: 1</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>如果只想对类模板中的某些通用类型参数进行特化，并非对其全部的通用类型参数进行特化，那么可以使用类模板的<font color="purpleblack">偏特化</font>，也叫部分特化。例如：</p><div class="code-wrapper"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T1, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">T2</span>&gt;<span class="hljs-symbol">class</span> <span class="hljs-symbol">A</span> &#123; ... &#125;;<span class="hljs-comment">/* 仅对 T2 进行特化 */</span>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T1</span>&gt;  // 这里必须要列出未特化的模板参数: <span class="hljs-symbol">T1</span><span class="hljs-symbol">class</span> <span class="hljs-symbol">A</span>&lt;<span class="hljs-symbol">T1, <span class="hljs-symbol">int</span></span>&gt;  // <span class="hljs-symbol">A</span> 的后面要列出全部模板参数, 并指定特化的类型: 指定 <span class="hljs-symbol">int</span> 为 <span class="hljs-symbol">T2</span> 的特化类型&#123; ... &#125;;</code></pre></div><h2 id="os篇进程的并发与同步">OS篇：进程的并发与同步</h2><p>操作系统（OperatingSystem，OS）是整个计算机系统的管理和控制中心。</p><h3 id="操作系统os的含义">操作系统（OS）的含义</h3><p><font color="purple">从计算机系统设计者的角度看</font>，OS是由一系列程序模块组成的一个大的系统管理程序，它依据设计者设计的各种管理和调度策略，合理地组织计算机的工作流程，从而提高计算机资源（处理器CPU、缓存Cache、内存Memory、数据通路等）的利用效率。由此可认为，OS是计算机软硬件资源的管理和控制程序。</p><p>调度策略包括先来先服务调度算法（First Come First Service,FCFS）、最短作业优先调度算法（Shortest Job First,SJF）、高响应比优先调度算法（Highest Response Ratio Next,HRN）、优先级调度算法（Priority Scheduling / Highest Priority First,HPF）、时间片轮转调度法（Round Robin, RR）等。</p><p><font color="red">从用户角度看</font>，配上 OS的计算机是一台比裸机功能更强、使用更方便简单的智能机。也即，OS是用户与计算机系统之间的一个接口，用户通过它来使用计算机。它向用户及其程序提供了一个良好的使用计算机的环境，通过用户态和核心态（内核态）两种模式的切换保护自身免受应用程序的损害，同时使得计算机系统变得容易维护、安全可靠、容错能力强、更加有效。</p><p>所谓裸机，是只包括冯诺依曼模型中的基本结构：中央处理机（即CPU，包括运算器和控制器）、存储器、输入设备和输出设备，不增加任何扩充的计算机。</p><p>从上面两个角度可以总结出，设计 OS的目的有两个：一个是使用户方便、简单地使用计算机系统，另一个是使计算机系统能高效可靠地运转。</p><h3 id="进程和线程">进程和线程</h3><p>进程是为了描述操作系统中各种并发活动而引入的。<strong>进程（Process）</strong>是操作系统最基本、最重要的概念之一，是OS进行系统资源分配的基本单位。进程是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。</p><p>通俗来说，进程就是程序的一次执行过程。程序是静态的概念，可以作为一种软件资源长期保存。而进程是动态的，它把程序作为自己的运行实体，没有程序也就没有进程。进程是动态的产生、变化和消亡的，拥有自己的生命周期。进程控制块（ProcessControl Block, PCB）或进程描述符（Process Descriptor,PD）是进程存在的唯一标识，它包含系统管理进程所需的全部信息。</p><p>进程的生命周期：</p><p><img src="/img/stage2/010.jpg" /></p><p>现代 OS为了提高系统的并发程度，引入了线程的概念。<strong>线程（Thread）</strong>是处理机调度的基本对象。线程又称为迷你进程，或者说轻型进程。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，需要较大的时空开销，限制了并发程度的进一步提高。为减少进程切换的开销，把进程作为资源分配单位和调度单位这两个属性分开处理（这是进程刚被提出时的定位），即进程还是作为资源分配的基本单位，但是不作为调度的基本单位（很少调度或切换），把调度执行与切换的责任交给线程，即线程成为独立调度的基本单位。线程比进程更容易（更快）创建，也更容易撤销。</p><p>举个例子：进程是拥有资源的基本单位，而且还能够进行独立调度，这就犹如一个背着粮草的士兵，这必然会造成士兵执行命令（战斗）的速度。所以一个简单想法就是：分配两个士兵执行同一个命令（携带粮草战斗）：一个负责携带所需粮草随时供给，另一个负责执行战斗。这就是线程的思想。一个线程也由一个线程控制块描述，它包含系统管理线程所需的全部信息。</p><p><strong>区别</strong>：进程在逻辑上表示 OS必须做的一个任务，线程表示完成这个任务的许多可能的子任务。线程是进程中的一个可执行实体，一个进程至少有一个线程，也可以有多个线程。每个进程拥有一个独立的存储空间，用来装入由若干代码段和数据段组成的实体，此外它还包含一些打开的文件。进程之间一般互不影响。一个进程的多个线程共享该进程拥有的所有资源，因此线程的上下文切换要比进程快得多。但由于资源共享，安全性就会降低，多进程比多线程可能更加安全。</p><h3 id="进程间的并发控制信号量机制">进程间的并发控制：信号量机制</h3><p>进程间的互斥是由资源共享导致的，比如两个异步进程都要执行文件打印，但打印机只有一台。</p><p>引入两个概念：临界资源（CriticalResource），是一次仅允许一个进程使用的系统中的一些共享资源，包括慢速的硬设备（如打印机等），也包括软件资源（如共享变量、共享文件、各种队列等）。临界区（CriticalSection），是并发进程访问临界资源的那段必须互斥执行的程序段。</p><p>要保证程序在临界区的互斥执行，就不能让两个（或多个）进程同时在他们的临界区内执行，并且临界区之外的进程不可以阻止其他进程进入临界区。信号量（Semaphore）机制是荷兰学者Dijkstra于1965年提出的一种可以正确管理各并发进程对计算机系统中的共享资源的互斥使用和协作同步关系的同步机制。</p><p>信号量（用 s表示）表示系统共享资源的物理实体，操作系统利用信号量的状态对进程和资源进行管理。信号量s 用一个数据结构表示：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">semaphore</span> &#123;    <span class="hljs-type">int</span> value;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span> *list;&#125;s;</code></pre></div><p>其中，value 表示该类资源的可用数量，list是等待使用该类资源的进程排队队列的头指针。对信号量 s 的操作只允许执行P、V原语操作（原子操作，表示不可分割（不可中断）的操作，即要么全做，要么全不做）。P、V源自荷兰语，翻译过来分别是 test、increment，分别表示测试和增加之意。</p><p>P 操作：<code>P(s)</code>，表示将信号量 s.value 的值减1。若减1后s.value 的值为0，说明临界区内无进程，则执行 P操作的进程继续执行。若减1后为负，则执行 P操作的进程变为阻塞状态，并进入与该信号量有关的 list所指队列中等待，之后转处理机调度。P 操作相当于申请资源。</p><p>V 操作：<code>V(s)</code>，表示将信号量 s.value 的值加1。若加1后s.value 的值大于0，说明执行 V操作的进程在临界区内正常完成了程序的执行过程，本进程继续前进。若加1后仍小于或等于0，则执行V 操作的进程从与该信号量有关的 list所指队列中释放一个进程，使其由阻塞态变为就绪态，之后本进程继续执行或者转处理机调度。V操作相当于释放资源。</p><p>注：有些资料用了 wait(s) 和 signal(s) 分别取代 P(s) 和 V(s)操作。</p><p>在实际操作中，引入互斥信号量 mutex并赋初值：1。任何欲进入临界区执行的进程，必须先对 mutex 执行 P操作，即将 mutex 的值减1。若减1后 mutex 为0，表示临界资源空闲，执行 P操作的进程可以进入临界区执行。若减1后 mutex为负值，说明已有进程正在临界区执行，那么本进程（执行 P操作的进程）必须等待，直到临界区空闲为止。这样，利用信号量就可以方便解决临界区的互斥执行，从而让进程更好的同步协作。</p><h3 id="信号量案例展示">信号量案例展示</h3><p>本节由计算机中的两个经典问题为引，用伪代码的形式对进程之间并发、同步产生的互斥问题进行解读。</p><h4id="案例1生产者和消费者问题the-producer-consumer-problem">案例1：生产者和消费者问题（TheProducer-Consumer Problem）</h4><p>计算机中进程之间的同步问题可以一般化为生产者和消费者问题。运行中的进程释放一个资源时，可将其看作生产者。而当其申请使用一个资源时，可看作消费者。例如对数据计算后打印的任务，计算进程可看作被打印数据的生产者，又可看作空缓冲区的消费者；而打印进程可看作被打印数据的消费者，也可看作空缓冲区的生产者。</p><p>用信号量解决这个问题，需要定义以下信号量：</p><ul><li>互斥信号量mutex，控制生产者和消费者互斥使用缓冲区（避免打印混乱）</li><li>同步信号量empty，指示空缓冲区的可用数量，制约生产者进程输送数据</li><li>同步信号量full，指示装满数据的缓冲区个数，制约消费者进程取用数据</li><li>送、取数据（产品）的指针变量 i、j</li><li>临时变量 x、y，表示送、取的数据（产品）</li></ul><p>共享环形缓冲区问题描述：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> mutex, empty, full;mutex=<span class="hljs-number">1</span>; empty=k; full=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 赋初值，缓冲区大小为k</span><span class="hljs-type">int</span> array[k];  <span class="hljs-comment">// 定义缓冲区</span><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 定义缓冲区送取产品的指针</span><span class="hljs-type">int</span> x, y;parbegin    producer: begin        produce a product to x;        <span class="hljs-built_in">P</span>(empty);  <span class="hljs-comment">// 申请一个空缓冲 (empty -= 1)</span>        <span class="hljs-built_in">P</span>(mutex);  <span class="hljs-comment">// 申请进入缓冲区</span>        array[i] = x;  <span class="hljs-comment">// add the product to buffer</span>        i = (i+<span class="hljs-number">1</span>) mod k;  <span class="hljs-comment">// 以环形方式更新送产品的指针</span>        <span class="hljs-built_in">V</span>(full);  <span class="hljs-comment">// 释放一个产品 (full += 1)</span>        <span class="hljs-built_in">V</span>(mutex);  <span class="hljs-comment">// 退出缓冲区</span>        ...    end    consumer: <span class="hljs-function">begin</span><span class="hljs-function">        <span class="hljs-title">P</span><span class="hljs-params">(full)</span></span>;  <span class="hljs-comment">// 申请一个产品，产品数-1</span>        <span class="hljs-built_in">P</span>(mutex);  <span class="hljs-comment">// 申请进入缓冲区</span>        y = array[j];  <span class="hljs-comment">// take a product from buffer</span>        j = (j+<span class="hljs-number">1</span>) mod k;  <span class="hljs-comment">// 更新取产品的指针</span>        <span class="hljs-built_in">V</span>(empty);  <span class="hljs-comment">// 释放一个空缓冲</span>        <span class="hljs-built_in">V</span>(mutex);  <span class="hljs-comment">// 退出缓冲区</span>        ...    endparend</code></pre></div><p>无论是生产者进程还是消费者进程，P操作的顺序相当重要。如果把生产者进程中的两个 P操作的次序交换，那么当缓冲区满时，生产者欲向缓冲区放产品时，将在P(empty)上等待，但它已获得了使用缓冲区的权力。若此后，消费者欲取产品，申请使用缓冲区会失败，便会在P(mutex)上等待。这会导致生产者等待消费者取走产品，但消费者却在等待生产者释放缓冲区的相互等待状况，造成系统发生死锁现象。</p><h4id="案例2读者与写者问题the-readers-writers-problem">案例2：读者与写者问题（TheReaders-Writers Problem）</h4><p>一个文件可能要被多个进程共享。为了保证读写的正确性和文件的一致性，要求当有读者进程读文件时，允许多读者同时读，但不允许任何写者进程写；当有写者进程写时，既不允许其他任何写者进程写，也不允许任何读者进程读。</p><p>设置信号量：</p><ul><li>互斥信号量rw_ww_mutex，用于实现读写进程互斥和写写进程互斥地访问共享文件</li><li>计数器变量 readcount，记录同时进行读的读者进程数</li><li>互斥信号量 rr_mutex，用于控制读者进程互斥地修改计数器 readcount</li></ul><p>实现读者优先的问题描述：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> rw_ww_mutex=<span class="hljs-number">1</span>, rr_mutex=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> readcount=<span class="hljs-number">0</span>;parbegin    reader: begin  <span class="hljs-comment">// 读者进程</span>        <span class="hljs-comment">/* 开启阅读 */</span>        <span class="hljs-built_in">P</span>(rr_mutex);  <span class="hljs-comment">// 申请对读者计数+1</span>        <span class="hljs-keyword">if</span>(readcount==<span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 第一个读者申请文件的阅读使用权，此后若有其他的写文件进程则必须等待</span>            <span class="hljs-built_in">P</span>(rw_ww_mutex);        &#125;        readcount += <span class="hljs-number">1</span>;        <span class="hljs-built_in">V</span>(rr_mutex);  <span class="hljs-comment">// 第一个读者已经计数完成，就要释放对 readcount 的使用权</span>        ...        <span class="hljs-comment">/* 完成阅读，准备退出 */</span>        <span class="hljs-built_in">P</span>(rr_mutex);  <span class="hljs-comment">// 读完退出时，申请对读者计数-1</span>        readcount -= <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(readcount==<span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 若退出的是最后一位读者，应开放该文件的使用权（写者方能使用）</span>            <span class="hljs-built_in">V</span>(rw_ww_mutex);        &#125;        <span class="hljs-built_in">V</span>(rr_mutex);        ...    end    writer: begin  <span class="hljs-comment">// 写者进程</span>        ...        <span class="hljs-built_in">P</span>(rw_ww_mutex);  <span class="hljs-comment">// 申请写文件</span>        &lt;-- 向文件写数据 --&gt;        <span class="hljs-built_in">V</span>(rw_ww_mutex);  <span class="hljs-comment">// 释放文件的使用权</span>        ...    endparend</code></pre></div><h3 id="并发进程新的同步机制管程">并发进程新的同步机制：管程</h3><p>使用信号量往往涉及大量的 P、V操作，这会给用户编程造成较大负担，很容易出错，且程序的易读性差、查错纠错困难，不利于修改和维护。</p><p>管程（Monitor）提供了一种高级的同步原语，它将共享资源和对资源的操作封装在一个单元中，并提供了对这个单元的访问控制机制。使用管程进行编程更加简单，使用方便，且容易控制。</p><p>Hansan 和 Hoare在1973年提出了管程，基本思想是将共享变量以及对共享变量进行的所有操作过程集中在一个模块中。Hansan对管程的定义是：管程是关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块。管程与C++中的类相似，它隐含了代表资源的内部表示，向外提供的只是为各方法规定的操作特性。管程保证任何时候最多只有一个进程执行管程中的代码。并发进程在请求和释放共享资源时调用管程，从而提供了互斥机制，保证管程数据的一致性。</p><p>一个管程包括以下四个主要部分：</p><ul><li>共享变量：管程中包含了共享的变量或数据结构，多个线程或进程需要通过管程来访问和修改这些共享资源。</li><li>互斥锁（Mutex）：互斥锁是管程中的一个关键组成部分，用于确保在同一时间只有一个线程或进程可以进入管程。一旦一个线程或进程进入管程，其他线程或进程必须等待，直到当前线程或进程退出管程。</li><li>条件变量（ConditionVariables）：条件变量用于实现线程或进程之间的等待和通知机制。当一个线程或进程需要等待某个条件满足时（比如某个共享资源的状态），它可以通过条件变量进入等待状态。当其他线程或进程满足了这个条件时，它们可以通过条件变量发送信号来唤醒等待的线程或进程。</li><li>管程接口（对管程进行操作的函数）：这是一组操作共享资源的接口或方法。这些接口定义了对共享资源的操作，并且在内部实现中包含了互斥锁和条件变量的管理逻辑。其他线程或进程通过调用这些接口来访问共享资源，从而确保了对共享资源的有序访问。</li></ul><p>管程的数据只能由该管程的过程存取，不允许进程和其他管程直接存取。当一个进程进入管程执行它的一个过程时，如果因某种原因而被阻塞，应立即退出该管程，否则就会阻塞其他进程进入管程，从而导致系统死锁。管程内的条件变量c 和两个操作条件变量的同步原语 wait(c) 和 signal(c)提供了同步机制，可以防止系统死锁，保证各进程间的有序协作。</p><p><code>wait(c)</code>：执行 wait(c) 的进程将自己阻塞在条件变量 c的相应等待队列中。在阻塞前，检查有无等待进入该管程的进程。若无，阻塞自己并释放管程的互斥使用权；若有，则唤醒第一个等待者进程，以便其进入该管程。</p><p><code>signal(c)</code>：执行 signal(c) 的进程检查条件变量 c的相应等待队列。如果队列为空，则该进程继续；如果不为空，唤醒 c队列中第一个等待者进程，以便其重新进入该管程。</p><p>需要注意的是，不管是信号量机制，还是管程机制，都属于进程间的低级通信。除了低级通信，还有进程的高级通信，即进程采用操作系统提供的多种通信方式，如消息缓冲、信箱、管道和共享主存区等实现的通信。当进程通过消息缓冲进行数据交换时，以消息为单位把通信内容直接或间接地发送给对方，这是进程利用系统提供的一组命令实现的。操作系统隐藏了通信的实现细节，大大简化了通信编程的复杂性，因而得到广泛应用。</p><h3 id="管程案例展示">管程案例展示</h3><p>下面是用管程描述生产者和消费者共享环形缓冲区（循环队列）问题的一个示例。</p><div class="code-wrapper"><pre><code class="hljs arduino">Monitor prod_conshow &#123;  <span class="hljs-comment">// Producer-Consumer Demonstration</span>    <span class="hljs-type">char</span> buffer[N];  <span class="hljs-comment">// 具有N个元素的环形缓冲区</span>    <span class="hljs-type">int</span> k;  <span class="hljs-comment">// 缓冲区中产品的个数</span>    <span class="hljs-type">int</span> next_empty, next_full;  <span class="hljs-comment">// 送、取产品的指针</span>    condition non_empty, non_full;  <span class="hljs-comment">// 条件变量</span>    define put, get;  <span class="hljs-comment">// 本管程内定义的过程（或函数）说明（即：名字表）</span>    <span class="hljs-function">use <span class="hljs-title">wait</span><span class="hljs-params">()</span>, <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 本管程内引用的外部模块的过程说明</span>    <span class="hljs-comment">/* 向缓冲区送产品的过程 */</span>    <span class="hljs-function">procedure <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">char</span> product)</span> </span>&#123;        <span class="hljs-keyword">if</span>(k==N) &#123;            <span class="hljs-comment">// 缓冲区已满，调用者（生产者）进程阻塞等待（退出至 non_full 队列）</span>            <span class="hljs-built_in">wait</span>(non_full);        &#125;        buffer[next_empty] = product;        k += <span class="hljs-number">1</span>;  <span class="hljs-comment">// 可用产品数+1</span>        next_empty = (next_empty + <span class="hljs-number">1</span>) % N;  <span class="hljs-comment">// 环形更新</span>        <span class="hljs-comment">// 唤醒等待取产品的消费者进程（在 non_empty 队列中）</span>        <span class="hljs-built_in">signal</span>(non_empty);    &#125;    <span class="hljs-comment">/* 从缓冲区取产品的过程 */</span>    <span class="hljs-function">procedure <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span> goods)</span> </span>&#123;        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 缓冲区空，调用者（消费者）进程阻塞等待（退出至 non_empty 队列）</span>            <span class="hljs-built_in">wait</span>(non_empty);        &#125;        goods = buffer[next_full];        k -= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 可用产品数-1</span>        next_full = (next_full + <span class="hljs-number">1</span>) % N;        <span class="hljs-comment">// 唤醒等待送产品的生产者进程（在 non_full 队列中）</span>        <span class="hljs-built_in">signal</span>(non_full);    &#125;    <span class="hljs-comment">/* 初始化 */</span>    &#123;        k = <span class="hljs-number">0</span>; next_empty = <span class="hljs-number">0</span>; next_full = <span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-comment">/* 调用管程的相应过程实现进程同步 */</span>producer: &#123;    <span class="hljs-type">char</span> item;    &lt;-- produce an item --&gt;    prod_conshow.<span class="hljs-built_in">put</span>(item);&#125;consumer: &#123;    <span class="hljs-type">char</span> item;    prod_conshow.<span class="hljs-built_in">get</span>(item);    &lt;-- consume the item --&gt;&#125;</code></pre></div><p>C++代码实现：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Monitor</span> &#123;<span class="hljs-keyword">private</span>:    queue&lt;<span class="hljs-type">int</span>&gt; buffer;               <span class="hljs-comment">// 共享的缓冲区</span>    <span class="hljs-type">int</span> maxSize;                     <span class="hljs-comment">// 缓冲区的最大容量</span>    mutex mtx;                       <span class="hljs-comment">// 互斥锁</span>    condition_variable bufferFull;   <span class="hljs-comment">// 缓冲区满的条件变量</span>    condition_variable bufferEmpty;  <span class="hljs-comment">// 缓冲区空的条件变量</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">// 构造函数，初始化缓冲区大小</span>    <span class="hljs-built_in">Monitor</span>(<span class="hljs-type">int</span> size) : <span class="hljs-built_in">maxSize</span>(size) &#123;&#125;    <span class="hljs-comment">// 生产者进程的方法</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-type">int</span> item)</span> </span>&#123;        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;  <span class="hljs-comment">// 锁定互斥锁</span>        <span class="hljs-comment">// 如果缓冲区已满，则生产者等待</span>        <span class="hljs-keyword">while</span> (buffer.<span class="hljs-built_in">size</span>() == maxSize) &#123;            bufferFull.<span class="hljs-built_in">wait</span>(lock);  <span class="hljs-comment">// 释放锁并等待，直到被通知（唤醒）</span>        &#125;        buffer.<span class="hljs-built_in">push</span>(item);  <span class="hljs-comment">// 将数据添加到缓冲区</span>        cout &lt;&lt; <span class="hljs-string">&quot;Produced item: &quot;</span> &lt;&lt; item &lt;&lt; endl;  <span class="hljs-comment">// 给用户提示</span>        bufferEmpty.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// 通知一个消费者，缓冲区中有产品可拿走消费</span>    &#125;     <span class="hljs-comment">// 消费者进程的方法</span>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;  <span class="hljs-comment">// 锁定互斥锁</span>        <span class="hljs-comment">// 如果缓冲区为空，则消费者等待</span>        <span class="hljs-keyword">while</span> (buffer.<span class="hljs-built_in">empty</span>()) &#123;            bufferEmpty.<span class="hljs-built_in">wait</span>(lock);  <span class="hljs-comment">// 释放锁并等待，直到被通知（唤醒）</span>        &#125;        <span class="hljs-type">int</span> item = buffer.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 从缓冲区取出数据</span>        buffer.<span class="hljs-built_in">pop</span>();        cout &lt;&lt; <span class="hljs-string">&quot;Consumed item: &quot;</span> &lt;&lt; item &lt;&lt; endl;        bufferFull.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// 通知一个生产者，缓冲区中有空位可添加数据</span>        <span class="hljs-keyword">return</span> item;    &#125;&#125;; <span class="hljs-function">Monitor <span class="hljs-title">monitor</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 创建 Monitor 类的实例并指定缓冲区大小为5</span><span class="hljs-comment">// 生产者线程函数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;        monitor.<span class="hljs-built_in">produce</span>(i);        <span class="hljs-comment">// 模拟耗时：生产间隔是500ms，即线程休眠500毫秒</span>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));    &#125;&#125;<span class="hljs-comment">// 消费者线程函数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;        <span class="hljs-type">int</span> item = monitor.<span class="hljs-built_in">consume</span>();        <span class="hljs-comment">// 模拟耗时：消费间隔是800ms，即线程休眠800毫秒</span>        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">800</span>));    &#125;&#125;<span class="hljs-comment">// 在主函数中，创建并启动生产者线程和消费者线程，然后等待它们完成</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 创建新线程，这个新线程与主线程（通常是 main 函数所在的线程）会并行执行</span>    <span class="hljs-function">thread <span class="hljs-title">producerThread</span><span class="hljs-params">(producer)</span></span>;    <span class="hljs-function">thread <span class="hljs-title">consumerThread</span><span class="hljs-params">(consumer)</span></span>;    <span class="hljs-comment">// 等待线程完成，确保 producerThread 线程执行完毕后才能执行下一个线程，否则各个线程执行程度不一比较混乱</span>    <span class="hljs-comment">// 换句话说，join() 方法会阻塞当前线程（通常是主线程），保证主线程在所有子线程执行完毕后再继续执行（不会提前结束）</span>    producerThread.<span class="hljs-built_in">join</span>();    consumerThread.<span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>PS：在上面的C++例子中，不需要手动对互斥锁解锁，当进程的方法结束时，lock对象离开其作用域后，若互斥锁 mutex 还处于锁定状态，那么在 unique_lock对象的析构之时会自动解锁（对象被销毁了）。在某些循环中，用户或许需要使用lock.unlock() 进行手动解锁。</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>码农日记（一）</title>
    <link href="/2024/03/21/Programming/"/>
    <url>/2024/03/21/Programming/</url>
    
    <content type="html"><![CDATA[<h2 id="linux文件操作">Linux文件操作</h2><p>Linux是一种自由和开放源码的类UNIX操作系统。Linux遵循GNU通用公共许可证（GPL），任何个人和机构都可以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。</p><p>目前主流的Linux版本有：<br/> Debian（及其派生版本Ubuntu、LinuxMint）<br/> Fedora（及其相关版本CentOS、Red Hat Enterprise Linux）<br/>openSUSE...</p><p>由于Linux网上各种教程很多，因此本节只对我（现阶段）在日常工作和学习中最常用的指令（文件相关）进行总结。</p><h3 id="远程登录">远程登录</h3><p>Linux系统启用了sshd服务后，可以进行远程操作。该服务监听22号端口。</p><h3 id="vi-and-vim">vi and vim</h3><p>Linux系统会内建vi文本编辑器，vim是vi的增强版本。</p><p>vi和vim的三种常见模式：</p><ul><li><p>正常模式：一般模式，默认打开进入的模式，通过 vim xxx加回车就会直接进入该模式。</p></li><li><p>插入模式：编辑模式，在正常模式下键入：i（或者a、o）加回车（Enter）会进入此模式，可以对文本进行编辑，按ESC 退出至正常模式。</p></li><li><p>命令模式：键入冒号 :后（或者/）就进入了该模式，然后可以接着键入一些表示命令的字符进行实现相关的命令，按ESC 退出至正常模式。</p></li></ul><p>进入插入模式的几种方式：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span>  从当前光标位置开始输入<span class="hljs-selector-tag">a</span>  从光标后面一位开始输入o  在光标下面创建一个空行开始输入</code></pre></div><p>正常模式下进入命令模式并进行相应操作的指令：</p><div class="code-wrapper"><pre><code class="hljs elixir"><span class="hljs-symbol">:wq</span>  写入（保存）并退出<span class="hljs-symbol">:q!</span>  不保存，只退出<span class="hljs-symbol">:q</span>  仅退出，适用于查看但未作修改的情形<span class="hljs-symbol">:set</span> nu  显示行号<span class="hljs-symbol">:set</span> nonu  取消行号<span class="hljs-symbol">:</span><span class="hljs-number">100</span>  跳转到第<span class="hljs-number">100</span>行</code></pre></div><p>vim快捷键（正常模式下）：</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">yy</span>  复制当前光标所在的这一行<span class="hljs-selector-tag">p</span>  粘贴<span class="hljs-selector-tag">dd</span>  删除当前光标所在的这一行（但会复制，可配合<span class="hljs-selector-tag">p</span>实现剪切）/<span class="hljs-selector-tag">key</span>  查找<span class="hljs-selector-tag">key</span><span class="hljs-selector-tag">x</span>  实现单个字符的删除（剪切）<span class="hljs-selector-tag">u</span>  撤销上一步动作<span class="hljs-selector-tag">q</span>  进入/退出记录，对想重复自动执行（如累加）的语句进行记录    <span class="hljs-selector-tag">q</span>用法示例: <span class="hljs-selector-attr">[对 test 0 = 1 重复8次，且数值每次自增1]</span>    键入:<span class="hljs-selector-tag">q</span> <span class="hljs-selector-tag">-</span>&gt; 输入标记符(例如:f) <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">yy</span>+<span class="hljs-selector-tag">p</span>复制语句 <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">Ctrl</span> <span class="hljs-selector-tag">A</span> 自增<span class="hljs-number">1</span>    <span class="hljs-selector-tag">-</span>&gt; 键入:<span class="hljs-selector-tag">q</span>(退出记录) <span class="hljs-selector-tag">-</span>&gt; 输入:<span class="hljs-number">8</span>@<span class="hljs-selector-tag">f</span></code></pre></div><p>编辑文件文本时（正常模式下）：</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">G</span>  定位至最后一行<span class="hljs-variable">gg</span>  定位至第一行<span class="hljs-variable">H</span>  左移<span class="hljs-variable">J</span>  下移（<span class="hljs-variable">J</span>小）<span class="hljs-built_in">K</span>  上移（<span class="hljs-built_in">K</span>大）<span class="hljs-variable">L</span>  右移</code></pre></div><h3 id="关机">关机</h3><div class="code-wrapper"><pre><code class="hljs arduino">shutdown -h now  立即关机shutdown -h <span class="hljs-number">5</span>  <span class="hljs-number">5</span>min后关机shutdown -r now / reboot  立即重启sync  将内存数据存入磁盘防止丢失</code></pre></div><h3 id="用户管理">用户管理</h3><div class="code-wrapper"><pre><code class="hljs vim">su - user_name  切换用户所在账号su - root  切换管理员用户登录whoami / who <span class="hljs-keyword">am</span> i  查看当前登录的是哪个用户<span class="hljs-keyword">ps</span> -ef  查看所有进程信息top  实时显示进程状态用户<span class="hljs-keyword">w</span>  查看当前活动用户<span class="hljs-keyword">last</span>  查看用户登录日志</code></pre></div><h3 id="设备">设备</h3><div class="code-wrapper"><pre><code class="hljs tcl">uname -a  查看当前Linux操作系统的内核信息cat /etc/issue  查看当前操作系统发行版信息cat /<span class="hljs-keyword">proc</span>/version  查看当前操作系统的版本信息<span class="hljs-title"></span><span class="hljs-title">hostname</span>  查看服务器的名称<span class="hljs-title"></span><span class="hljs-title"></span><span class="hljs-title">df</span> -lh  查看磁盘空间<span class="hljs-title"></span><span class="hljs-title">free</span> -m  以兆字节（MB）显示内存信息<span class="hljs-title"></span><span class="hljs-title">lsblk</span>  查看磁盘信息，列出所有可用块设备的信息及其依赖关系<span class="hljs-title"></span><span class="hljs-title"></span><span class="hljs-title">nvidia-smi</span>  查看显卡、驱动等相关信息<span class="hljs-title"></span><span class="hljs-title">watch</span> -n 1<span class="hljs-title"> nvidia-smi</span>  实时追踪显卡使用情况（每隔1秒自动刷新）<span class="hljs-title"></span><span class="hljs-title">gpustat</span>  高亮显示GPU信息<span class="hljs-title"></span><span class="hljs-title">gpustat</span> -i  高亮显示GPU信息·实时版（每秒刷新1次）<span class="hljs-title"></span><span class="hljs-title">nvitop</span> [-m<span class="hljs-title"> full]</span>  彩色 [完整] 显示GPU信息</code></pre></div><h3 id="网络">网络</h3><div class="code-wrapper"><pre><code class="hljs dos"><span class="hljs-built_in">ping</span> ip_address  检测当前主机/服务器是否可以连接ip_address所在的主机/服务器/网址（检查网络连接）ifconfig  查看当前网络信息注：<span class="hljs-built_in">ipconfig</span> 是Windows <span class="hljs-built_in">CMD</span>下的指令</code></pre></div><h3 id="文件系统">文件系统</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span>  显示当前工作目录（即文件夹）的绝对路径。<span class="hljs-built_in">ls</span> [Ops] 目录/文件名  显示目录或文件的内容。Ops（Options，选项）：-a 显示所有；-l 以列表形式显示<span class="hljs-built_in">cd</span> addr  切换到指定路径。<span class="hljs-built_in">cd</span> 或 <span class="hljs-built_in">cd</span> ~ 回主（家）目录；<span class="hljs-built_in">cd</span> / 回根目录；<span class="hljs-built_in">cd</span> .. 回上级目录<span class="hljs-built_in">mkdir</span> [Ops] directory_name  创建新的目录，不带选项只能创建单级空目录。Ops：-p 创建多级目录；-v 显示单次创建信息<span class="hljs-built_in">touch</span> file_name  创建新的文件，可以一次性创建多个空文件（当前目录）：<span class="hljs-built_in">touch</span> A.txt B.md<span class="hljs-built_in">rmdir</span> [Ops] 空目录名  删除空目录，不带任何选项时只删除该空目录。Ops：-p 删除该空目录，删除后若其父目录也为空，则一并删去<span class="hljs-built_in">rm</span> [Ops] f/d_name  删除文件或目录，不带任何选项时只能删除文件。Ops：-r （递归）删除整个文件夹；-f 强制删除不提示；-i 提醒用户确认Tips：<span class="hljs-built_in">rm</span> -rf  相当于<span class="hljs-built_in">rm</span> -r -f，强制删除所有文件/文件夹！<span class="hljs-built_in">cp</span> [Ops] f/d_name New_d_name  拷贝文件f或文件夹d至指定的目录New_d中，不带任何选项只能复制文件。Ops：-r （递归）拷贝整个文件夹；-f 覆盖目标同名文件或目录时不提醒（强制覆盖）；-i 覆盖目标同名文件或目录时提醒用户确认；不提示也可写为：\<span class="hljs-built_in">cp</span> f/d New_d<span class="hljs-built_in">mv</span> 原名 新名  为文件/目录重新起名或移动。若路径不变则是重命名，路径不一致将不保留原文件/目录（剪切）。&gt;  输出重定向：写入并覆盖（替换）原本内容。&gt;&gt;  追加：将内容加在末尾，不会覆盖原内容。<span class="hljs-built_in">head</span> filename  显示该文件前 10 行（默认行数）的内容。<span class="hljs-built_in">head</span> -n 5 filename  显示文件前 5 行内容。<span class="hljs-built_in">tail</span> filename  显示该文件后 10 行（默认行数）的内容。<span class="hljs-built_in">tail</span> -n 5 filename  显示文件后 5 行内容。<span class="hljs-built_in">tail</span> -f filename  实时追踪该文件的所有更新信息。zip destination_file.zip source_file.txt  将.txt压缩为.zip文件后存入当前路径。Ops：-r 递归压缩整个文件夹unzip *.zip  解压文件unzip -d /*path*/ *.zip  解压后存入指定路径tar  打包指令，打包后的文件格式为 .tar.gz，也可以解包，由选项控制。Ops：-c 打包；-x 解包；-v 显示详细信息；-f 指定压缩后的文件名；-z 打包的同时压缩tar -zcvf UFO.tar.gz a.txt b.txt  将a、b用一套组合拳打包成UFO后存入当前路径tar -zxvf UFO.tar.gz [-C /*directory*/]  解包UFO文件，-C 指定解包后文件的存储路径<span class="hljs-built_in">history</span>  查看所有已经执行过的指令。<span class="hljs-built_in">history</span> n  查看最近使用过的 n 条指令。!x  执行编号为 x 的历史指令（所有历史指令都有编号）。</code></pre></div><p><img src="/img/stage2/004.png" /></p><h2id="java学习笔记面向对象三大特征">Java学习笔记：面向对象三大特征</h2><p>C语言面向过程，强调步骤和因果关系，耦合度高（一个关系错误整个就错了），扩展力差。<br/>C++既面向过程、又面向对象。<br/>Java面向对象，每个事物都是对象，各自协同形成系统，耦合度低，扩展力强。</p><p>面向对象分析：OOA(Object-Oriented Analysis) <br/>面向对象设计：OOD(Object-Oriented Design) <br/>面向对象编程：OOP(Object-Oriented Programming)</p><p>面向对象的三大特征：<font color="red">封装(encapsulation)</font>、<font color="green">继承(inheritance)</font>、<font color="purple">多态(polymorphism)</font>。</p><h3 id="前置知识类和对象">前置知识：类和对象</h3><p>类：某些特征、性质的总结，抽象的模板。类是具有相同属性（数据、变量）和方法（实现功能的函数）的对象集合。普通公共类Animal的创建：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal</span> &#123;    ...&#125;</code></pre></div><p>对象：类实例化的具有特定接口的内存块，也叫实例。对象通过类(Animal)来创建：<code>Animal ani = new Animal();</code></p><p>new运算符会在JVM（Java VirtualMachine，Java虚拟机）的堆内存中开辟一块空间，将创建的对象放入堆内存空间中。程序运行时，JVM中的类加载器classloader会先加载类（.class文件），装载到JVM后由解释器将字节码翻译为二进制数据，供操作系统（OS）与硬件交互。</p><p>保存了内存地址并指向堆内存对象的变量叫引用，通过(引用.对象名)的方式可以访问实例变量（堆内存中存储的对象的实例变量）。其他语言如C++、Python等也可以以此类推。引用相当于C语言中的指针（Java没有指针这个概念）。</p><p>构造方法（也叫构造器、Constructor、构造函数）是用来创建对象并对实例变量进行初始化（赋值）的一种特殊方法。无参构造方法是系统默认提供的，也叫缺省构造器，如果用户手动编写了有参构造器，系统就不会再提供缺省构造器了，因此需要加上无参构造器防止出错。构造方法名必须与类名一致，且不需要写返回值类型。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span><span class="hljs-params">(形参列表)</span> </span>&#123;    ...&#125;</code></pre></div><p>普通方法带关键字static，static修饰静态方法（或变量），是类相关的，通过(类名.)的形式调用，同一类中(类名.)可以省略。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dosome</span>()</span> &#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;DOSOME!&quot;</span>);&#125;</code></pre></div><p>实例方法不带static，是对象相关的，通过(引用.)的形式调用。需要用类实例化对象，才能用对象名（引用）调用实例方法或访问实例变量。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dosome</span>()</span> &#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;DOSOME!&quot;</span>);&#125;</code></pre></div><h3 id="封装">封装</h3><p>封装，就是将各种对数据的操作封在一起，成为不可分割的独立整体，尽可能隐藏内部细节，只保留一些对外的接口与外界发生关系。外部人员不能随便访问，保护内部数据和结构的安全。即：属性“私有化”。</p><p>注意，不是用private关键字将属性私有后什么也不管了，这样该属性只能在本类中访问，而不能在其它类中访问了，过度的安全意义不大。正确做法：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">private</span> int age;    <span class="hljs-keyword">public</span> int <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAge</span>(<span class="hljs-params">int <span class="hljs-built_in">number</span></span>) &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">number</span>&lt;<span class="hljs-number">0</span> || <span class="hljs-built_in">number</span>&gt;<span class="hljs-number">130</span>) &#123;            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;输入年龄不合法!&quot;</span>);            <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 结束方法</span>        &#125;        age = <span class="hljs-built_in">number</span>;    &#125;&#125;</code></pre></div><p>这种做法的好处是只提供外部接口对类内的属性进行访问和修改，且修改需要满足一定的条件，在一定程度上保证了内部数据的安全，并且屏蔽了复杂、显露了简单。可以在另一个类中进行访问：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;  <span class="hljs-comment">// 程序入口</span>        <span class="hljs-title class_">Person</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(p.<span class="hljs-title function_">getAge</span>());  <span class="hljs-comment">// 读取年龄</span>        p.<span class="hljs-title function_">setAge</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 修改年龄为10（年龄合法，修改成功）</span>    &#125;&#125;</code></pre></div><h3 id="继承">继承</h3><p>代码封装后形成了独立体，但是独立体之间可能存在继承关系。比如两个类：Animal和Dog，很明显Dog属于（继承）Animal。继承关键字：extends。</p><p>子类继承父类，则父类中已经定义的方法，子类可以直接拿来用，实现了代码复用。而且有了继承，多态机制才能发挥作用，方法覆盖才有用武之地。</p><p>当多个类共用一些属性时（不同类也可能有相同的一些特性），将这些属性、方法都放在某一个类中作为通用类（父类），让其他类共享，其他类为特定类（子类）。这就是子类继承父类。父类中的属性和方法，子类可以“直接用”，不需要重新定义和编写代码。若B类继承A类，则A类是Superclass，即父类、超类、基类；B类是Subclass，即子类、派生类、扩展类。</p><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;    ...&#125;</code></pre></div><p>Java中规定，子类继承父类，除了构造方法外的所有都可以继承。但是private关键字修饰的私有属性在子类中是无法直接访问的。虽然私有属性被继承过来了，但是仍然是属于父类的，子类中访问跟“外界”访问的方式一样，通过对外的接口方法：getter和setter方法。且Java中默认父类（没有用extends的类）都继承跟类Object，这是老祖宗类。继承以后，耦合度变高了。</p><p>只要满足“A is a B”这种关系的，比如Dog is a Animal，就可以继承。</p><p>子类继承了父类的属性和方法时，若某些方法不符合自己的要求，子类可以重写一遍该方法，此为<font color="purple">Override</font>，即方法覆盖或方法重写。此时，子类对象调用该方法，执行的是子类中重写的新方法，就不再是父类中的老方法了。重写的方法除了方法体和返回值类型之外，其他部分必须与父类一直，比如方法名、形参列表等。访问权限不能低于父类，但可以更高，比如父类是protected，重写后是public，这是可行的，但反过来不行。另外，重写后的方法不能比父类的原方法抛出更多异常。</p><p>方法覆盖注意事项：只针对方法，与属性无关；私有方法不能被覆盖；构造方法无法被继承，故不存在覆盖这一说；只针对实例方法，静态方法的覆盖是没有意义的（静态方法即便覆盖了，用了(引用.)的形式调用，本质上还是转换为了(类名.)的形式，其实与对象（子类）没有任何关系，也就不存在多态这一说。因此一般认为静态方法不存在方法覆盖）。</p><h3 id="扩展抽象类">扩展：抽象类</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的。如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</p><p>在Java语言中使用abstract class来定义抽象类。</p><h3 id="多态">多态</h3><p>多态是同一个行为具有多个不同的表现形式或形态的能力，即同一行为发生在不同的对象上会产生不同的效果。换句话说，多态就是同一个接口，使用不同的实例而执行不同的操作。</p><p>多态可以降低类型之间的耦合关系，具有可替换、可扩充的性质，简单而灵活。多态存在有三个必要条件：继承、方法重写、父类引用指向子类对象。</p><figure><img src="/img/stage2/005.jpg" alt="多态的实现举例" /><figcaption aria-hidden="true">多态的实现举例</figcaption></figure><p>在Java中对多态的核心表现主要是方法的重写。方法的重写（覆盖），一言以蔽之：同一个父类的方法，可以根据子类的不同而具有不同的表现形式。</p><p>多态有两种类型。由子类转向父类，是向上转型；由父类转向子类，是向下转型。不管是向上转型还是向下转型，两个类之间必须是继承关系，即父类与子类。下面是关于多态的实例分析。</p><p><font color="bluepurple">向上转型(upcasting)</font>:</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()  <span class="hljs-comment">// 父类中的实例方法</span></span>    &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;a is moving!&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-title">extends</span> <span class="hljs-title">Animal</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()  <span class="hljs-comment">// 子类重写了实例方法</span></span>    &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;c is wandering!&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;        Animal ac = <span class="hljs-keyword">new</span> Cat();  <span class="hljs-comment">// 向上转型</span>        ac.move();  <span class="hljs-comment">// 输出：c is wandering!</span>    &#125;&#125;</code></pre></div><p>向上转型，即允许父类型引用指向子类型对象。编译时，编译器只知道ac是Animal类型，因此会去Animal.class（类）字节码中寻找move()方法，而Animal中有此实例方法，因此会被找到。找到了以后，编译器认为ac要访问的方法move()存在，编译通过，此为<strong>静态绑定</strong>。运行时，堆内存中实际创建的其实是Cat对象，不是Animal类型对象，因此通过(引用.)的方式调用执行的move()方法是Cat中的实例方法，此为<strong>动态绑定</strong>。编译（静态绑定父类的方法）、运行（动态绑定子类型对象的方法）各有一种形态，故名多态。</p><p>不管是否发生了向上转型，核心的本质还是在于：你使用的是哪一个子类（new了什么），而且调用的方法是否被子类所覆写了。想一想为什么要使用向上转型？假设父类有N个子类，子类中重写了父类的实例方法，如果没有向上转型，有N个子类就需要定义N个方法接收不同的对象。向上转型可以减少重复代码，且实例化的时候可以根据不同的需求实例化不同的对象，实现参数的统一化。具体的意义用得多了自然就明白了，下面举一个例子进行解释。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 我们需要写getMessage()方法接收不同子类的对象并调用它们的实例方法print()输出各个子类的相关信息</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">getMessage</span>(<span class="hljs-params">Student stu</span>) &#123;    stu.<span class="hljs-title function_">print</span>();&#125;<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">getMessage</span>(<span class="hljs-params">Tescher ter</span>) &#123;    ter.<span class="hljs-title function_">print</span>();&#125;<span class="hljs-comment">// 如果还有很多子类，那么需要写很多的方法</span><span class="hljs-comment">// 使用向上转型进行代码复用，只需写一个方法来接收所有Person类的子类对象，实现了参数的统一化</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">getMessage</span>(<span class="hljs-params">Person per</span>) &#123;  <span class="hljs-comment">// 把对象传入，自动进行upcasting</span>    per.<span class="hljs-title function_">print</span>();&#125;</code></pre></div><p>如果子类中写了独有的方法，向上转型用父类型的引用访问子类型的专有方法时会出错，因为静态绑定失败（父类型中没有此方法）。此时就需要用向下转型进行强制类型转换了。</p><p><font color="bluepurple">向下转型(downcasting)</font>:</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()  <span class="hljs-comment">// 父类中的实例方法</span></span>    &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;a is moving!&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-title">extends</span> <span class="hljs-title">Animal</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span>()  <span class="hljs-comment">// 子类重写了实例方法</span></span>    &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;c is wandering!&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CatchMouse</span>()  <span class="hljs-comment">// 子类特有方法</span></span>    &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;c can catch mouse, can you?&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;        Animal ac = <span class="hljs-keyword">new</span> Cat();  <span class="hljs-comment">// 先向上转型</span>        <span class="hljs-keyword">if</span>(ac instanceof Cat) &#123;  <span class="hljs-comment">// 判断引用指向的对象类型是否匹配，互相匹配才可以强制转换</span>            Cat x = (Cat)ac;  <span class="hljs-comment">// Animal类型的ac与Cat有继承关系，可以强制父类-&gt;子类转换，即向下转型</span>            x.CatchMouse();  <span class="hljs-comment">// 输出：c can catch mouse, can you?</span>        &#125;    &#125;&#125;</code></pre></div><p>通过对象的向上转型可以实现接收参数的统一，向下转型可以实现子类扩充的调用（一般不操作向下转型，有安全隐患，不过搭配instanceof使用可以提高安全性）。注意：向下转型之前一定要进行向上转型！</p><h3 id="知识迁移overload与命名空间">知识迁移：Overload与命名空间</h3><p><font color="purple">Overload</font>，即方法重载，同一个方法名称可以根据参数类型或者参数个数的不同而调用不同的方法体。如果功能相近的几种方法需要各自取名时，未免过于繁琐，且名字太多调用不方便。故而引入方法重载解决这个问题。方法重载使得功能相同或相近的方法可以用同一个名字，利用不同的参数来分别选用不同的方法。触发Overload机制的条件：在同一个类中；方法名相同；参数列表不同。以上三个条件同时满足时，我们认为触发了方法重载机制，比如<code>m() 与 m(int a)</code>、<code>m(int i, double j) 与 m(double i, int j)</code>等，下面是一个例子。</p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-comment">// 定义了两种的方法，但都是进行求和运算</span><span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>(<span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j)&#123;    <span class="hljs-keyword">return</span> i + j;&#125;<span class="hljs-built_in">double</span> <span class="hljs-keyword">sum</span>(<span class="hljs-built_in">double</span> i, <span class="hljs-built_in">double</span> j)&#123;    <span class="hljs-keyword">return</span> i + j;&#125;<span class="hljs-comment">// 主函数（方法）中通过参数匹配从而进行不同的调用</span><span class="hljs-built_in">int</span> a = <span class="hljs-keyword">sum</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);  <span class="hljs-comment">// outpit: a == 30</span><span class="hljs-built_in">double</span> b = <span class="hljs-keyword">sum</span>(<span class="hljs-number">10.0</span>,<span class="hljs-number">20.0</span>);  <span class="hljs-comment">// output: b == 30.0</span></code></pre></div><p>方法覆盖与重载的详细对比点此查看：<ahref="https://www.runoob.com/java/java-override-overload.html">runnoob:java - override and overload</a></p><p>C++中有一个概念叫：<font color="purple">命名空间</font>，是一个由程序设计者命名的内存区域，它定义了一个包含多个变量和函数的范围，使其不会与命名空间以外的任何变量和函数发生重名的冲突。每个程序员可以定义自己的命名空间，多个工程师开发同一个项目时，对程序的管理更加便捷和高效。命名空间的关键字是namespace，命名空间可以相互分隔不同的全局实体，但是命名空间不能同名。在成员名字这个方面，我觉得命名空间与方法覆盖和方法重载有异曲同工之妙。下面是关于命名空间的简单C++示例：</p><div class="code-wrapper"><pre><code class="hljs kotlin">#include &lt;iostream&gt;<span class="hljs-comment">// std是输入输出标准的类，它包括了cin和cout成员（内置对象）</span><span class="hljs-comment">// 利用此语句可以直接使用这些成员函数</span><span class="hljs-comment">// 如果没有此语句，那么需要用 std::cin 或者 std::cout 进行使用</span>using namespace std;namespace first_field  <span class="hljs-comment">/* 第一个命名空间 */</span>&#123;    void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>    &#123;        <span class="hljs-comment">// cout与流插入运算符 &lt;&lt; 搭配使用（cin与流提取运算符 &gt;&gt; 搭配使用）</span>        cout &lt;&lt; <span class="hljs-string">&quot;第一个命名空间所包含的内容&quot;</span> &lt;&lt; endl;    &#125;&#125;namespace second_field  <span class="hljs-comment">/* 第二个命名空间 */</span>&#123;        void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;第二个命名空间所包含的内容&quot;</span> &lt;&lt; endl;    &#125;&#125;<span class="hljs-comment">// 主函数（程序入口）</span>int main()&#123;    namespace FF = first_field;  <span class="hljs-comment">/* 为第一个命名空间起个别名 */</span>    first_field::<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">/* 调用第一个命名空间中的函数 */</span>    FF::<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 同上</span>    second_field::<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">/* 调用第二个命名空间中的函数 */</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="内存块">内存块</h2><h3 id="数据结构中的内存">数据结构中的内存</h3><p>内存一般分成以下6个区：</p><p>栈区（Stack）：编译器自行分配、自行释放，存放局部变量的值、函数（方法）参数、寄存器内容、函数返回的地址等。栈相当于一个受限的线性表，主要用于数据交换、函数调用、断点保护等，空间不大，随用随消。</p><p>堆区（Heap）：由程序员进行分配、释放，如Java中的new操作。堆相当于一个特殊的完全二叉树，空间大，主要用来存放大量文件，操作类似于链表。</p><p>自由存储区：由malloc等进行分配的内存块，用free释放空间。与堆的new生成和delete释放类似。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/* C语言申请内存空间 */</span><span class="hljs-comment">// 顺序表的指针变量</span>SeqList *L;<span class="hljs-comment">// malloc函数可以动态分配内存空间，向操作系统申请(SeqList)类型大小的内存空间，返回第一个字节地址</span><span class="hljs-comment">// (SeqList*)强制转换为地址类型，否则只是干地址，无实际含义</span>L = (SeqList*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SeqList));<span class="hljs-comment">/* Java创建对象 */</span>Student stu = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>();</code></pre></div><p>文字常量区：存放常量、字符串。</p><p>程序代码区：存放函数的二进制代码。</p><p>全局/静态存储区：分配全局、静态变量。</p><h3 id="引申字面量常量和变量">引申：字面量、常量和变量</h3><p>先看下面的C++代码例子：</p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> a;  <span class="hljs-comment">// 变量</span><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> b = <span class="hljs-number">10</span>;  <span class="hljs-comment">// b为常量，10为字面量</span>string <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello world!&quot;</span>;  <span class="hljs-comment">// str为变量，hello world!为字面量</span></code></pre></div><p>在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串,有很多也对布尔类型和字符类型的值支持字面量表示，还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值支持字面量表示法。</p><p>有些数据在程序运行中可以变化或者被赋值，这称为变量。有些数据可以在程序使用之前预先设定并在整个运行过程中没有变化，这称为常量。变量和常量在内存中的存储方式是一样的，只是常量不允许改变，就像只读文件一样。</p><p>字面量是指由字母、数字等构成的字符串或者数值，它只能作为等号右边的值出现，相当于真实值。</p><p>Java中，成员变量就是定义在类里方法外的变量，也叫全局变量。成员变量又分为：实例变量和类变量。类变量也叫静态变量，即在变量前加static的变量；实例变量也叫对象变量，即没加static修饰的变量。静态变量和实例变量的区别在于：静态变量是所有对象共有的，其中一个对象将它的值改变了，那么其他对象得到的就是改变后的结果；而实例变量则为对象专有，若某一个对象将其值改变，不会影响其他对象。如果局部变量和成员变量的名称相同，那么成员变量被隐藏，即方法内失效，方法中如需要访问该类中的成员变量，则需要加上关键字this。</p><h3 id="java虚拟机jvm中的空间">Java虚拟机JVM中的空间</h3><p>JVM中主要有三块空间：栈区、方法区、堆区。</p><p>当一个Java程序运行时，JVM中的类加载器ClassLoader将硬盘上的xxx.class字节码文件存入方法区中（程序类最先加载），即方法区最先有数据（代码片段）。同时静态变量也会被存储在方法区。</p><p>在方法（方法区中的代码片段）被调用时，所需要的内存空间在栈中分配，进栈（或称压栈、入栈）为push，出栈（或称弹栈）为pop。方法调用时为压栈（为方法中的局部变量和运行所需的内存分配空间），方法结束空间释放时是弹栈。</p><p>堆区是由程序员对类和对象进行操作时用到的。当使用new运算符创建对象后，JVM的堆内存会开辟一块空间（垃圾回收器主要针对的就是堆内存），将创建的对象以及对象的实例变量存储在其中。</p><p>​​​​成员变量的存储：没有实例化的成员变量放在栈中，实例化后的对象放在堆中，栈中放的是指向堆中对象的引用地址。成员变量在对象被创建时而存在，当对象被GC（GarbageCollection，垃圾回收机制）回收时消失，生存周期适中。</p><h2 id="c数组与指针">C++数组与指针</h2><p>当时大学初学C语言时，就被指针、一维数组和二维数组等相关知识绕了好久。C++的指针与C差不多，这里用几段程序对这个容易混淆的知识点进行总结。</p><h3 id="引用为返回值">引用为返回值</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<span class="hljs-comment">/* 把引用作为返回值，与返回指针类似，相当于返回一个指向返回值的隐式指针，可以作为赋值语句的左值 */</span><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">value</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><span class="hljs-function"><span class="hljs-comment">/* 如果这样定义: int value(int i)，执行下面的 value(0)=1 和 value(3)=20 就会报错，提示左值不对 */</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> a[i];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> i;    cout &lt;&lt; <span class="hljs-string">&quot;Before change:&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;a[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; a[i] &lt;&lt; endl;    &#125;    <span class="hljs-comment">/* 修改数组的值，赋值语句合法 */</span>    <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span>;    <span class="hljs-built_in">value</span>(<span class="hljs-number">3</span>) = <span class="hljs-number">20</span>;    <span class="hljs-comment">/* 输出a(数组)的类型，我的输出的是缩写 */</span>    cout &lt;&lt; <span class="hljs-string">&quot;type of value&#x27;s return is: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>() &lt;&lt; endl;  <span class="hljs-comment">// A5_i</span>    <span class="hljs-comment">/* 输出a(数组)的类型全称，要加上头文件: #include &lt;cxxabi.h&gt; */</span>    cout &lt;&lt; abi::__cxa_demangle(<span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>(),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> ) &lt;&lt; endl;  <span class="hljs-comment">// int [5]</span>    cout &lt;&lt; <span class="hljs-string">&quot;After change:&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;a[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; a[i] &lt;&lt; endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="d-and-2d-array">1D and 2D Array</h3><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_1d</span>()</span>;  <span class="hljs-comment">/* 一维数组辨析 */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_2d</span>()</span>;  <span class="hljs-comment">/* 二维数组辨析 */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_1d</span>()</span>&#123;    <span class="hljs-built_in">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;    <span class="hljs-built_in">int</span> *ap = nullptr;    ap = &amp;a[<span class="hljs-number">0</span>];  <span class="hljs-comment">/* 将数组首个元素a[0]的地址赋给指针ap */</span>    ap = a;  <span class="hljs-comment">/* 与上个语句等价 */</span>    cout &lt;&lt; <span class="hljs-string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; endl;  <span class="hljs-comment">// 0</span>    *ap = <span class="hljs-number">10</span>;  <span class="hljs-comment">/* 修改第1个元素的值 */</span>    cout &lt;&lt; <span class="hljs-string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; endl;  <span class="hljs-comment">// 10</span>    cout &lt;&lt; <span class="hljs-string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="hljs-number">1</span>] &lt;&lt; endl;  <span class="hljs-comment">// 1</span>    *(ap+<span class="hljs-number">1</span>) = <span class="hljs-number">20</span>;  <span class="hljs-comment">/* 修改下一个(第2个)元素a[1]的值 */</span>    *(a+<span class="hljs-number">1</span>) = <span class="hljs-number">20</span>;  <span class="hljs-comment">/* 与上个语句等价 */</span>    cout &lt;&lt; <span class="hljs-string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="hljs-number">1</span>] &lt;&lt; endl;  <span class="hljs-comment">// 20</span>    cout &lt;&lt; a &lt;&lt; endl;  <span class="hljs-comment">// 输出了数组a代表的地址: &amp;a[0]</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_2d</span>()</span>&#123;    <span class="hljs-built_in">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;;    <span class="hljs-built_in">int</span> *p1, *p2, *p3;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">4</span>; j++)        &#123;            cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        &#125;        cout &lt;&lt; endl;    &#125;    p1 = &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];  <span class="hljs-comment">/* 将数组第一行第一个元素a[0][0]的地址赋给指针p1 */</span>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; *p1 &lt;&lt; endl;  <span class="hljs-comment">// 1</span>    p2 = a[<span class="hljs-number">0</span>];  <span class="hljs-comment">/* 将数组第一行的起始地址a[0](1维数组名)赋给指针p2 */</span>    cout &lt;&lt; *p2 &lt;&lt; endl;  <span class="hljs-comment">// 1</span>    cout &lt;&lt; *(p2+<span class="hljs-number">1</span>) &lt;&lt; endl;  <span class="hljs-comment">// 2   p2+1是p2指向的行（首元素地址）的下一个（第2个）元素的地址，故输出a[0][1]</span>    cout &lt;&lt; *(a[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>) &lt;&lt; endl;  <span class="hljs-comment">/* 与上条语句等价，+1可以认为是地址偏移量，C++数组按行优先存储，故向右移动1个单位 */</span>    cout &lt;&lt; *(p2+<span class="hljs-number">3</span>) &lt;&lt; endl;  <span class="hljs-comment">// 4   输出a[0][3]</span>    <span class="hljs-comment">/* a代表二维数组的地址(指向首个元素)，不能直接将a赋值给(int*)类型的指针变量p3，类型不统一。</span><span class="hljs-comment">    但*a可以，因为*a代表a[0] */</span>    p3 = *a;    p3 = a[<span class="hljs-number">0</span>];  <span class="hljs-comment">/* 与上条语句等价 */</span>    cout &lt;&lt; *p3 &lt;&lt; endl;  <span class="hljs-comment">// 1</span>    <span class="hljs-comment">/* a表示二维数组地址，因此a+1是向下一行进行偏移 */</span>    cout &lt;&lt; **(a+<span class="hljs-number">1</span>) &lt;&lt; endl;  <span class="hljs-comment">// 5   **(a+1)相当于*a[1]，即第2行起始地址指向的元素: a[1][0]</span>    cout &lt;&lt; *(*a+<span class="hljs-number">1</span>) &lt;&lt; endl;  <span class="hljs-comment">// 2   注意与上条语句区分: *a+1 = (*a)+1 = a[0]+1</span>        <span class="hljs-comment">/* 总结: *(a[i]+j) 与 *(*(a+i)+j) 是一样的，都是a[i][j]的值。</span><span class="hljs-comment">             Type(a[0]): int [4] (A4_i)   Type(a): int [3][4] (A3_A4_i) */</span>&#125;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;    test_1d();    test_2d();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>关于二维数组名 a 和 int*指针变量类型不统一的问题，若是强行赋值：<code>p3 = a;</code>，则会报错：<code>error: cannot convert 'int [3][4]' to 'int*' in assignment</code>。若是按照下面的方式定义，则不会出错：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;;<span class="hljs-attribute">int</span> (*p)[<span class="hljs-number">4</span>];<span class="hljs-attribute">p</span> = a;  // Type(p) == int (*)<span class="hljs-meta"> [4]，赋值合法</span></code></pre></div><p><strong>思考</strong>：为什么指针变量 int * 和数组名的类型 int [4]作为左值和右值的关系是对应的（赋值语句合法）？指针变量类型 int (*) [4]和数组名类型 int [3][4] 对应？</p><p><strong>解答</strong>：因为在C语言中，当你将一个数组赋值给一个指针时，编译器会进行类型转换，因此这种赋值是合法的（只要类型对的上）。在上例中，p指向了数组a的第一个一维数组（第1行），而p被定义为一个指向包含4个整数的数组的指针，因此它可以指向a的一维数组元素，类型兼容，故<code>p = a;</code>赋值合法。同理，a是一维数组名时也如此分析即可。还可以从这个角度来理解：<code>int (*p)[4]</code>实际上定义了一个数组指针<code>p</code>，即指向一个数组的指针，因此赋值语句<code>p = a;</code>是正确的。</p><h3 id="字符数组字符指针与字符串">字符数组、字符指针与字符串</h3><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-meta">#include &lt;iostream&gt;</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">void</span> test_str()&#123;    <span class="hljs-comment">/* 左边加入了const是因为：如果不加const，等号两边的变量类型不一样。</span><span class="hljs-comment">    右值是一个不变常量，左值是一个char*指针变量，不是const类型(那就表示可以修改)。</span><span class="hljs-comment">    如果编译通过，那么就说明const(右值，字符串)可以被修改！这显然是不被允许的，因此会弹出警告或报错。 */</span>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;Tom Love C++?!&quot;</span>;  <span class="hljs-comment">/* 用字符指针实现字符串的定义 */</span>    <span class="hljs-built_in">char</span> string_array1[] = <span class="hljs-string">&quot;Tom hate C++!?&quot;</span>;  <span class="hljs-comment">/* 用字符数组存放字符串，结尾是空字符&#x27;\0&#x27;，也计入数组长度 */</span>    <span class="hljs-built_in">char</span> string_array2[] = &#123;<span class="hljs-string">&#x27;T&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-string">&#x27;!&#x27;</span>,<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;  <span class="hljs-comment">/* 也定义了字符串 */</span>    cout &lt;&lt; string_array1 &lt;&lt; endl;  <span class="hljs-comment">// Tom hate C++!?   注意：输出的不是地址！与普通数值类型的数组区分开</span>    cout &lt;&lt; string_array2 &lt;&lt; endl;  <span class="hljs-comment">// Tom hate C++!?</span>    cout &lt;&lt; <span class="hljs-built_in">str</span> &lt;&lt; endl;  <span class="hljs-comment">// Tom Love C++?!</span>    cout &lt;&lt; *<span class="hljs-built_in">str</span> &lt;&lt; endl;  <span class="hljs-comment">// T   注意区别</span>    cout &lt;&lt; <span class="hljs-built_in">str</span>+<span class="hljs-number">1</span> &lt;&lt; endl;  <span class="hljs-comment">// om Love C++?!   T没了！</span>    cout &lt;&lt; *(<span class="hljs-built_in">str</span>+<span class="hljs-number">1</span>) &lt;&lt; endl;  <span class="hljs-comment">// o</span>    <span class="hljs-comment">/* 可以看出，字符指针可以指向字符串中的任意一个字符，很灵活，字符数组则不可以。 */</span>&#125;<span class="hljs-built_in">int</span> main()&#123;    test_str();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>Q</strong>：为什么可以直接用字符型数组的名字输出数组值（字符串），而数值型的比如整型却不行呢？</p><p><strong>A1</strong>：网上的一个答案：在定义流对象，系统会在内存中开辟一段缓冲区，用来暂存输入输出流的数据。在执行cout语句时，先把插入的数据顺序存放在输出缓冲区中，直到输出缓冲区满或遇到cout 语句中的endl（或‘’，ends，flush）为止，此时将缓冲区中已有的数据一起输出，并清空缓冲区。输出流中的数据在系统默认的设备（一般为显示器）输出。因为char 型数组中的每一个元素都是一字节，所以每一个字符之间的地址都是 +1的，是连续的，所以当 cout 输出时读到字符数组中的 '\0' 便停止输出；而 int数组每个元素占 4个字节，所以数组中每个元素地址的间隔是4（尽管其实它也是连续的），且没有结束符。</p><p><strong>A2</strong>：ChatGPT的回答：在C语言中，字符型数组和数值型数组的行为略有不同。当你使用字符型数组的名字时，它会被解释为指向数组第一个元素的指针，而数组的第一个元素通常是一个字符，因此这个指针指向了字符串的首地址。字符串在C语言中以null字符'\0' 结尾，因此你可以通过打印指向字符串的指针来输出整个字符串，因为printf 等函数会一直打印直到遇到null字符为止。C++也一样，cout函数会一直打印直至遇见终止符'\0'。而数值型数组在使用时通常需要通过数组下标来访问其元素，而不是直接输出整个数组。因为数值型数组的名字会被解释为指向数组第一个元素的指针，但printf/cout 不会自动解析整个数组，因此需要循环遍历输出。</p><p>C++为了继承C语言的指针操作，cout 对 char *进行了重载。C语言中，字符串的相关操作基本上都是直接打印其值，而非字符串的地址。因此C++中也是如此。</p><h3 id="指针数组和数组指针">指针数组和数组指针</h3><p><font color="blue">指针数组</font>：是个数组，数组的元素都是指针，是存储指针的一个数组。数组占多少字节（数组占用的内存是连续的）由数组本身决定（与数组的长度有关）。</p><p><font color="red">数组指针</font>：是个指针，指向某一个数组。在32位系统下永远是4个字节（Bytes）。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">/* 定义指针数组 */</span>int *p1<span class="hljs-selector-attr">[10]</span>;<span class="hljs-comment">/* 定义数组指针 */</span>int (*p2)<span class="hljs-selector-attr">[4]</span>;</code></pre></div><p>通过上例进行分析。对 <code>int *p1[10];</code>来说，<code>[]</code>的优先级高于<code>*</code>，所以<code>p1</code>先跟<code>[10]</code>结合，构成一个数组，数组名是<code>p1</code>。<code>int *</code>修饰数组，即数组<code>p1</code>中的每个元素都是<code>int *</code>类型。也就是说，指针数组中的每一个元素都相当于一个指针变量，它的值都是地址。</p><p>而对 <code>int (*p2)[4];</code>来说，<code>()</code>优先级最高，<code>*p2</code>先构成了一个指针的定义，指针变量名是<code>p2</code>，<code>int</code>修饰的是数组的内容，即<code>p2</code>所指数组中的每个元素都是<code>int</code>类型。也就是说，指针<code>p2</code>指向了一个包含4个<code>int</code>类型数据的数组，而且该数组没有名字，是个匿名数组。</p><p>下面是一个示例，简单演示了数组指针的用法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> a[MAX] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">// Type(a) == A5_i (int [5])</span>    <span class="hljs-type">int</span> *ap;  <span class="hljs-comment">// Type(ap) == Pi (int*)</span>    <span class="hljs-built_in">int</span> (*p)[MAX];  <span class="hljs-comment">// Type(p) == PA5_i (int (*) [5])</span>    ap = a;  <span class="hljs-comment">// 合法语句</span>    p = &amp;a;  <span class="hljs-comment">// 合法语句</span>    cout &lt;&lt; *ap &lt;&lt; endl;  <span class="hljs-comment">// 1</span>    cout &lt;&lt; **p &lt;&lt; endl;  <span class="hljs-comment">// 1</span>    cout &lt;&lt; *(*p+<span class="hljs-number">1</span>) &lt;&lt; endl;  <span class="hljs-comment">// 2   相当于: *(a+1)</span>    cout &lt;&lt; (*p)[<span class="hljs-number">4</span>] &lt;&lt; endl;  <span class="hljs-comment">// 5</span>    <span class="hljs-comment">/* p是数组指针，也叫行指针，相当于二维数组名，代表二维数组(首行) */</span>    cout &lt;&lt; **(p+<span class="hljs-number">1</span>) &lt;&lt; endl;  <span class="hljs-comment">// 0   越界了，输出了未定义的内存值，是垃圾数据</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="const指针">const指针</h3><p>C++中，const关键字用来指定不可修改的变量，const修饰的变量类似于常量，值初始化后不能被修改（比如重新赋值），可以使编译器帮助用户定义的某些变量不被意外修改。指针也是变量，可以将const用于指针。用法主要有以下三种：</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-comment">/* 1.指针包含的地址是常量，不能被修改 */</span><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<span class="hljs-type">int</span>* const p = &amp;x;  // p被const修饰，p本身(即p中保存的地址)不能被修改*p = <span class="hljs-number">20</span>;  // x == <span class="hljs-number">20</span>，指向的数据可以被修改<span class="hljs-type">int</span> y = <span class="hljs-number">5</span>;p = &amp;y;  // 报错: error: assignment <span class="hljs-keyword">of</span> <span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span> variable <span class="hljs-string">&#x27;p1&#x27;</span><span class="hljs-comment">/* 2.指针指向的数据不能被修改 */</span><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;const <span class="hljs-type">int</span>* p = &amp;x;  // const在 * 前，修饰指针p指向的内容，所以x的值不能被修改*p = <span class="hljs-number">20</span>;  // 报错: error: assignment <span class="hljs-keyword">of</span> <span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span> <span class="hljs-keyword">location</span> <span class="hljs-string">&#x27;* p&#x27;</span><span class="hljs-type">int</span> y = <span class="hljs-number">5</span>;p = &amp;y;  // p本身可以被修改，现在p指向的是y了<span class="hljs-comment">/* 3.指针本身和它指向的值都是常量，不能被修改 */</span><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;const <span class="hljs-type">int</span>* const p = &amp;x;*p = <span class="hljs-number">20</span>;  // 报错: error: assignment <span class="hljs-keyword">of</span> <span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span> <span class="hljs-keyword">location</span> <span class="hljs-string">&#x27;*(const int*)p&#x27;</span><span class="hljs-type">int</span> y = <span class="hljs-number">5</span>;p = &amp;y;  // 报错: error: assignment <span class="hljs-keyword">of</span> <span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span> variable <span class="hljs-string">&#x27;p&#x27;</span></code></pre></div><p>有时需要禁止通过引用修改它指向的变量的值，为此也可在声明引用时使用const。例如：</p><div class="code-wrapper"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span> = <span class="hljs-number">30</span>;const <span class="hljs-keyword">int</span>&amp; p = <span class="hljs-keyword">x</span>;  <span class="hljs-regexp">//</span> Type(p) == i (<span class="hljs-keyword">int</span>)p = <span class="hljs-number">15</span>;  <span class="hljs-regexp">//</span> 报错: error: assignment of <span class="hljs-keyword">read</span>-only reference <span class="hljs-string">&#x27;p&#x27;</span><span class="hljs-keyword">int</span>&amp; <span class="hljs-keyword">q</span> = p;  <span class="hljs-regexp">//</span> 报错: error: binding reference of type <span class="hljs-string">&#x27;int&amp;&#x27;</span> to <span class="hljs-string">&#x27;const int&#x27;</span> discards qualifiers             // 翻译: 将类型为<span class="hljs-string">&quot;int&amp;&quot;</span>的引用绑定到<span class="hljs-string">&quot;const int&quot;</span>将丢弃限定符，类型不匹配(<span class="hljs-keyword">y</span>未被const修饰)const <span class="hljs-keyword">int</span>&amp; z = p;  <span class="hljs-regexp">//</span> 合法语句(类型相同，可以赋值)</code></pre></div><h3 id="c中引用和指针的区别">C++中引用和指针的区别</h3><p>在C++中，引用（Reference）和指针（Pointer）都是用来间接访问变量的工具，引用提供了一种更安全和更方便的方式来间接访问变量，相当于给变量重新起了个名字，但是又有指针的作用，而指针提供了更多的灵活性和功能，但也带来了更多的潜在错误和安全风险。</p><p>通过指针和引用，你可以直接操作内存，这在很多情况下都非常有用，例如：动态内存分配，函数参数传递，数据结构（如链表和树）等等。</p><p>它们之间有一些重要的区别：</p><h4 id="语法和操作">1.语法和操作</h4><p>指针是一个变量，其存储的是另一个变量的地址。指针需要使用取地址运算符<code>&amp;</code> 来获取变量的地址，并使用解引用运算符 <code>*</code>来访问存储在该地址上的值。指针可以被赋值为 <code>nullptr</code>或者另一个变量的地址，可以进行指针算术运算。</p><p>引用是一个别名，它必须在创建时初始化，并且不能被重新赋值为另一个变量的引用。引用使用<code>&amp;</code>符号进行声明，并且在声明时必须绑定到一个已经存在的变量。对引用的操作就像对变量本身的操作一样，不需要使用解引用运算符。</p><h4 id="空值安全性和错误">2.空值、安全性和错误</h4><p>指针可以指向空值（nullptr），表示不指向任何有效的对象。指针可以有空值，也可以指向任何对象，包括无效的对象或未初始化的对象，这可能导致空指针解引用错误（NullPointer Dereference）或野指针（Dangling Pointer）错误。</p><p>引用不能指向空值，必须在初始化时绑定到一个已经存在的对象，因此不存在空指针或者野指针错误。</p><h4 id="赋值和重定向">3.赋值和重定向</h4><p>指针可以被重新赋值为另一个地址，从而改变其所指向的对象。</p><p>引用一旦绑定到一个对象后，就不能再绑定到其他对象。因此，引用不能像指针一样被重新赋值为另一个对象的引用。</p><h4 id="用途">4.用途</h4><p>指针通常用于动态内存分配、数组、函数指针、实现数据结构等需要灵活处理内存和对象的情况。</p><p>引用通常用于函数参数传递、函数返回值、提高代码可读性和简洁性的情况，如通过引用避免对象的拷贝。</p><p><font color="purple">下面是一段示例代码</font>：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> x = <span class="hljs-number">30</span>;  <span class="hljs-comment">// 假设 x 初始值为 30</span><span class="hljs-type">int</span> y = <span class="hljs-number">50</span>;  <span class="hljs-comment">// 假设 y 初始值为 50</span><span class="hljs-type">int</span>&amp; p1 = x;  <span class="hljs-comment">// 引用 p1 绑定到 x</span><span class="hljs-type">int</span>&amp; p2 = x;  <span class="hljs-comment">// 引用 p2 也绑定到 x</span><span class="hljs-type">int</span>&amp; p3;  <span class="hljs-comment">// 不允许这样写！引用必须在声明时绑定变量！</span><span class="hljs-comment">// p1、p2 均已绑定 x，因此此处的赋值操作会修改 x 的值</span>p2 = y;  <span class="hljs-comment">// 将 x 的值修改为 y 的值，即: x == 50</span>p1 = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 将 x 的值修改为 100</span>p2 = <span class="hljs-number">200</span>;  <span class="hljs-comment">// 将 x 的值修改为 200 (上面的赋值操作都被覆盖了)</span>cout &lt;&lt; <span class="hljs-string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-string">&quot;p1: &quot;</span> &lt;&lt; p1 &lt;&lt; endl; <span class="hljs-comment">// 输出 x 和 p1 的值</span>cout &lt;&lt; <span class="hljs-string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-string">&quot;p2: &quot;</span> &lt;&lt; p2 &lt;&lt; endl; <span class="hljs-comment">// 输出 y 和 p2 的值</span><span class="hljs-comment">// 输出</span>x: <span class="hljs-number">200</span>    p1: <span class="hljs-number">200</span>y: <span class="hljs-number">50</span>    p2: <span class="hljs-number">200</span></code></pre></div><h3 id="传值传指针传引用调用">传值、传指针、传引用调用</h3><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><span class="hljs-keyword">using</span> namespace std;<span class="hljs-type">void</span> swap(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b);<span class="hljs-type">void</span> swap(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b);<span class="hljs-type">void</span> swap_ref(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b);<span class="hljs-type">int</span> main() &#123;    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> y = <span class="hljs-number">50</span>;    <span class="hljs-type">int</span>&amp; z1 = x;    <span class="hljs-type">int</span> &amp;z2 = y;    cout &lt;&lt; &quot;Before: x = &quot; &lt;&lt; x &lt;&lt; &quot;  y = &quot; &lt;&lt; y &lt;&lt; endl;    swap(x, y);  // 交换失败    swap(&amp;x, &amp;y);  // 交换成功    swap_ref(z1, z2);  // 交换成功    cout &lt;&lt; &quot;After: x = &quot; &lt;&lt; x &lt;&lt; &quot;  y = &quot; &lt;&lt; y &lt;&lt; endl;&#125;<span class="hljs-type">void</span> swap(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;    <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span>;    <span class="hljs-keyword">temp</span> = a;    a = b;    b = <span class="hljs-keyword">temp</span>;&#125;<span class="hljs-type">void</span> swap(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b) &#123;    <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span>;    <span class="hljs-keyword">temp</span> = *a;    *a = *b;    *b = <span class="hljs-keyword">temp</span>;&#125;<span class="hljs-type">void</span> swap_ref(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b) &#123;    <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span>;    <span class="hljs-keyword">temp</span> = a;    a = b;    b = <span class="hljs-keyword">temp</span>;&#125;</code></pre></div><h3 id="悬挂指针和野指针">悬挂指针和野指针</h3><p>悬挂指针（DanglingPointer），是指向已经释放或者已经超出作用域的内存的指针。</p><div class="code-wrapper"><pre><code class="hljs d"><span class="hljs-keyword">int</span> *pt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>);<span class="hljs-keyword">delete</span> pt;  <span class="hljs-comment">// 此时这块内存已被操作系统回收，可能重新分配给其他程序了</span>*pt = <span class="hljs-number">10</span>;  <span class="hljs-comment">// Undefined behavior</span></code></pre></div><p>野指针（WildPointer），是未初始化的指针，如：<code>int *pt;</code></p><h4 id="如何避免悬挂指针和野指针">如何避免悬挂指针和野指针</h4><p>悬挂指针的避免很容易理解：指针变量经过 delete (或free)操作以后，其指向的内存会被释放，继而被系统回收。只需要对该指针赋个空值，让它别再继续指向这块已经被释放掉的内存空间即可。如：<code>pt = NULL;</code></p><p>避免野指针的常见建议如下：</p><p>（1）初始化空指针 nullptr</p><p>在 C++中，未初始化的指针变量会被默认初始化为一个未定义的值，即它们可能指向任意位置。因此，在使用指针变量之前，应该始终确保对其进行初始化，以避免未定义的行为。</p><p><code>int *p = nullptr;</code> 这是 C++11中引入的新方式，声明指向整数的指针 p2，并使用 nullptr 初始化。nullptr 是C++11 标准中的一个关键字，专门用于表示空指针。它的类型是std::nullptr_t，可以转换为任何其他指针类型，并且优于NULL，因为它消除了整数和空指针之间的歧义。</p><p><code>int *p = NULL;</code> 这条语句声明了指向整数的指针p1，并将其初始化为 NULL。NULL 是 C++ 中的一个宏，代表空指针，在 C++中它通常被定义为 0。尽管使用 NULL 是合法的，但它是基于 C的遗留实践，C++11 后推荐使用 nullptr。</p><p><code>int *p;</code> 这条语句仅仅声明了指向整数的指针p3，没有初始化。在这种情况下，p3将包含一个垃圾值（未定义的内存地址）。如果你没有正确初始化而试图使用这个指针，会导致未定义的行为，可能会带来安全风险和难以调试的bug。</p><p>（2）使用智能指针</p><p>C++ 中引入了一些智能指针，如 unique_ptr、shared_ptr等，在它们的生命周期结束时会自动释放所管理的资源，可以减少野指针和悬挂指针的风险。</p><p>例如：<code>std::unique_ptr&lt;int&gt; ptr(new int(5));</code></p><p>（3）避免使用裸指针</p><p>在可能的情况下，尽量使用引用或智能指针。</p><h3 id="智能指针">智能指针</h3><p>C++提供了四种类型的智能指针：unique_ptr、shared_ptr、weak_ptr、auto_ptr。它们都位于&lt;memory&gt; 头文件中，并在 std 命名空间下。</p><h4 id="unique_ptr">unique_ptr</h4><p>这是C++11中引入的一个智能指针，unique_ptr对象拥有其所指向的对象（所有权语义），但所有权不能被复制，只能通过std::move 转移。这意味着在任何时刻，最多只有一个 unique_ptr指向某个给定的对象，unique_ptr 被销毁时对象将被删除。这使得 unique_ptr成为管理堆上创建的单一对象或者原始数组的理想选择。</p><h4 id="shared_ptr">shared_ptr</h4><p>这是C++11中引入的另一个智能指针，它实现了共享所有权语义，即多个shared_ptr 对象可以指向同一个对象，该对象在最后一个 shared_ptr被销毁时删除。shared_ptr 使用了引用计数来跟踪有多少 shared_ptr指向当前这个对象。</p><h4 id="weak_ptr">weak_ptr</h4><p>这是C++11中引入的第三种智能指针，它是为了配合 shared_ptr使用的，对一个对象产生弱引用。一个 weak_ptr 对象可以指向一个由shared_ptr对象指向（拥有）的对象，但它不参与所有权的管理。也就是说，weak_ptr对象的存在不会阻止其指向的对象被删除。weak_ptr 常被用来解决 shared_ptr中可能出现的循环引用问题。</p><h4 id="auto_ptr">auto_ptr</h4><p>这是C98标准库中的一个智能指针，在C++11中被弃用，已在C++17中被移除。auto_ptr对象也拥有其所指向的对象，但所有权可以被转移，会导致一些违反直觉的行为。不建议使用auto_ptr，它已经被 unique_ptr 所替代。用户应当优先使用 unique_ptr 和shared_ptr 进行强引用，或者 weak_ptr 进行弱引用。</p><h2 id="c中的类和对象">C++中的类和对象</h2><h3 id="类的定义-对象的创建">类的定义 &amp; 对象的创建</h3><p>定义一个类，本质上就是定义一个数据类型的蓝图。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Goods</span> &#123;    <span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 访问限定符</span>        <span class="hljs-type">char</span> name[<span class="hljs-number">30</span>];  <span class="hljs-comment">// 成员变量</span>        <span class="hljs-type">int</span> amount;        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">price</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 成员函数</span>&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Goods::price</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 类外定义</span>    <span class="hljs-keyword">return</span> amount*<span class="hljs-number">10</span>;&#125;</code></pre></div><p>声明对象有两种形式：普通对象和指针。</p><div class="code-wrapper"><pre><code class="hljs xl">Goods good;  <span class="hljs-comment">// 声明对象</span>Goods *pGood = &amp;good;  <span class="hljs-comment">// 指针</span>good.amount = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 访问</span><span class="hljs-function"><span class="hljs-title">pGood</span>-&gt;</span>amount = <span class="hljs-number">10</span>;</code></pre></div><p><code>public</code>表示公有成员，在程序中类外可以访问；<code>private</code>表示私有成员，在类外不能访问，只能在本类和友元中访问；<code>protected</code>表示保护成员，只能被本类或派生类的成员函数访问。默认：<code>private</code>。</p><p>友元函数是可以直接访问类的私有成员的非成员函数，有利于类间数据的共享，但是破坏了类的封装性。友元函数内部没有this 指针！友元不是类的成员，只有成员函数才有 this 指针。</p><h3 id="构造函数">构造函数</h3><p>构造函数（Constructor）是对数据成员进行初始化的特殊函数，在对象被创建时由系统自动调用。初始化就相当于（自动）调用构造函数。</p><p>构造函数有几个特点：</p><ul><li>函数名与类名一样</li><li>不需用户调用，也不能被用户调用</li><li>可以在类中定义，也可以在类外定义</li><li>无函数返回值类型说明，但有返回值，返回构造函数所对应的被创建的对象</li><li>若类说明中没有给出构造函数，则C++默认给出一个缺省构造函数，不过函数体为空</li></ul><p>构造函数可以带参数（实参在创建对象时给出），有重载机制，它的一项重要功能就是对成员变量进行初始化（第一次赋值）。为达此目的，可以在构造函数的函数体中对成员变量逐一赋值，也可以采用参数初始化表。注意：用参数初始化表进行参数初始化的顺序与表列出的顺序无关，只与成员变量在类中声明的顺序有关。</p><p>下面是构造函数的一个实例：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;    <span class="hljs-keyword">private</span>:        <span class="hljs-type">int</span> a;  <span class="hljs-comment">// 私有成员变量</span>        <span class="hljs-type">int</span> b;    <span class="hljs-keyword">public</span>:        <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 构造函数（必须是public型）</span>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 公有成员函数</span>&#125;;<span class="hljs-comment">// 通过参数初始化表，按成员变量在类中声明的顺序赋值</span><span class="hljs-comment">// 先把b赋给a，此时b中是垃圾数据(比如0)，然后把给的参数i赋给b</span>[<span class="hljs-number">1</span>] Date::<span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> i) :<span class="hljs-built_in">b</span>(i), <span class="hljs-built_in">a</span>(b) &#123; &#125;<span class="hljs-comment">// 先依次执行: a = b、b = i，再执行函数体中的语句: a = b</span>[<span class="hljs-number">2</span>] Date::<span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> i) :<span class="hljs-built_in">b</span>(i), <span class="hljs-built_in">a</span>(b) &#123;    a = b;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::show</span><span class="hljs-params">()</span> </span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">55</span>)</span></span>;  <span class="hljs-comment">// 实例化对象</span>    Date *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">336</span>);  <span class="hljs-comment">// 动态申请内存</span>    Date *p2 = &amp;d;    d.<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// [1] a = 0  b = 55  [2] a = 55  b = 55</span>    p-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// [1] a = 0  b = 336  [2] a = 336  b = 336</span>    p2-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 结果与d.show()一样</span>    <span class="hljs-keyword">delete</span> p;  <span class="hljs-comment">// new完一定记得delete!</span>&#125;</code></pre></div><h3id="函数重载复制构造函数与析构函数">函数重载、复制构造函数与析构函数</h3><p>构造函数可以重载，要求：参数个数或参数类型不相同。因此一个类中可以有多个构造函数，但对于每一个对象来说，建立对象时只会执行其中一个构造函数。一个类中只能有一个默认构造函数（即无参的构造函数）。</p><p>复制构造函数（CopyConstructor）是一个特殊的构造函数，就是用一个已有的对象，以复制的方式快速产生多个完全相同的对象。为了确保相同，在对象的引用形式上一般要加<code>const</code>声明，使参数值不能改变，以防止调用此函数时不慎将对象值修改了。</p><p>析构函数（Destructor）也是一种特殊的成员函数，没有返回值。当对象生命周期结束时，系统自动执行析构函数，其会进行清理工作，如销毁对象、释放分配的内存、关闭打开的文件等。在类名（构造函数名）前加上"~"就构成了析构函数名。</p><p>析构函数执行的顺序类似于栈，“先进后出”，最先被调用的构造函数，其对应的对象的析构函数最后被调用。当然，并不是任何情况下都按这一原则处理，这与作用域有关。比如静态局部对象，在函数执行完以后并不会释放，直到程序结束以后要释放它时，才会调用它的析构函数。</p><p>C++中，每一个成员函数中都包含一个特殊的指针，叫<strong>this指针</strong>。它是指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的起始地址。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;    <span class="hljs-keyword">private</span>:        <span class="hljs-type">int</span> length;        <span class="hljs-type">int</span> width;        <span class="hljs-type">int</span> height;    <span class="hljs-keyword">public</span>:        <span class="hljs-comment">// 默认参数的构造函数。也可以在定义的时候填写默认参数，在这里只需要声明类型即可</span>        <span class="hljs-built_in">Box</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">10</span>, <span class="hljs-type">int</span> w=<span class="hljs-number">10</span>, <span class="hljs-type">int</span> h=<span class="hljs-number">10</span>);        <span class="hljs-built_in">Box</span>(<span class="hljs-type">const</span> Box&amp; box);  <span class="hljs-comment">// 复制构造函数 + 重载</span>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">volume</span><span class="hljs-params">()</span></span>;        ~<span class="hljs-built_in">Box</span>();  <span class="hljs-comment">// 析构函数</span>&#125;;Box::<span class="hljs-built_in">Box</span>(<span class="hljs-type">int</span> len, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h) &#123;    <span class="hljs-comment">// 下面三条语句等价。C++中，this是个指针，指向调用该成员函数的对象</span>    length = len;    <span class="hljs-keyword">this</span>-&gt;width = w;    (*<span class="hljs-keyword">this</span>).height = h;    cout &lt;&lt; <span class="hljs-string">&quot;调用了构造函数&quot;</span> &lt;&lt; endl;&#125;Box::<span class="hljs-built_in">Box</span>(<span class="hljs-type">const</span> Box&amp; box) &#123;    length = box.length;    width = box.width;    height = box.height;    cout &lt;&lt; <span class="hljs-string">&quot;调用了复制构造函数&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Box::volume</span><span class="hljs-params">()</span> </span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;length = &quot;</span> &lt;&lt; length &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;width = &quot;</span> &lt;&lt; width &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;height = &quot;</span> &lt;&lt; height &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;volume: &quot;</span>;        <span class="hljs-keyword">return</span>(length*width*height);&#125;Box::~<span class="hljs-built_in">Box</span>() &#123;    <span class="hljs-comment">// 输出一下相关信息</span>    cout &lt;&lt; <span class="hljs-string">&quot;调用了析构函数，清理工作已完成！&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">volume</span>() &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Box <span class="hljs-title">box1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// 自动局部对象box1，调用构造函数，第三个析构</span>    cout &lt;&lt; box1.<span class="hljs-built_in">volume</span>() &lt;&lt; endl;    <span class="hljs-function">Box <span class="hljs-title">box2</span><span class="hljs-params">(<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>)</span></span>;  <span class="hljs-comment">// 自动局部对象box2，调用构造函数，第二个析构</span>    cout &lt;&lt; box2.<span class="hljs-built_in">volume</span>() &lt;&lt; endl;    Box box3 = box1;  <span class="hljs-comment">// 自动局部对象box3，调用复制构造函数，最先被析构</span>    cout &lt;&lt; box3.<span class="hljs-built_in">volume</span>() &lt;&lt; endl;    <span class="hljs-type">static</span> Box box4;  <span class="hljs-comment">// 静态局部对象box4，调用构造函数，最后被析构</span>    cout &lt;&lt; box4.<span class="hljs-built_in">volume</span>() &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="静态数据成员">静态数据成员</h3><p>静态数据成员，为类的所有对象共享，内存中只占用一份空间。在创建第一个对象时，所有的静态数据都会被初始化为0，因此不能将静态成员的初始化放在类中定义，否则会冲突。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">volume</span><span class="hljs-params">()</span></span>;    <span class="hljs-keyword">private</span>:        <span class="hljs-type">static</span> <span class="hljs-type">int</span> length;        <span class="hljs-type">int</span> width;        <span class="hljs-type">int</span> height;&#125;;</code></pre></div><p>如果希望用Box类实例化的每个对象的length属性值都一样，那么就可以用<code>static</code>把它定义为静态数据成员。如果只声明了类而未定义对象，则类的一般数据成员是不占内存空间的，只有在定义对象时，才为对象的数据成员分配空间。但是静态数据成员不属于某一个对象，在为对象所分配的空间中不包括静态数据成员所占的空间。静态数据成员在所有对象之外单独开辟空间。只要在类中定义了静态数据成员，即使不定义对象，也为静态数据成员分配空间，它可以被引用。在一个类中可以有一个或多个静态数据成员，所有的对象共享这些静态数据成员，都可以引用它。</p><p>静态数据成员既可以通过对象名引用，也可以通过类名引用。</p><p>对于<strong>静态变量</strong>，如果在一个函数中定义了静态变量，在函数结束时该静态变量并不释放，仍然存在并保留其值。静态数据成员也类似，它不随对象的建立而分配空间，也不随对象的撒销而释放（一般数据成员是在对象建立时分配空间，在对象撒销时释放）。静态数据成员是在程序编译时被分配空间的，到程序结束时才释放空间。</p><p>静态数据成员可以初始化，但只能在类体外进行初始化。注意：不能用参数初始化静态数据成员，如参数初始化表就不行。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">product</span><span class="hljs-params">()</span></span>;    <span class="hljs-keyword">private</span>:        <span class="hljs-type">static</span> <span class="hljs-type">int</span> len;        <span class="hljs-type">int</span> width;&#125;;<span class="hljs-type">int</span> Box::len = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 初始化静态成员变量</span></code></pre></div><p>有了静态变量，各对象之间的数据有了沟通的渠道，实现了数据共享。</p><p>静态成员函数，可以用类名加 "::"进行访问，即便在类对象不存在的情况下也能被调用。静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。静态成员函数没有this 指针，只能访问静态成员，不能访问实例成员（普通成员）。</p><p>作用域限定符（Scope Resolution Operator）"::"还可以用来访问<strong>全局变量</strong>，但是不能在某个语句块内部访问在语句块外声明的局部变量。关于静态变量和全局变量、普通变量的区别，可以查看后文《C/C++中的static关键字》，也可以点击这个链接跳转访问：<ahref="https://www.runoob.com/w3cnote/cpp-static-usage.html">菜鸟教程:C/C++中的static</a>。看下面这个例子：</p><div class="code-wrapper"><pre><code class="hljs llvm">int <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span><span class="hljs-comment">;  // 全局变量</span>int main() &#123;    int <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span><span class="hljs-comment">;  // 局部变量</span>    cout &lt;&lt; ::<span class="hljs-keyword">x</span> &lt;&lt; endl<span class="hljs-comment">;  // 访问的是全局变量：x == 11</span>    cout &lt;&lt; <span class="hljs-keyword">x</span> &lt;&lt; endl<span class="hljs-comment">;  // 访问的是局部变量：x == 22</span>    ::<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span><span class="hljs-comment">;  // 修改全局变量的值</span>&#125;</code></pre></div><h3 id="常量成员">常量成员</h3><p>用const修饰的成员变量、成员函数、对象叫常量数据成员。由于const成员变量无法被修改，初始化常量数据成员的唯一方法就是用参数初始化表。</p><p>const成员函数可以使用类中所有成员变量，但是不能修改它们的值。const成员函数也叫常量成员函数。</p><p>相应地，创建对象时，也要用const进行修饰，常量对象可以且只能调用类的const成员函数（const类型相互匹配）（除了系统自动调用的隐式的构造函数和析构函数）。</p><div class="code-wrapper"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span> &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> s);        <span class="hljs-type">int</span> <span class="hljs-title function_">getHour</span>() <span class="hljs-keyword">const</span>;  <span class="hljs-comment">// 声明常量成员函数</span>    <span class="hljs-keyword">private</span>:        <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> <span class="hljs-built_in">hour</span>;        <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> <span class="hljs-built_in">minute</span>;        <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> <span class="hljs-built_in">second</span>;&#125;;<span class="hljs-comment">// 必须使用参数初始化表</span>Time::<span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> s) :<span class="hljs-built_in">hour</span>(h), <span class="hljs-built_in">minute</span>(m), <span class="hljs-built_in">second</span>(s) &#123; &#125;<span class="hljs-type">int</span> Time::<span class="hljs-title function_">getHour</span>() <span class="hljs-keyword">const</span>  <span class="hljs-comment">// 定义函数时也要加上const</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hour</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span>() &#123;    Time <span class="hljs-keyword">const</span> <span class="hljs-title function_">time</span>(<span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">56</span>);&#125;</code></pre></div><h3 id="静态与动态内存">静态与动态内存</h3><p>通常定义变量（或对象）后，编译器在编译时都可以根据该变量（或对象）的类型知道所需内存空间的大小，然后系统可以在适当的时候为它们分配确定的存储空间。这种内存分配称为静态存储分配。</p><p>有些操作对象只在程序运行时才能确定，这样编译时就无法为它们预定存储空间，只能在程序运行时，系统根据运行时的要求进行内存分配，这种方法称为动态存储分配。所有动态存储分配都在堆区中进行。C++程序中的内存分为两个部分：</p><p>(1)栈：在函数内部声明的所有变量都将占用栈内存。</p><p>(2)堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。</p><p>很多时候，用户无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。因此在C++中，可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符是new运算符。如果不再需要动态分配的内存空间，可以使用delete运算符，删除之前由new运算符分配的内存。</p><div class="code-wrapper"><pre><code class="hljs awk">double *p = nullptr;  <span class="hljs-regexp">//</span> 初始化 null 指针p = new double;  <span class="hljs-regexp">//</span> 为变量请求内存<span class="hljs-regexp">/* 改进如下 */</span><span class="hljs-keyword">if</span>(!(p = new double))&#123;    cout &lt;&lt; <span class="hljs-string">&quot;动态内存分配失败!&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);&#125;</code></pre></div><p>malloc函数在C语言中较常使用，建议C++中使用new运算。因为new不只分配了内存，还创建了对象。在任何时候，当用户觉得已经动态分配的变量不再需要使用时，可以使用delete操作符将其释放。</p><p>对象的动态内存分配：</p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;    int x;<span class="hljs-keyword">public</span>:    Base(int x) &#123;        <span class="hljs-keyword">this</span>-&gt;x = x;    &#125;    int <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">return</span> x;    &#125;&#125;;int main() &#123;    Base *p = new Base(<span class="hljs-number">100</span>);    <span class="hljs-keyword">if</span>(!p) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;动态内存分配失败!&quot;</span> &lt;&lt; endl;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; p-&gt;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> &lt;&lt; endl;    delete p;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="cc中的static关键字">C/C++中的static关键字</h3><h4 id="区别">区别</h4><p>在C和C++中，static关键字有三个主要的用途，但其在C++中的用法更加丰富：</p><p>在函数内部：在C和C++中，static关键字可用于函数内部变量。此时，此变量的生命周期将贯穿整个程序，即使函数执行结束，这个变量也不会被销毁。每次调用这个函数时，它都不会重新初始化。这可以用于实现一些需要保持状态的函数。</p><p>在函数外部或类外部：在C和C++中，static关键字可以用于全局变量或函数。此时，此变量或函数的作用域被限制在定义它的文件内，无法在其他文件中访问。这可以防止命名冲突或不必要的访问。</p><p>在类内部：只有C++支持此用法。在C++中，static关键字可以用于类的成员变量或成员函数。对于静态成员变量，无论创建多少个类的实例，都只有一份静态成员变量的副本。静态成员函数则可以直接通过类名调用，而无需创建类的实例。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;  <span class="hljs-comment">// 静态成员变量，所有实例共享一份</span>    <span class="hljs-built_in">MyClass</span>() &#123;        count++;  <span class="hljs-comment">// 每次创建实例，计数加1</span>    &#125;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 静态成员函数，可通过类名直接调用</span>        <span class="hljs-keyword">return</span> count;    &#125;&#125;;<span class="hljs-type">int</span> MyClass::count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 静态成员变量的初始化</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    MyClass a;    MyClass b;    MyClass c;    std::cout &lt;&lt; MyClass::<span class="hljs-built_in">getCount</span>();  <span class="hljs-comment">// 输出3，因为创建了3个实例</span>&#125;</code></pre></div><h4 id="作用">作用</h4><p>在C++中，static关键字有多个用途，它的作用主要取决于它在哪里被使用：</p><p>在函数内部：如果static被用于函数内部的变量，那么它会改变该变量的生命周期，使其在程序的整个运行期间都存在，而不是在每次函数调用结束时被销毁。这意味着，这个变量的值在函数调用之间是保持的。</p><p>在函数外部：如果static被用于函数外部的全局变量或函数，那么它会将这个变量或函数的链接范围限制在它被定义的文件内。换句话说，这个变量或函数不能在其他文件中被直接访问。这可以帮助减少命名冲突，而且能提供一种控制变量和函数可见性的方式。</p><p>在类中：如果static被用于类的成员变量，那么该变量将会成为这个类的所有实例共享的变量，也就是说，类的每个实例都能访问到这个同样的变量。如果static被用于类的成员函数，那么这个函数可以直接通过类来调用，而不需要创建类的实例。</p><h2 id="c核心之继承与多态">C++核心之继承与多态</h2><p>封装：encapsulation(package)<br/> 继承：inheritance<br/>多态：polymorphism</p><h3 id="继承用法子类初始化">继承用法：子类初始化</h3><p>子类/派生类/扩展类（Sub-class/derivedclass）可以继承父类/基类/超类（Super-class/base class）。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><span class="hljs-meta">#include &lt;string&gt;</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<span class="hljs-keyword">class</span> <span class="hljs-title">People</span> &#123;<span class="hljs-keyword">public</span>:    People(<span class="hljs-built_in">string</span> n, <span class="hljs-built_in">int</span> a, <span class="hljs-built_in">float</span> h) &#123;  <span class="hljs-comment">// 基类构造函数</span>        name = n;        age = a;        height = h;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-built_in">string</span> name;    <span class="hljs-built_in">int</span> age;    <span class="hljs-built_in">float</span> height;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> :<span class="hljs-title">public</span> <span class="hljs-title">People</span> &#123;  <span class="hljs-comment">// 公有继承</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">// 派生类的构造函数写法（初始化方法）</span>    Student(<span class="hljs-built_in">string</span> n, <span class="hljs-built_in">int</span> a, <span class="hljs-built_in">float</span> h, <span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> id) :People(n, a, h) &#123;        sex = s;        identity = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Show student&quot;</span> &lt;&lt; endl;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> sex;    <span class="hljs-built_in">string</span> identity;&#125;;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;    <span class="hljs-function">Student <span class="hljs-title">stu</span>(<span class="hljs-params"><span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">26</span>, <span class="hljs-number">188</span>, <span class="hljs-string">&quot;Gentleman&quot;</span>, <span class="hljs-string">&quot;XDer&quot;</span></span>)</span>;    stu.show();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>派生类的构造方法，仍然按照类的构造方法的语法写，但是形参列表需要将涉及到的所有参数都列出来，即总参数列表，按照先基类后派生类的次序，根据声明顺序依次列出。后面需要用参数初始化表的语法格式，<code>:People(n,a,h)</code>表示父类构造函数的信息，即<strong>派生类会调用父类构造函数及其参数</strong>，将相应的实参传递过去。然后再执行派生类函数体中的语句，为自己的成员变量初始化。也可以全部采用参数初始化表进行简化：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Student</span><span class="hljs-params">(string n, int a, float h, string s, string id)</span></span> :<span class="hljs-built_in">People</span>(n,<span class="hljs-selector-tag">a</span>,h), <span class="hljs-built_in">sex</span>(s), <span class="hljs-built_in">identity</span>(id) &#123; &#125;</code></pre></div><h3 id="继承的三种方式">继承的三种方式</h3><p>派生类继承有三种方式：公有继承 public、保护继承 protected、私有继承private。</p><p>三种继承的特点见下表：</p><table><thead><tr class="header"><th style="text-align: center;">基类中的成员</th><th style="text-align: center;">在公有派生类中的访问属性</th><th style="text-align: center;">在保护派生类中的访问属性</th><th style="text-align: center;">在私有派生类中的访问属性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">公有成员</td><td style="text-align: center;">公有</td><td style="text-align: center;">保护</td><td style="text-align: center;">私有</td></tr><tr class="even"><td style="text-align: center;">保护成员</td><td style="text-align: center;">保护</td><td style="text-align: center;">保护</td><td style="text-align: center;">私有</td></tr><tr class="odd"><td style="text-align: center;">私有成员</td><td style="text-align: center;">不可访问</td><td style="text-align: center;">不可访问</td><td style="text-align: center;">不可访问</td></tr></tbody></table><p>如果基类中需要定义私有的数据成员，要将其定义为 peotected类型，这样派生类就可以继承并使用了。</p><p>使用继承时需要注意以下内容：</p><p>（1）父类的构造函数和析构函数不会被继承，派生类需要重写。</p><p>（2）派生类的构造函数调用顺序：先调用各个直接基类的构造函数，之后再调用成员对象的构造函数，最后进行新增成员的初始化。</p><p>（3）对于多继承有多个基类，按照被继承时的声明顺序从左到右依次调用，与初始化表的顺序无关。对成员对象的初始化也一样，按照声明顺序而非初始化表的顺序。</p><h3 id="final-and-override">final and override</h3><p>final 和 override 是 C++11引入的两个关键字，主要用于类的继承和虚函数的覆盖（即重写）。</p><p>final：如果一个类被声明为final，那么它不能被继承。例如，<code>class Base final &#123; ... &#125;;</code>，此时任何试图继承Base 的类都会导致编译错误。此外，如果一个虚函数被声明为final，那么它不能在派生类中被覆盖。例如，<code>virtual void fun() final;</code>，此时任何派生类试图覆盖fun() 函数都会导致编译错误。</p><p>override：如果一个虚函数被声明为override，那么编译器会检查这个函数是否真的覆盖了基类中的一个虚函数。如果没有，编译器会报错。这个关键字可以帮助我们避免因为拼写错误或者函数签名错误而导致的编译报错。例如，<code>void fun() override;</code>，如果基类中没有一个函数的签名和fun() 完全匹配，那么编译器就会报错。</p><p>举个例子：假设我们有一个基类 Animal 和一个派生类 Dog，Animal有一个虚函数 make_sound()，Dog 需要覆盖这个函数。如果我们在 Dog 的make_sound() 函数声明中加上了 override关键字，那么如果我们不小心将函数名拼写成了maek_sound()，编译器就会因为找不到对应的基类函数而报错，帮助我们及时发现错误。</p><h3 id="多重继承">多重继承</h3><p>下例给出了类 D 分别以公有方式继承了基类 A 和 B 的一种实现。</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span> &#123;  <span class="hljs-comment">// 基类 A</span><span class="hljs-keyword">public</span>:    A(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;        A_a = a;        A_b = b;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-built_in">int</span> A_a;    <span class="hljs-built_in">int</span> A_b;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-symbol">B</span> &#123;  <span class="hljs-comment">// 基类 B</span><span class="hljs-keyword">public</span>:    B(<span class="hljs-built_in">int</span> c, <span class="hljs-built_in">int</span> d) :B_c(c), B_d(d) &#123; &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-built_in">int</span> B_c, B_d;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-symbol">D</span> :<span class="hljs-symbol">public</span> <span class="hljs-symbol">A, <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">B</span> &#123;  <span class="hljs-comment">// 派生类 D</span><span class="hljs-keyword">public</span>:    D(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b, <span class="hljs-built_in">int</span> c, <span class="hljs-built_in">int</span> d, <span class="hljs-built_in">int</span> e);<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">int</span> D_e;&#125;;<span class="hljs-comment">// 子类构造函数</span>D::D(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b, <span class="hljs-built_in">int</span> c, <span class="hljs-built_in">int</span> d, <span class="hljs-built_in">int</span> e) : A(a,b), B(c,d), D_e(e) &#123; &#125;</code></pre></div><p>注意：在派生类构造函数中，基类构造函数的调用顺序与声明/定义基类的顺序相同，与派生类构造函数初始化表中基类构造函数出现的顺序无关。</p><p>容易想到，若继承的多个基类有同名的数据成员，则访问的时候会出现“二义性”（ambiguous）的问题，也就是不知道访问的是哪一个父类中的数据成员。可以用作用域限定符/域解析运算符:: 进行说明。如：<code>d.A::x = 3;</code> 表示派生类 D 的对象 d访问的是其所继承的基类 A 中的那个成员变量x，为它重新赋值为3。又如：<code>d.B::show();</code> 表示 d 访问的是基类B 中的成员函数 show()。</p><h3 id="类的引用">类的引用</h3><p>引用相当于别名，在内存中共享同一段空间。</p><p>若一个指针先被定义为指向基类对象，那么后续再对其重新赋值，让其指向派生类对象，也只能访问派生类中的基类成员。关于这一点，可以查阅后文：《多态的动态实现：虚函数》。</p><p>基类和派生类可以相互转换，但是会存在“切片”问题，即把派生类类型的变量赋值给基类类型时，系统自动进行隐式转换，但是只会将派生类中基类的部分赋过去，派生类自己新增的信息将丢失。这个解决办法就是后文中的多态机制。</p><p>看下面这个代码片段：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>  &#123; &#125;;<span class="hljs-keyword">class</span> <span class="hljs-symbol">B</span> :<span class="hljs-symbol">public</span> <span class="hljs-symbol">A</span> &#123; &#125;;<span class="hljs-built_in">int</span> main() &#123;    A a;  <span class="hljs-comment">// 创建基类的对象</span>    B b;  <span class="hljs-comment">// 创建派生类的对象</span>    A &amp;r = a;  <span class="hljs-comment">// 创建一个引用: r</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>引用 r 是 a 的别名，两者共享同一段内存单元。若对 r重新赋值：<code>r = b;</code>，此时 r 并非 b 的别名！所以 r 不与 b共享同一段存储单元。r 只是 b 中基类部分的别名，r 与 b中基类部分共享同一段存储单元，r 与 b 具有相同的起始地址。</p><h3 id="认识多态性">认识多态性</h3><p>顾名思义，一个事物的多种形态称之为多态。在C++程序设计中，多态性就相当于具有不同功能的成员函数可以共用同一个函数名，这样就可以用一个函数名调用具有不同功能的成员函数，用于类的继承中。</p><p>在面向对象方法中一般是这样表述多态性的：向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为（即各自的方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用（基类）函数，不同的行为就是指不同的实现，即执行不同的函数。函数重载就是一种多态性。</p><p>从系统实现的角度看，多态性分为两类：静态多态性和动态多态性。</p><p>函数重载、运算符重载就属于静态多态性，在程序编译时系统就能决定调用的是哪个函数，因此静态多态性又称编译时的多态性。静态多态性是通过函数的重载实现的。</p><p>动态多态性是在程序运行过程中才动态地确定操作所针对的对象，它又称运行时的多态性。动态多态性是通过虚函数实现的。</p><h3 id="多态的动态实现虚函数">多态的动态实现：虚函数</h3><p>C++的多态性用一句话概括就是：在基类的函数前加上 virual关键字，在派生类中重写该函数，在主函数中用指针进行动态绑定实现多态（疑问：为什么一定要使用指针？）。运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p><p>看一个例子：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123;        cout &lt;&lt; <span class="hljs-string">&quot;This is a Father!&quot;</span> &lt;&lt; endl;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Polymorphism: Father!&quot;</span> &lt;&lt; endl;    &#125;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> :<span class="hljs-title">public</span> <span class="hljs-title">Father</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123;        cout &lt;&lt; <span class="hljs-string">&quot;This is a son!&quot;</span> &lt;&lt; endl;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;  <span class="hljs-comment">// 这里的 virtual 可以省略</span>        cout &lt;&lt; <span class="hljs-string">&quot;Polymorphism: son!&quot;</span> &lt;&lt; endl;    &#125;&#125;;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;    Father f;    Son son;    f.show();  <span class="hljs-comment">// 输出: This is a Father!</span>    f.display();  <span class="hljs-comment">// 输出: Polymorphism: Father!</span>    Father *p = &amp;son;    p-&gt;show();  <span class="hljs-comment">// 输出: This is a Father!</span>    p-&gt;display();  <span class="hljs-comment">// 输出: Polymorphism: son!</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>C++编译器在编译的时候，要确定每个对象调用的函数（非虚函数）的地址，这称为<strong>早期绑定</strong>。将派生类对象的地址赋给父类型的指针变量时：<code>Father *p = &amp;son;</code>，C++编译器进行了类型转换，此时编译器认为变量p 保存的就是基类 Father 的对象的地址，若用 p 指针调用子类型对象 son中重写的父类的函数，会失败，其实调用的仍然是父类自己的函数。</p><p>从内存角度来解释：用户在构造子类对象 son 的时候，首先要调用 Father类的构造函数去构造基类的对象，然后才调用子类的构造函数完成对象 son自身（增加）的部分。这时在内存中，son所占的空间就是两部分拼接的结果。当用户将 son 对象转换为 Father类型时（上述赋值语句），该对象就被认为是原对象整个内存的上半部分，即Father 对象所占的内存，因此用 p 调用 son中继承而来并重写的父类函数时，实际上调用的仍是父类本身的函数。</p><p>归根结底，是因为编译器在编译的时候，就已经确定了对象调用的函数的地址，要解决这个问题就要使用晚期绑定。当编译器使用晚期绑定时，就会在运行时再去确定对象的类型以及正确的调用函数，而要让编译器采用晚期绑定，就要在基类中声明函数时使用virtual关键字，这样的函数称之为<strong>虚函数</strong>。注意：一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是 virtual类型，而不需要再显式地声明为 virtual。虚函数肯定是类的成员函数。</p><p>在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。用户想要的是在程序中任意点都可以根据所调用的对象类型来选择调用的函数是哪一个（对象相应的派生类中的还是基类中的），这种操作被称为：<strong>动态联编</strong>，或<strong>动态绑定</strong>，或<strong>晚期绑定</strong>。因此，基类必须将它的两种成员函数区分开：希望被派生类覆盖的函数，或是只继承不改动的函数。对于前者，就可以利用多态机制了。</p><h3 id="虚函数表">虚函数表</h3><p>当用户在派生类中覆盖某个函数时，可以在函数前加 virtual关键字。然而这不是必须的，因为一旦某个函数被声明成虚函数，则所有派生类中它都是虚函数。任何构造函数之外的非静态函数都可以是虚函数。派生类经常覆盖它继承的虚函数，如果派生类没有覆盖其基类中某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。编译器在编译的时候，一旦发现某个类中有虚函数，就会为所有包含虚函数的类创建一个<strong>虚表</strong>，即vtable，该表是一个一维数组，其中存放每个虚函数的地址。编译器还为虚表提供了一个虚表指针（vptr），这个指针指向了对象所属类的虚表。在程序初始化的时候，编译器会根据对象的类型初始化vptr，让该指针正确指向所属类的虚表，从而在调用虚函数的时候，能够找到正确的那个函数。</p><p>在构造函数中进行虚表的创建和虚表指针的初始化。在构造子类对象时，要先调用父类的构造函数，此时编译器只“看到了”父类，并不知道后面是否还有继承者，它初始化父类对象的虚表指针，该虚表指针指向父类的虚表。当执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。虚函数表有以下特点：</p><ul><li>每一个类都有虚表。</li><li>虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现，如果基类有3个虚函数，那么基类的虚表中就有三项（虚函数地址）。派生类也会创建虚表，且至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现。如果派生类有自己的虚函数，那么虚表中就会添加该地址。</li><li>派生类的虚表中虚地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。</li></ul><p>存在虚函数的类都有一个一维的虚函数表（虚表），类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。</p><h3 id="虚函数的使用方式">虚函数的使用方式</h3><p>直接看这个示例：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;  <span class="hljs-comment">/* 声明基类People */</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">People</span>(<span class="hljs-type">int</span>, string, <span class="hljs-type">int</span>);  <span class="hljs-comment">/* 声明构造函数 */</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">/* 声明虚成员函数 */</span><span class="hljs-keyword">protected</span>:  <span class="hljs-comment">/* 受保护成员，派生类可以访问 */</span>    <span class="hljs-type">int</span> id;    string name;    <span class="hljs-type">int</span> age;&#125;;People::<span class="hljs-built_in">People</span>(<span class="hljs-type">int</span> id, string name, <span class="hljs-type">int</span> age) &#123;    <span class="hljs-keyword">this</span>-&gt;id = id;    <span class="hljs-keyword">this</span>-&gt;name = name;    <span class="hljs-keyword">this</span>-&gt;age = age;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">People::show</span><span class="hljs-params">()</span> </span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;id: &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot;\tname: &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\tage: &quot;</span> &lt;&lt; age &lt;&lt; endl;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> :<span class="hljs-keyword">public</span> People &#123;  <span class="hljs-comment">/* 声明公有派生类Student */</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span>, string, <span class="hljs-type">int</span>, <span class="hljs-type">float</span>);  <span class="hljs-comment">/* 声明构造函数 */</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">/* 声明成员函数，virtual 可以省略 */</span><span class="hljs-keyword">private</span>:    <span class="hljs-type">float</span> score;&#125;;Student::<span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> id, string name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score) :<span class="hljs-built_in">People</span>(id,name,age), <span class="hljs-built_in">score</span>(score) &#123; &#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::show</span><span class="hljs-params">()</span> </span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;id: &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot;\tname: &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\tage: &quot;</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">&quot;\tscore: &quot;</span> &lt;&lt; score &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">People <span class="hljs-title">peo</span><span class="hljs-params">(<span class="hljs-number">2001</span>, <span class="hljs-string">&quot;老鸨&quot;</span>, <span class="hljs-number">23</span>)</span></span>;  <span class="hljs-comment">/* 定义People类对象peo */</span>    <span class="hljs-function">Student <span class="hljs-title">stu</span><span class="hljs-params">(<span class="hljs-number">2006</span>, <span class="hljs-string">&quot;马猴&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">85</span>)</span></span>;  <span class="hljs-comment">/* 定义Student类对象stu */</span>    People *pt = &amp;peo;  <span class="hljs-comment">/* 定义指向基类对象的指针变量 */</span>    pt-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 输出: id: 2001  name: 老鸨  age: 23</span>    pt = &amp;stu;  <span class="hljs-comment">/* 父类型指针变量指向子类型对象 */</span>    pt-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 输出: id: 2006  name: 马猴  age: 18  score: 85</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>在过去，派生类的输出函数与基类的输出函数不同名（如show和show_1），但如果派生的层次多，就要起许多不同的函数名，很不方便。如果采用同名函数，又会发生同名覆盖问题。利用虚函数就很好地解决了这个问题。当把基类的某个成员函数声明为虚函数后，允许在其派生类中对该函数重新定义，赋予它新的功能，并且可以通过指向基类的指针指向同一类族中不同类的对象，从而调用其中的同名函数。由虚函数实现的动态多态性就是：同一类族中不同类的对象，对同一函数调用作出不同的响应。</p><p>虚函数是在基类中用 virtual声明定义，然后在子类中重写这个函数后，基类的指针指向子类对象，从而可以调用子类的这个函数。虚函数的使用方法是：</p><p>（1）在基类用 vitual声明成员函数为虚函数。这样就可以在派生类中重新定义此函数，为它赋予新的功能，并能方便地被调用。在类外定义虚函数时，不必再加virtual。</p><p>（2）在派生类中重新定义此函数，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同，并根据派生类的需要重新定义函数体。</p><p>（3）定义一个指向基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象。</p><p>（4）通过该指针变量调用此虚函数，此时调用的就是指针变量指向的对象的同名函数。</p><p>C++规定，当一个成员函数被声明虚函数后，其派生类中的同名函数都自动成为虚函数。因此在派生类重新声明该虚函数时，可以加virtual，也可以不加，但习惯上一般在每一层声明该函数时都加virtual，使程序更加清晰。如果在派生类中没有对基类的虚函数重新定义，则派生类简单地继承其直接基类的虚函数。</p><h3 id="动态关联与静态关联">动态关联与静态关联</h3><p>编译系统要根据已有的信息，对同名函数的调用做出判断。例如函数的重载，系统是根据参数的个数和类型的不同去找与之匹配的函数的。对于调用同一类族中的虚函数，应当在调用时用一定的方式告诉编译系统，你要调用的是哪个类对象中的函数。例如可以直接提供对象名，如student.display() 或teacher.display()，这样编译系统在对程序进行编译时，立即能确定调用的是哪个类对象中的函数。</p><p>确定调用的具体对象的过程称为关联（binding）。binding原意是捆绑或连接，即把两样东西连接在一起。在这里是指把一个函数名与一个类对象捆绑在一起，建立关联。一般地说，关联是指把一个标识符和一个存储地址联系起来。</p><p>多态性是指为一个函数名关联多种含义的能力，即同一种调用方式可以映像到不同的函数。这种把函数的调用与适当的函数体对应的活动又称为绑定。根据绑定所进行阶段的不同，可分为早期绑定（earlybinding）、晚期绑定（latebinding）。早期绑定发生在程序的编译阶段，称为静态关联（staticbinding），晚期绑定发生在程序的运行阶段，称为动态关联（dynamicbinding）。</p><p>早期绑定，也称为编译期多态，指绑定是发生在编译阶段，例如：函数的重载。晚期绑定，也称为动态联编、动态绑定，指在运行时实现多态。动态绑定时，编译器由于只做静态的语法检查，系统不能确定调用对象是谁，在运行阶段，指针变量调用了某个对象的函数，系统才知道是哪一个对象，才会触发多态机制。由于动态关联是在编译以后的运行阶段进行的，因此也成为滞后关联（latebinding）。</p><h3 id="纯虚函数">纯虚函数</h3><p>纯虚函数也是用 virtual进行修饰，但是可以不用定义，只需声明即可。纯虚函数是在声明虚函数时被“初始化”为0的函数，基类中并不使用这个函数，所以返回值没有意义。纯虚函数没有函数体，只需声明，所以语句后面有分号。</p><p>纯虚函数只有名字而不具备函数的功能，不能被调用。它只是通知编译系统：这里声明的是一个纯虚函数，留待派生类中再定义。在派生类中对此函数进行重写后，它才具有功能，方可被调用。</p><p>包含纯虚成员函数的类叫抽象基类，无法实例化，不能由该基类创建对象，所以很“抽象”。但是可以产生基类指针，可以被派生类继承。但需要注意的是，派生类继承了抽象基类后，纯虚函数也会被继承而来，若派生类不对继承来的所有纯虚成员函数进行重写，那么该派生类同样会变成一个抽象基类。</p><p>抽象基类可以用于实现公共接口，在抽象基类中声明的纯虚成员函数，派生类如果想要能创建对象，则必须全部重新定义这些纯虚函数。注意：虚函数所在的基类是可以创建对象的！纯虚函数（抽象基类）主要用在这种情形：基类中不需要这个函数（功能），且不需要产生对象，但是子类型需要，所以在基类中为子类“占个位”，子类继承基类后只需要重写该函数（纯虚函数）就可以使用了。</p><p>纯虚函数语法：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-comment">// 纯虚函数的声明，此时Base类是抽象基类</span>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> = <span class="hljs-number">0</span>;&#125;;</code></pre></div><p>后面的 =0并非表示函数返回值为0，也不表示赋值，它只起形式上的作用，即告诉编译系统：这是纯虚函数。</p><h2 id="c容器">C++容器</h2><p>容器，是一个特殊的对象，该对象保存其他对象，即持有其他对象或指向其他对象的指针，还包含了一些处理其他对象的方法。实质上，容器就是一组相同类型对象（数据）的集合，用于对数据的存储和处理，比数组更加强大。</p><p>容器类还是一种对特定代码重用问题的良好解决方案。此外，容器可以自行扩展，可以动态申请内存、释放内存，且使用最优算法执行命令。</p><h3 id="容器的分类">容器的分类</h3><p>容器有两大类别：顺序容器（Sequence container）、关联容器（Associativecontainer）。</p><h3 id="顺序容器">顺序容器</h3><p>各个元素之间有顺序关系的线性表，每个元素都有固定的位置，呈现某种逻辑顺序，通过在容器中的位置来保存和访问元素。更改位置只能通过插入、删除元素实现。</p><p>特点：插入和查询速度快、适合数据的修改操作频繁的场景。</p><p>常见的顺序容器有三种：vector、list、deque。</p><h4 id="vector">vector</h4><p>向量 vector，是一个动态的顺序容器，这是用的最广泛的容器。vector是具有连续内存地址的数据结构，类似数组，支持下标（索引）进行随机、快速地访问，但是存储空间是动态可扩展的。而且vector可以相对高效的在尾部插入、删除元素。只允许一端插入、删除元素，内部插入、删除效率很低。</p><p>vector 的查询性能最好，而且末端增加数据的性能也很好。</p><p>须包含头文件：<code>#include &lt;vector&gt;</code>，在命名空间 std中。</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">/* 初始化, 范围区间: 左闭右开 */</span><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">8</span>, <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// 8 个值全为 1 的 vector, a.size(): 8</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(a.begin(), a.end())</span></span>;  <span class="hljs-comment">// 把 a 从头到尾全赋给 b, b.size(): 8</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(a.begin(), a.begin()+<span class="hljs-number">3</span>)</span></span>;  <span class="hljs-comment">// 把 a 前 3 个元素赋给 c, c.size(): 3</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(arr, arr+<span class="hljs-number">3</span>)</span></span>;  <span class="hljs-comment">// 把 arr 前 3 个元素赋给 d, d.size(): 3</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">e</span><span class="hljs-params">(arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">3</span>])</span></span>;  <span class="hljs-comment">// 等价于: vector&lt;int&gt; e(1,1)  e.size(): 1</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[<span class="hljs-number">3</span>])</span></span>;  <span class="hljs-comment">// 把 arr 前 3 个元素赋给 f, f.size(): 3</span><span class="hljs-comment">/* 插入和删除元素 */</span><span class="hljs-comment">// f: 1 2 3</span>f.<span class="hljs-built_in">insert</span>(f.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 在 f.begin() 前插入元素: 0</span><span class="hljs-comment">// f: 0 1 2 3</span>f.<span class="hljs-built_in">insert</span>(f.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 在 f 末尾添加 3 个值为 1 的元素</span><span class="hljs-comment">// f: 0 1 2 3 1 1 1</span>f.<span class="hljs-built_in">insert</span>(f.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, &amp;arr[<span class="hljs-number">1</span>], &amp;arr[<span class="hljs-number">3</span>]);  <span class="hljs-comment">// 将 arr[1], arr[2] 插入 f 第二个位置处</span><span class="hljs-comment">// f: 0 2 3 1 2 3 1 1 1</span>f.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">9</span>);  <span class="hljs-comment">// 在 f 尾部插入元素: 9</span><span class="hljs-comment">// f: 0 2 3 1 2 3 1 1 1 9</span>f.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 删除 f 的末尾元素</span><span class="hljs-comment">// f: 0 2 3 1 2 3 1 1 1</span>f.<span class="hljs-built_in">erase</span>(f.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>);  <span class="hljs-comment">// 删除 f 的末尾元素</span><span class="hljs-comment">// f: 0 2 3 1 2 3 1 1</span>f.<span class="hljs-built_in">erase</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">3</span>);  <span class="hljs-comment">// 删除 f 前三个元素</span><span class="hljs-comment">// f: 1 2 3 1 1</span>f.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">// 清空 f (删除容器中所有元素)</span>f.<span class="hljs-built_in">assign</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 把 d 赋给 f, 会覆盖 f 原本的内容</span>f = d;  <span class="hljs-comment">// 同上</span><span class="hljs-comment">/* 其他常用的成员函数 */</span>f.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">// 作用于容器: 返回首元素的迭代器; 作用于数组: 返回首元素的指针</span>f.<span class="hljs-built_in">end</span>();  <span class="hljs-comment">// 作用于容器: 返回末尾元素向后延一个的迭代器; 作用于数组: 返回尾元素下一位的指针</span>f.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 返回容器 f 的大小</span>f.<span class="hljs-built_in">empty</span>();  <span class="hljs-comment">// 判空, 容器为空时返回: true, 否则返回: false</span>f.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 返回第一个元素</span>f.<span class="hljs-built_in">back</span>();  <span class="hljs-comment">// 返回最后的元素</span></code></pre></div><p>vector有两种遍历方式：像数组一样用下标访问元素、使用<font color="purple">迭代器</font>访问。迭代器是一种检查容器内元素并遍历元素的数据类型，通常用于对C++中各种容器内元素的访问，但不同的容器有不同的迭代器。迭代器在某种意义上可以理解为一种指针。</p><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-comment">/* 下标访问 */</span><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;f.size(); i++) &#123;    cout &lt;&lt; f[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;&#125;<span class="hljs-comment">/* 迭代器遍历 */</span><span class="hljs-keyword">for</span>(vector&lt;int&gt;::iterator <span class="hljs-literal">it</span>=f.begin(); <span class="hljs-literal">it</span>!=f.end(); <span class="hljs-literal">it</span>++) &#123;    cout &lt;&lt; *<span class="hljs-literal">it</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> ;&#125;</code></pre></div><p>扩展：二维向量，利用嵌套 vector 实现。</p><div class="code-wrapper"><pre><code class="hljs mel"><span class="hljs-comment">// 创建一个 3 行 4 列的 vector, 且值初始化为1</span><span class="hljs-keyword">vector</span>&lt; <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; g(<span class="hljs-number">3</span>, <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>));<span class="hljs-comment">// 输出这个 2D vector</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>; m&lt;g.<span class="hljs-keyword">size</span>(); m++) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>; n&lt;g[m].<span class="hljs-keyword">size</span>(); n++) &#123;        cout &lt;&lt; g[m][n] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;</code></pre></div><h4 id="list">list</h4><p>列表list，是一个双向（循环）链表，它保存了前、后指针，所以可以向前、向后双向访问，但是不能随机访问。存储空间不要求连续，可以在两头或中间的任意位置插入、删除元素，且相当高效。</p><p>list 适合大量的插入和删除操作，不过查询性能很差。</p><p>须包含头文件：<code>#include &lt;list&gt;</code>，大多数语法格式与vector 类似。</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">/* 初始化 */</span>list&lt;<span class="hljs-type">int</span>&gt; lst1;  <span class="hljs-comment">// 创建空容器</span><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lst2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 创建含有 5 个元素的 list</span><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lst3</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)</span></span>;  <span class="hljs-comment">// 创建含有 3 个元素的 list, 初始值为2</span><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lst4</span><span class="hljs-params">(lst3)</span></span>;  <span class="hljs-comment">// 用 lst3 初始化 lst4</span><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lst</span><span class="hljs-params">(lst3.begin(), lst3.end())</span></span>;  <span class="hljs-comment">// 同 lst4</span><span class="hljs-comment">/* 插入和删除 (区别于 vector 的新特性) */</span>lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 在头部插入元素: 0</span>lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 在尾部插入元素: 4</span>lst.<span class="hljs-built_in">pop_front</span>();  <span class="hljs-comment">// 删除首元素</span>lst.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 删除末尾元素</span><span class="hljs-comment">/* list 须用迭代器遍历 */</span><span class="hljs-keyword">for</span>(list&lt;<span class="hljs-type">int</span>&gt;::iterator it=lst.<span class="hljs-built_in">begin</span>(); it!=lst.<span class="hljs-built_in">end</span>(); it++) &#123;    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> ;&#125;<span class="hljs-comment">/* 迭代器还可以逆向遍历 */</span><span class="hljs-keyword">for</span>(list&lt;<span class="hljs-type">int</span>&gt;::reverse_iterator it=lst.<span class="hljs-built_in">rbegin</span>(); it!=lst.<span class="hljs-built_in">rend</span>(); it++) &#123;    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> ;&#125;</code></pre></div><h4 id="deque">deque</h4><p>是一个双端（向）队列，介于 vector 和 list之间，采用多个连续的内存块，是分块的链表和多个数组的联合。支持两端插入、删除元素，可以随机访问。deque的增删功能比 vector 多，但是随机访问的速度比 vector 慢。不过 deque的查询性能比 list 强。</p><p>deque 适用于既要随机存取、又关心两端数据的增删的情况。</p><p>须包含头文件：<code>#include &lt;deque&gt;</code>。</p><p>deque 的语法与 vector 类似，但是可以用 list中的一些成员函数（用于两端插入和删除）。</p><h3 id="关联容器">关联容器</h3><p>用非线性的二叉树结构实现，具体的说是：平衡二叉搜索（排序）树（AVL树，以两位发明此法的俄罗斯数学家的名字命名），更具体的说是：红黑树。</p><p>各元素间没有严格的物理顺序，元素通过关键字来保存和访问，即键（key），有的还包括对应的值（value）。支持通过键来高效地查找和读取元素。关键字是有序的，默认按照升序排列。</p><p>常见的关联容器有两种：map、set。</p><h4 id="map">map</h4><p>映射 map，元素是由 (key, value) 两个分量组成的对偶，其中 key是唯一的，只对应一个确定的value。关键字有序排列，且不允许重复。支持下标操作，下标是键（key）。</p><p>map 内部按链表的方式存储元素，插入比 vector快，但查找和在末尾添加元素比 vector 慢。</p><p>关键字（key）类型：<code>key_type</code> <br/>关键字关联的（value）类型：<code>mapped_type</code> <br/> map保存的元素类型（即：pair &lt;const key_type,mapped_type&gt;）：<code>value_type</code></p><p><font color="purple">pair</font> 对象，会将两个值视为一个单元，pair类型的对象存储的就是一个键值对。pair 是一个用来生成特定类型的模版，容器map 就是使用 pair 来管理键值对数据元素的。</p><p>须包含头文件：<code>#include &lt;map&gt;</code>。</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">// 下面三条语句等价</span><span class="hljs-function">pair&lt;string, string&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)</span></span>;pair&lt;string, string&gt; a = &#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>&#125;;pair&lt;string, string&gt; a &#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>&#125;;<span class="hljs-comment">// map 的使用</span><span class="hljs-comment">// map 初始化</span>map&lt;string, <span class="hljs-type">int</span>&gt; M &#123;    &#123;<span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-number">1</span>&#125;,    &#123;<span class="hljs-string">&quot;22&quot;</span>, <span class="hljs-number">2</span>&#125;&#125;;<span class="hljs-comment">// 用成员函数 insert 结合 pair 插入新元素对</span>M.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&quot;33&quot;</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">// 也可以用 map 中的元素类型 value_type 插入新元素对</span>M.<span class="hljs-built_in">insert</span>(map&lt;string, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-string">&quot;44&quot;</span>, <span class="hljs-number">4</span>));<span class="hljs-comment">// 可以用关键字下标访问元素 (输出: 3)</span>cout &lt;&lt; M[<span class="hljs-string">&quot;33&quot;</span>] &lt;&lt; endl;<span class="hljs-comment">// 还可以利用下标特性添加新元素对</span>M[<span class="hljs-string">&quot;55&quot;</span>] = <span class="hljs-number">5</span>;<span class="hljs-comment">// 用迭代器遍历, 输出键值对</span>map&lt;string, <span class="hljs-type">int</span>&gt;::iterator it;<span class="hljs-keyword">for</span>(it=M.<span class="hljs-built_in">begin</span>(); it!=M.<span class="hljs-built_in">end</span>(); it++) &#123;    <span class="hljs-comment">// it-&gt;first 返回关键字: key, it-&gt;second 返回 key 对应的 value</span>    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;&#125;<span class="hljs-comment">// 查找 key 是否存在 (存在, 返回: 1)</span>cout &lt;&lt; M.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;55&quot;</span>) &lt;&lt; endl;<span class="hljs-comment">// 下面这条指令返回指向改元素的迭代器, 若元素不存在, 则返回 end 迭代器</span>M.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;55&quot;</span>);<span class="hljs-comment">// 删除元素对, 下面两条语句等价</span>M.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;55&quot;</span>);M.<span class="hljs-built_in">erase</span>(M.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;55&quot;</span>));</code></pre></div><h4 id="set">set</h4><p>集合set，一组元素的集合，是单纯的键（关键字）的集合，只包含独立的元素。键唯一。没有下标操作。</p><p>set 包含的元素也叫 set 的实例。set内部也是通过链表的方式组织，插入元素快，但查找和末尾添元素较慢。</p><p>须包含头文件：<code>#include &lt;set&gt;</code>。</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">// 用 vector 初始化 set</span>vector&lt;<span class="hljs-type">int</span>&gt; v;<span class="hljs-comment">// size_type 是 vector&lt;int&gt; 里 size() 返回的类型</span><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::size_type i=<span class="hljs-number">0</span>; i!= <span class="hljs-number">5</span>; i++) &#123;    v.<span class="hljs-built_in">push_back</span>(i);    v.<span class="hljs-built_in">push_back</span>(i);&#125;<span class="hljs-comment">// v.size(): 10, s.size(): 5</span><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(v.begin(), v.end())</span></span>;<span class="hljs-comment">// 插入新元素</span>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);s.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;三国&quot;</span>);</code></pre></div><h3 id="容器适配器">容器适配器</h3><p>这是一个特殊的容器，是用基本容器实现的新容器，可以描述更高级的数据结构。C++中，适配器就是使一类事物的行为类似另一类事物的行为的一种机制。容器适配器让一种已存在的容器类型采用另一种不同的抽象类型的工作方式进行实现。</p><p>可以将容器适配器理解为：容器的容器，或者容器的接口。容器适配器本身不能直接保存元素，它只是调用另一种顺序容器去实现数据的保存，因此可以这样认为：它先保存一个容器，这个容器再保存元素。</p><p>常见的容器适配器有三种：stack、queue、priority_queue。</p><h4 id="stack">stack</h4><p>对应数据结构中的栈，先进后出、后进先出表。允许在栈顶插入、删除元素，不能访问中间元素。默认衍生自deque，由于只涉及单端数据的增删，因此可以使用 vector、list、deque中的任意一种实现。</p><p>须包含头文件：<code>#include &lt;stack&gt;</code>。</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 下面两条初始化语句是等价的</span>stack&lt;<span class="hljs-type">int</span>&gt; stk;stack&lt;<span class="hljs-type">int</span>, deque&lt;<span class="hljs-type">int</span>&gt;&gt; stk;<span class="hljs-comment">// 从 vector 衍生 stack</span>stack&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; stk;stk.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 从栈顶插入元素: 5</span>stk.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 删除栈顶元素</span>stk.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 获取指向栈顶元素的引用</span></code></pre></div><h4 id="queue">queue</h4><p>对应数据结构中的队列，先进先出、后进后出表。只允许在队尾插入元素，队头删除元素。默认衍生自deque，由于需要进行双头数据增删，因此关联的基本容器只能是list、deque，不能是 vector。</p><p>须包含头文件：<code>#include &lt;queue&gt;</code>。</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs scss">queue&lt;<span class="hljs-attribute">float</span>&gt; que;  <span class="hljs-comment">// 初始化</span>que<span class="hljs-selector-class">.push</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 队尾插入元素: 1</span>que<span class="hljs-selector-class">.pop</span>();  <span class="hljs-comment">// 删除队首元素</span>que<span class="hljs-selector-class">.front</span>();  <span class="hljs-comment">// 返回指向队首元素的引用</span>que<span class="hljs-selector-class">.back</span>();  <span class="hljs-comment">// 返回指向队尾元素的引用</span></code></pre></div><h4 id="priority_queue">priority_queue</h4><p>带优先级的队列，一般最大值在队首，且（整型队列）会按照从大到小的顺序排列。只能删除最大值元素，也就是说，只能在队首进行删除。默认衍生自vector，由于要提供随机访问的功能，故不能建立在 list 容器上，可以由vector 和 deque 实现。</p><p>须包含头文件：<code>#include &lt;queue&gt;</code>。</p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>&gt; prq;  <span class="hljs-comment">// 初始化</span>prq.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 插入新元素: 2</span>prq.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 删除队首元素(最大值元素)</span>prq.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 返回队列中最大元素的引用</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Coding Corner</title>
    <link href="/2024/03/16/Coding/"/>
    <url>/2024/03/16/Coding/</url>
    
    <content type="html"><![CDATA[<h2 id="linux-ubuntu系统安装gcc和g">Linux-Ubuntu系统安装gcc和g++</h2><p>GCC：GNU CompilerCollection（GNU编译器集合），它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</p><p>gcc是GCC中的GUN C Compiler（C 编译器）；g++是GCC中的GUN C++Compiler（C++编译器）。</p><h3 id="查看当前版本">1.查看当前版本</h3><div class="code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">gcc</span> <span class="hljs-literal">-</span><span class="hljs-comment">v (gcc</span> <span class="hljs-literal">--</span><span class="hljs-comment">version)</span><span class="hljs-comment">g</span><span class="hljs-literal">++</span> <span class="hljs-literal">-</span><span class="hljs-comment">v (g</span><span class="hljs-literal">++</span> <span class="hljs-literal">--</span><span class="hljs-comment">version)</span></code></pre></div><h3 id="查看目录下已有的gccg版本">2.查看目录下已有的gcc(g++)版本</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /usr/bin/ | grep gcc (g++)</code></pre></div><h3 id="安装对应版本的gcc和g">3.安装对应版本的gcc和g++</h3><div class="code-wrapper"><pre><code class="hljs awk">sudo update-alternatives --install <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/gcc gcc /u</span>sr<span class="hljs-regexp">/bin/g</span>cc-<span class="hljs-number">7</span> <span class="hljs-number">20</span>sudo update-alternatives --install <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/g++ g++ /u</span>sr<span class="hljs-regexp">/bin/g</span>++-<span class="hljs-number">7</span> <span class="hljs-number">20</span></code></pre></div><p>最后的数值（20）表示优先级，数值越大，优先级越高，可以自行设定。</p><h3 id="管理gccg的版本">4.管理gcc(g++)的版本</h3><div class="code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">sudo update</span><span class="hljs-literal">-</span><span class="hljs-comment">alternatives</span> <span class="hljs-literal">--</span><span class="hljs-comment">config gcc (g</span><span class="hljs-literal">++</span><span class="hljs-comment">)</span></code></pre></div><p>上述指令执行后，用户可以自行选择需要的版本，只需要填入相应版本前面的号码再按回车即可。如果目录中已经有需要的版本，便不需要第3步的下载安装了。最后再键入步骤1的指令查看当前版本是否更改成功。</p><h2 id="vscode搭建c运行环境">VSCode搭建C++运行环境</h2><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/643934671"class="uri">https://zhuanlan.zhihu.com/p/643934671</a></p><p>VSCode（全称：Visual StudioCode）是一款由微软开发且跨平台的免费源代码编辑器，轻量可扩展。因为它完全免费，启动速度超级快（没有对比就没有伤害），再加上默认的dark主题很舒服（比Pycharm自带的好很多），所以我相当喜欢这款软件。</p><h3 id="下载安装vscode">下载安装VSCode</h3><p>这一步我就不多说了，网上教程很多，跟着操作就好。然后安装C/C++扩展。</p><h3 id="下载编译器mingw">下载编译器mingw</h3><p>下载链接：<ahref="https://sourceforge.net/projects/mingw-w64/files">MinGW-W64GCC/G++</a></p><p>在"Files"栏往下翻页，在"Totals"之下有很多版本的mingw，可以选择MinGW-W64GCC-8.1.0的x86_64-win32-seh版本，下载并解压至自己想放的文件夹里，记住路径。</p><h3 id="编辑系统环境变量">编辑系统环境变量</h3><p>桌面右键"此电脑"，点击"属性"，然后选择"高级系统设置"，依次点击"高级"- "环境变量"，在系统变量中点击"Path" - "编辑" -"新建"，把mingw64文件夹下的bin文件夹的路径拷贝进去，一路"确定"保存即可。</p><p>接下来进入cmd（command的缩写，即Windows命令提示符，是命令行操作工具，也叫DOS窗口），输入指令<code>gcc -v</code>或者<code>g++ -v</code>（上篇中也介绍过gcc/g++编译器），显示了版本就说明环境已经配置成功啦！</p><h3 id="配置json文件">配置json文件</h3><p>写一段C++代码（后缀名为.cpp），如test.cpp，通过VSCode打开，按快捷键Ctrl + Shift + P调出面板，输入：C/C++，选择"编辑配置（UI）"，在VSCode目录里会出现.vscode文件夹，里面有一个"c_cpp_properties.json"文件。</p><p>在这个配置界面里，编辑器路径根据自己的需求设置：C语言选gcc，C++选g++。编辑器路径是mingw的路径。</p><p>IntelliSense模式设置成：gcc-x64(legacy)，将C标准设置为c11，C++标准设置为c++17。当然，这里也可以将C/C++标准设置成更高的版本。</p><p>此时，c_cpp_properties.json中的文件内容应该是这样的：</p><div class="code-wrapper"><pre><code class="hljs prolog">&#123;    <span class="hljs-string">&quot;configurations&quot;</span>: [        &#123;            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Win32&quot;</span>,            <span class="hljs-string">&quot;includePath&quot;</span>: [                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>            ],            <span class="hljs-string">&quot;defines&quot;</span>: [                <span class="hljs-string">&quot;_DEBUG&quot;</span>,                <span class="hljs-string">&quot;UNICODE&quot;</span>,                <span class="hljs-string">&quot;_UNICODE&quot;</span>            ],            <span class="hljs-string">&quot;compilerPath&quot;</span>: <span class="hljs-string">&quot;/自己的MinGW路径/mingw64/bin/g++.exe&quot;</span>,            <span class="hljs-string">&quot;cStandard&quot;</span>: <span class="hljs-string">&quot;c11&quot;</span>,            <span class="hljs-string">&quot;cppStandard&quot;</span>: <span class="hljs-string">&quot;c++17&quot;</span>,            <span class="hljs-string">&quot;intelliSenseMode&quot;</span>: <span class="hljs-string">&quot;gcc-x64&quot;</span>        &#125;    ],    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-number">4</span>&#125;</code></pre></div><h3 id="配置构建任务">配置构建任务</h3><p>回到test.cpp界面，按下 Ctrl + Shift + P调出面板，输入：tasks，选择"任务：配置默认生成任务"，然后选择"C/C++:g++.exe生成活动文件"，此时.vscode文件夹内会多出一个"tasks.json"文件。文件内容如下：</p><div class="code-wrapper"><pre><code class="hljs nsis">&#123;<span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<span class="hljs-string">&quot;tasks&quot;</span>: [&#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppbuild&quot;</span>,<span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++: g++.exe 生成活动文件&quot;</span>,<span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;/自己的MinGW路径/mingw64/bin/g++.exe&quot;</span>,<span class="hljs-string">&quot;args&quot;</span>: [<span class="hljs-string">&quot;-fdiagnostics-color=always&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;file&#125;</span>&quot;</span>,<span class="hljs-string">&quot;-o&quot;</span>,<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;fileDirname&#125;</span>\\<span class="hljs-variable">$&#123;fileBasenameNoExtension&#125;</span>.exe&quot;</span>],<span class="hljs-string">&quot;options&quot;</span>: &#123;<span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;/自己的MinGW路径/mingw64/bin&quot;</span>&#125;,<span class="hljs-string">&quot;problemMatcher&quot;</span>: [<span class="hljs-string">&quot;<span class="hljs-variable">$gcc</span>&quot;</span>],<span class="hljs-string">&quot;group&quot;</span>: &#123;<span class="hljs-string">&quot;kind&quot;</span>: <span class="hljs-string">&quot;build&quot;</span>,<span class="hljs-string">&quot;isDefault&quot;</span>: <span class="hljs-literal">true</span>&#125;,<span class="hljs-string">&quot;detail&quot;</span>: <span class="hljs-string">&quot;编译器: \&quot;</span>/自己的MinGW路径/mingw64/bin/g++.exe\<span class="hljs-string">&quot;&quot;</span>&#125;]&#125;</code></pre></div><h3 id="配置调试设置">配置调试设置</h3><p>回到test.cpp界面，按下 Ctrl + Shift + P调出面板，输入：debug，选择"调试：开始调试"，再选择"C++(GDB/LLDB)"，然后点击VSCode左上角运行和调试下面的蓝色按钮："创建launch.json文件"，再选择"C++(GDB/LLDB)"。</p><p>此时，.vscode文件夹内会生成一个"launch.json"文件。文件内容中"configurations"属性为空。把launch.json文件中的"configurations"属性内容修改为：</p><div class="code-wrapper"><pre><code class="hljs bash">&#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;g++.exe - 生成和调试活动文件&quot;</span>,    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,    <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,    <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;fileDirname&#125;</span>\\<span class="hljs-variable">$&#123;fileBasenameNoExtension&#125;</span>.exe&quot;</span>,    <span class="hljs-string">&quot;args&quot;</span>: [],    <span class="hljs-string">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,    <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;workspaceFolder&#125;</span>&quot;</span>,    <span class="hljs-string">&quot;environment&quot;</span>: [],    <span class="hljs-string">&quot;externalConsole&quot;</span>: <span class="hljs-literal">true</span>,    <span class="hljs-string">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,    <span class="hljs-string">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;/自己的MinGW路径/mingw64/bin/gdb.exe&quot;</span>,    <span class="hljs-string">&quot;setupCommands&quot;</span>: [        &#123;            <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span>,            <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,            <span class="hljs-string">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span>        &#125;    ],    <span class="hljs-string">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;C/C++: g++.exe 生成活动文件&quot;</span>&#125;</code></pre></div><h3 id="验证可行性">验证可行性</h3><p>回到test.cpp界面，在某条语句前打个断点，按F5进行调试（或者按菜单栏右边的相关按钮），如果调试成功，则说明所有的配置都已经成功了，可以正常使用C++进行编辑、运行和调试了！</p><p>PS：Debug是调试工具，目的是检查程序中可能存在的bug，然后供程序员进行修复。</p><h3 id="补充搭建c语言的运行环境">补充：搭建C语言的运行环境</h3><p>如果想用VSCode搭建 C 语言编译环境，步骤同上，但是 json文件中的某些指令需要稍作修改。</p><p>tasks.json文件只需修改 "tasks": [ ... ] 中的属性 "label" 和 "detail"为下列语句即可：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span>,<span class="hljs-string">&quot;detail&quot;</span>: <span class="hljs-string">&quot;编译器: <span class="hljs-subst">\&quot;</span>/自己的MinGW路径/mingw64/bin/gcc.exe<span class="hljs-subst">\&quot;</span>&quot;</span></code></pre></div><p>launch.json文件中的"configurations"属性内容中，只需修改属性 "name" 和"preLaunchTask" 为下列语句即可：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc.exe - 生成和调试活动文件&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span></code></pre></div><h2 id="linux命令行调试">Linux命令行调试</h2><p>代码的调试（Debug）是软件开发过程中一个至关重要的环节，它指的是在程序开发过程中发现并修正错误（bug）。调试是确保软件按照预期运行的关键步骤。在调试过程中，开发人员通常会使用调试工具（Debugger）来辅助进行。</p><p>调试工具允许开发人员执行以下操作：</p><ul><li>设置断点：在代码的特定位置设置断点，使得程序在到达该位置时暂停执行。这样开发人员可以查看并控制此时程序的状态。</li><li>单步执行：使用Step Over、Step Into、StepOut等命令逐行或逐过程地执行代码，以便观察程序的执行流程。</li><li>查看变量值：在程序暂停时，开发人员可以查看和修改程序中的变量值，以便理解程序当前的状态。</li><li>调用栈跟踪：当程序出现错误时，调试工具可以显示调用栈（CallStack），即函数调用的层次结构，帮助开发人员定位错误发生的具体位置。</li><li>条件断点：设置当满足特定条件时才触发的断点，以便更精确地控制程序的执行流程。</li><li>异常捕获：调试工具可以捕获程序运行时的异常，并显示异常信息和调用栈，帮助开发人员定位和解决问题。</li></ul><h3 id="几种不同的调试方式">几种不同的调试方式</h3><p>在程序调试中，Step Over、Step Into、Step Into my code 和 Step Out是四种不同的调试步骤，它们各自有特定的用途和行为。</p><ul><li><p>StepOver（逐过程执行）：当你执行到一行代码，并且这行代码是一个函数调用时，StepOver会执行整个函数（不会进入函数内部），也就是把整个函数作为一步，然后在函数调用的下一行代码处停止。这在你想要忽略某些函数细节，只想查看程序的主要流程时很有用。</p></li><li><p>StepInto（单步执行/逐语句执行）：当你执行到一行代码，并且这行代码是一个函数调用时，StepInto会进入函数内部，并逐行执行函数内的代码。这对于你想要深入了解函数内部的执行细节时很有用。</p></li><li><p>Step Into mycode（仅进入我的代码）：这是某些集成开发环境（IDE）中的一个选项，特别是当你调试包含第三方库或框架的代码时。当你执行到一行代码，并且这行代码是一个函数调用，但该函数调用属于第三方库或框架时，StepInto my code会忽略这个函数调用，并在该函数调用后的下一行代码处停止。这可以帮助你专注于自己的代码，而不用进入第三方库的细节中。</p></li><li><p>StepOut（步出）：当你已经单步进入了一个函数，并想要快速返回到调用这个函数的代码行时，你可以使用Step Out。Step Out后会执行完当前函数内的剩余代码（但不会进入任何子函数），然后返回到调用这个函数的代码行处停止。</p></li></ul><h3 id="python交互环境中启用调试">python交互环境中启用调试</h3><p>在Linux命令行模式下，有两种常用的代码调试方式，它们都是基于pdb（Python Debugger）的。一种是在文件内使用 pdb模块在需要的地方进行调试，另一种是在命令行以 pdb指令的形式从代码第一行开始调试。</p><p>例如我要调试一个文件名提取函数（FileNameExtraction.py），在文件中可以在指定位置加入调试代码：</p><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> pdb&lt;-- <span class="hljs-keyword">code</span> snippet I --&gt;pdb.set_trace()&lt;-- <span class="hljs-keyword">code</span> snippet II --&gt;</code></pre></div><p>运行上面的代码后，程序会在 pdb.set_trace() 处暂停，此时可以使用 pdb提供的命令对代码进行调试。</p><p>在命令行启动目标程序：</p><div class="code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> -<span class="hljs-keyword">m</span> pdb FileNameExtraction.<span class="hljs-keyword">py</span></code></pre></div><p>然后会进入下图所示的 pdb 调试模式：</p><figure><img src="/img/stage2/011.png" alt="进入pdb调试模式" /><figcaption aria-hidden="true">进入pdb调试模式</figcaption></figure><p>这样程序会自动停在第一行，等待你进行调试。接下来可以使用调试命令进行调试。常用的调试命令有：</p><div class="code-wrapper"><pre><code class="hljs mipsasm">(Pdb) <span class="hljs-keyword">b </span><span class="hljs-number">8</span>  <span class="hljs-comment"># 设置断点：断点设在该文件的第8行（b: break point）</span>(Pdb) <span class="hljs-keyword">b </span> <span class="hljs-comment"># 显示所有断点：b命令，不加参数</span>(Pdb) cl <span class="hljs-number">2</span>  <span class="hljs-comment"># 删除断点：删除第2个断点（cl: clear）</span>(Pdb) cl  <span class="hljs-comment"># 删除所有断点</span>(Pdb) n  <span class="hljs-comment"># Step Over：向下执行一行（n: next）</span>(Pdb) s  <span class="hljs-comment"># Step Into：进入一个函数（s: step）</span>(Pdb) r  <span class="hljs-comment"># Setp Return：快速执行到函数的最后一行（r: return）</span>(Pdb) c  <span class="hljs-comment"># Resume：继续执行代码（c: continue）</span>(Pdb) <span class="hljs-keyword">j </span><span class="hljs-number">10</span>  <span class="hljs-comment"># Run to Line：运行到指定行，即第10行（j: jump）</span>(Pdb) p a,<span class="hljs-keyword">b </span> <span class="hljs-comment"># 查看变量 (a, b) 的值（p: parameter）</span>(Pdb) l  <span class="hljs-comment"># 查看当前代码，即运行到的代码（l: list）</span>(Pdb) a  <span class="hljs-comment"># 查看全部栈内变量，打印所有形参语句（a: args）</span>(Pdb) h  <span class="hljs-comment"># 帮助（h: help）</span>(Pdb) q  <span class="hljs-comment"># 退出调试（q: quit）</span></code></pre></div><h2 id="anaconda常用命令">Anaconda常用命令</h2><p>Anaconda是可以便捷获取包且能对包和环境进行统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</p><p>conda是包及其依赖项和虚拟环境的管理工具，pip是用于安装和管理软件包的包管理器。conda结合了pip和virtualenv（用于创建独立的Python环境的工具）的功能，安装包时自动安装其依赖项，可以便捷地在包的不同版本中自由切换，且适配很多编程语言，因此推荐使用conda。</p><h3 id="environment">environment</h3><p>新建虚拟环境：</p><div class="code-wrapper"><pre><code class="hljs routeros">conda create -n env_name <span class="hljs-attribute">python</span>=x.xconda create --name env_name <span class="hljs-attribute">python</span>=3.8</code></pre></div><p>查看已存在的虚拟环境：</p><div class="code-wrapper"><pre><code class="hljs routeros">conda <span class="hljs-built_in">info</span> -econda env listconda <span class="hljs-built_in">info</span> --envs</code></pre></div><p>进入（激活）虚拟环境：</p><div class="code-wrapper"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> env_name</code></pre></div><p>退出当前虚拟环境：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda deactivate</span></code></pre></div><p>（完整）删除虚拟环境：</p><div class="code-wrapper"><pre><code class="hljs lua">conda <span class="hljs-built_in">remove</span> -n env_name <span class="hljs-comment">--all</span></code></pre></div><h3 id="packages">packages</h3><p>查看所有已安装的包：</p><div class="code-wrapper"><pre><code class="hljs lsl">conda <span class="hljs-type">list</span>pip <span class="hljs-type">list</span></code></pre></div><p>查看某个包是否在当前环境中：</p><div class="code-wrapper"><pre><code class="hljs gauss">conda list pkg_namepip <span class="hljs-keyword">show</span> pkg_name<span class="hljs-meta"># pip show package_name 会显示package的安装路径</span><span class="hljs-meta"># 一般默认的安装路径: (Environment position).../lib/site_packages/</span></code></pre></div><p>安装某个包：</p><div class="code-wrapper"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> pkg_name[=version]pip <span class="hljs-keyword">install</span> some_package[==x.x]<span class="hljs-comment"># -r表示从指定的文件中读取每行的内容（待安装的包列表）</span><span class="hljs-comment"># 指定文件的每行须是一个包名，可以用==或&gt;=指定版本号</span>pip <span class="hljs-keyword">install</span> -r requirements.txtpip <span class="hljs-keyword">install</span> --requirement FILE_name</code></pre></div><p>更新包：</p><div class="code-wrapper"><pre><code class="hljs n1ql">conda <span class="hljs-keyword">update</span> pkg_nameconda <span class="hljs-keyword">update</span> --<span class="hljs-keyword">all</span></code></pre></div><p>删除包：</p><div class="code-wrapper"><pre><code class="hljs routeros">conda <span class="hljs-built_in">remove</span> pkg_namepip uninstall some_package</code></pre></div><p>检验torch是否安装成功：</p><div class="code-wrapper"><pre><code class="hljs awk">python  <span class="hljs-comment"># 进入Python开发环境</span>&gt;&gt;&gt; import torch  <span class="hljs-comment"># 未报错</span>&gt;&gt;&gt; torch.cuda.is_available()  <span class="hljs-comment"># 输出: True</span>&gt;&gt;&gt; <span class="hljs-keyword">exit</span>()  <span class="hljs-comment"># 大功告成！退出即可</span></code></pre></div><p>建议首选conda进行管理。若conda没有相应的包，再使用pip指令。不过pip下载安装的响应很快，且基本不会报错，而conda容易报错，尤其是用conda安装torch的时候。</p><h2 id="git下载代码">Git下载代码</h2><p>Git是一个软件（需要下载安装），可以帮助你在Github网站进行代码操作。GitHub是一个面向开源及私有软件项目的托管平台，即代码仓库。</p><p>在Github上找到了你所需要的项目，只需要在“code”按钮上点击，进入Clone界面，复制代码地址，然后在本地打开GitBash命令行窗口，键入代码：</p><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">copied_address</span></code></pre></div><p>代码就会从网站下载到你的电脑里。</p><p>在使用<code>git clone</code>时，若是遇到了类似<code>fatal: unable to access 'https://github.com/...': Failed to connect to 127.0.0.1 port 7890 after 2021 ms: Couldn't connect to server</code>的报错，一般是配置出了问题。因为git在拉取(clone)或者提交项目时，中间会有git的HTTP和HTTPS代理，但是我们的本地环境中本来就有SSL协议，所以要么重新设置git代理，要么取消git的https代理（不行再把http代理也取消了）。此外，网络原因可能也会导致连接失败，合理科学上网（VPN）可以提高服务器的连接速度，从而解决“timeout 443”问题。</p><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 检查当前全局的http/https代理</span>git config <span class="hljs-params">--global</span> http.proxygit config <span class="hljs-params">--global</span> https.proxy<span class="hljs-comment"># 取消git代理</span>git config <span class="hljs-params">--global</span> <span class="hljs-params">--unset</span> http.proxygit config <span class="hljs-params">--global</span> <span class="hljs-params">--unset</span> https.proxy<span class="hljs-comment"># 设置git代理</span>git config <span class="hljs-params">--global</span> http.proxy http:<span class="hljs-string">//127.0.0.1</span><span class="hljs-function">:7890</span>git config <span class="hljs-params">--global</span> https.proxy https:<span class="hljs-string">//127.0.0.1</span><span class="hljs-function">:7890</span><span class="hljs-comment"># Git的默认编辑器会打开 ~/.gitconfig 文件</span><span class="hljs-comment"># 该文件中包括了代理的配置，可以进行编辑</span>git config <span class="hljs-params">--global</span> <span class="hljs-params">--edit</span><span class="hljs-comment"># 若使用以上方法后仍然报错，可尝试关闭SSL证书验证</span>git config <span class="hljs-params">--global</span> http.sslVerify <span class="hljs-literal">false</span></code></pre></div><h2 id="监控gpu使用情况">监控GPU使用情况</h2><h3 id="工具1nvidia-smi">工具1：nvidia-smi</h3><p>直接在终端输入以下代码即可查看显卡的基本情况：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvidia-smi</span></code></pre></div><p>每过1s自动刷新：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">watch</span> -n <span class="hljs-number">1</span> nvidia-smi</code></pre></div><p>系统指令，无需安装。</p><h3 id="工具2gpustat">工具2：gpustat</h3><p>高亮显示GPU的信息：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">gpustat</span></code></pre></div><p>每秒刷新：</p><div class="code-wrapper"><pre><code class="hljs css">gpustat -<span class="hljs-selector-tag">i</span></code></pre></div><p>需要安装。安装方式：</p><div class="code-wrapper"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> gpustat  作为系统包进行安装pip <span class="hljs-keyword">install</span> gpustat  作为Python库进行安装</code></pre></div><h3 id="工具3nvitop">工具3：nvitop</h3><p>高亮展示完整详细的GPU信息：</p><div class="code-wrapper"><pre><code class="hljs sql">nvitop  (<span class="hljs-keyword">default</span>)nvitop <span class="hljs-operator">-</span>m <span class="hljs-keyword">full</span></code></pre></div><h2 id="runtimeerror-cuda-out-of-memory">RuntimeError: CUDA out ofmemory</h2><p>这个Bug的出现往往是直接采用了作者源代码中的指令，因为自己电脑/服务器的算力不一定能满足其所需。有以下解决方法：</p><h3 id="调小batch_size首选">调小batch_size（首选）</h3><p>一般把batch_size设置为4基本上能解决问题，再不然设置成2呢（不建议这么做，因为太慢了）。</p><h3 id="设置参数梯度推荐">设置参数梯度（推荐）</h3><p>在测试阶段和验证阶段前插入代码 <code>with torch.no_grad()</code>，目的是该段程序不计算参数梯度。不过一般在测试阶段都会这么做吧~</p><h3 id="关闭锁页内存">关闭锁页内存</h3><p>查看代码中是否存在以下代码（通常出现在main.py或者数据加载的py文件中）：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">kwargs</span> = &#123;<span class="hljs-string">&#x27;num_workers&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;pin_memory&#x27;</span>: <span class="hljs-literal">True</span>&#125; if torch.cuda.is_available() else &#123;&#125;</code></pre></div><p>将"pin_memory": True改为：False，具体原因如下：</p><blockquote><p>pin_memory就是锁页内存，创建DataLoader时，设置pin_memory=True，则意味着生成的Tensor数据最开始是属于内存中的锁页内存，这样将内存的Tensor转义到GPU的显存就会更快一些。<br/>主机中的内存，有两种存在方式，一是锁页，二是不锁页。锁页内存存放的内容在任何情况下都不会与主机的虚拟内存进行交换（注：虚拟内存就是硬盘），而不锁页内存在主机内存不足时，数据会存放在虚拟内存中。显卡中的显存全部是锁页内存，当计算机内存充足的时候，可以设置pin_memory=True。当系统卡住，或者交换内存使用过多的时候，设置pin_memory=False。因为pin_memory与电脑硬件性能有关，pytorch开发者不能确保每一个炼丹玩家都有高端设备，因此pin_memory默认设置为False。</p></blockquote><h3 id="降低精度">降低精度</h3><p>如果你用的是Pytorch-Lightning，你也可以尝试将精度更改为“float16”。这可能会带来诸如预期的Double和Float张量之间的不匹配等问题，但它可以节省很多内存，并且在性能上有一个非常轻微的权衡，使其成为一个可行的选择。</p><h3 id="选择空闲显卡">选择空闲显卡</h3><p>在命令行执行指令前加上一行选择GPU的代码，选择空闲状态的GPU运行程序：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">CUDA_VISIBLE_DEVICES</span> = gpu_id[, gpu_id2]</code></pre></div><p>或者，在python源代码中设置：</p><div class="code-wrapper"><pre><code class="hljs moonscript"><span class="hljs-keyword">import</span> <span class="hljs-built_in">os</span><span class="hljs-built_in">os</span>.environ[<span class="hljs-string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>] = <span class="hljs-string">&#x27;gpu_id[, gpu_id2]&#x27;</span></code></pre></div><h3 id="清理内存">清理内存</h3><p>要弄清楚你的模型在cuda上占用了多少内存，你可以尝试：</p><div class="code-wrapper"><pre><code class="hljs scss">import torchdef <span class="hljs-built_in">report_gpu</span>():<span class="hljs-built_in">print</span>(torch.cuda.<span class="hljs-built_in">list_gpu_processes</span>())</code></pre></div><p>在关键的代码节点或报错处（一个epoch跑完）插入以下代码定时清理内存：</p><div class="code-wrapper"><pre><code class="hljs stylus">import gcgc<span class="hljs-selector-class">.collect</span>()torch<span class="hljs-selector-class">.cuda</span><span class="hljs-selector-class">.empty_cache</span>()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读 · 万卷计划</title>
    <link href="/2024/03/14/Read%20and%20Think/"/>
    <url>/2024/03/14/Read%20and%20Think/</url>
    
    <content type="html"><![CDATA[<h2 id="实录毛泽东">实录毛泽东</h2><p>作者：李捷 于俊道</p><p>简介：本书精选了毛泽东的老师、同学、战友、身边工作人员、亲属以及外国领导人、驻华大使等273人的回忆，全面、客观、翔实地记录了毛泽东的一生。本书对各个时期的重大历史事件都有详细深刻的记录，从历史背景、内中原委、事实真相，以及当事人的亲身感受等方面作了客观生动的写照，细节回忆，寓意深远。</p><h3 id="摘录1讲堂录-修身篇">摘录1：讲堂录-修身篇</h3><p>1913年春，19岁的毛泽东以优异成绩考入湖南省立第四师范学校（于1914年合并于省立第一师范学校）。在校期间，毛泽东听课十分认真，记下大量笔记和读书礼记《讲堂录》。以下是我读时感觉颇有启迪意义的几句话：</p><p>人情多耽安佚而惮劳苦，懒惰为万恶之渊薮。人而懒惰，农则废其田畴，工则废其规矩，商贾则废其所鬻，士则废其所学。业既废矣，无以为生，而杀身亡家乃随之。国而懒惰，始则不进，继则退行，继则衰弱，终则灭亡。可畏哉！故曰懒惰万恶之渊薮也。</p><p>奋斗。夫以五千之卒，敌十万之军，策罢乏之兵，当新羁之马，如此而欲图存，非奋斗不可。</p><p>朝气。少年须有朝气，否则暮气中之。暮气之来，乘疏懈之隙也，故曰怠惰者，生之坟墓。</p><p>药文弱。文弱者多，国用不振，吾国是也，坐此而不能与外竞。夫兵者，国之卫也，非强悍有力者不胜其任，尤非多受教育者不能有功。吾国士人既甚弱矣，则兵出于召募，而无赖鲜识之徒充其选，驱之临战，不待交而先溃，历年国受巨创者以此。游乎日本，则大不然者。有主教育者演说曰：日本立乎世界竞争之涡，诸强挟全势以临我，危乎殆哉！非兵不立，则身体之锻炼其急矣，云云。其在日本，学校最重运动，其运动之法有诸种：庭球、野球、蹴球、弓拔、击剑、柔道、短艇、游泳、徒步、远足会皆是。西国亦然。如远足会之事，以期举校远行，先择佳地，既至，则集众演说，莫敢不至者。凡此皆所以药文弱之道也，勉矣后生。</p><p>勤务。勤务之益，一以医偷惰，二以药文弱。有地板之室，不应用帚扫，致扬尘，必以布揩之。</p><p>知觉类化。解甲物而有通乎己，思此理而有会乎彼。及其至也，大宇之内，万象之众，息息而相通，是谓知觉类化。</p><p>闭门求学，其学无用。欲从天下国家万事万物而学之，则汗漫九垓，遍游四宇尚已。</p><p>游之为益大矣哉！登祝融之峰，一览众山小；泛黄勃之海，启瞬江湖失；马迁览潇湘，泛西湖，历昆仑，周览名山大川，而其襟怀乃益广。</p><p>才不胜今人，不足以为才；学不胜古人，不足以为学。</p><p>天下无所谓才，有能雄时者，无对手也。以言对手，则孟德、仲谋、诸葛而已。</p><p>人之议之者尊之也。天下惟庸人不惹物议，若贤者则时为众矢之的，故曰事修而谤兴，德高而毁来。</p><p>程子曰：货色两关打不破，其人不足道也。</p><p>恶事终有露布之一日，故曰若要人不知，除非己莫为。</p><p>拿得定，见得透，事无不成。</p><p>惟明而后可断，既明而断矣，事未有不成者，伊尹是也。</p><p>惟安贫者能成事，故曰咬得菜根，百事可做。</p><p>乐利者，人所共也，惟圣人不喜躯壳之乐利（世俗之乐利），而喜精神之乐利，故曰饭疏食饮水，曲肱而枕之，乐亦在其中矣。不义而富且贵，于我如浮云。</p><h3 id="摘录2青年之抱负">摘录2：青年之抱负</h3><p>毛泽东在湖南省立第一师范学校结识了不少良师益友。在老师中，有杨昌济、徐特立、袁仲谦、黎锦熙、方维夏、王季范等。在同学中，有罗学瓒、周世钊、蔡和森、陈章甫、张昆弟、萧三、萧子升等。其中，又以杨昌济和黎锦熙对他的影响最大，联系也最多。</p><p>在1915年4月15日杨昌济的日记中有这样的记载：</p><p>毛生泽东，言其所居之地为湘潭与湘乡连界之地，仅隔一山，而两地之语言各异。其地在高山之中，聚族而居，人多务农，易于致富，富则往湘乡买田。风俗淳朴，烟赌甚稀。渠之父先亦务农，现业转贩，其弟亦务农，其外家为湘乡人，亦农家也，而资质俊秀若此，殊为难得。余因以农家多出异材，引曾涤生、梁任公之例以勉之。毛生曾务农两年，民国反正时又曾当兵半年，亦有趣味之履历也。</p><p>有一年多，他们都不曾吃早饭。一个暑假期内，毛泽东、蔡和森和张昆弟三人同住长沙对河岳麓山上，爱晚亭读书、休养，每天吃新蚕豆饭一顿，既废朝食，也不晚餐——这当然也有节省的意思在内，因为他们都穷呵！在那里他们每天清早在山上打坐，然后下来去塘里或河里洗冷水澡。这样持续到假期满后回校，到冬天11月里还不停止。毛泽东更扩大浴的范围：在太阳下面、在大风里、在大雨下、赤着让身体晒、让吹、让淋。泽东叫这作“日浴”“风浴”“雨浴”。那时他们又常去水陆洲——湘江里游泳。凡此一切，目的在锻炼身体。他们又去山中“练嗓子”，对着树木大声讲话，朗诵唐诗；在长沙城墙上天心阁一带对着风大声叫喊...这些行动，不期然而然地正合乎现在大家所知道的日光浴、空气浴、淋浴等疗养卫生的好方法。</p><p>在爱晚亭住的时候，他们只各有一条面巾，一把雨伞和随身的衣服。泽东常着的一件“土地袍子”（灰布长褂），给人的印象最深。</p><p>岳麓山上有一副对联：“西南云气来衡岳，日夜江声下洞庭。”在这山上，在这背景下，毛泽东等一天早晚是体操、静坐、读书、看报、谈论和思考问题。</p><p>夜里他们露宿，睡草地上，彼此离得远远的，怕呼吸空气不好...回校后他们就在操场露宿，直到打霜以后。</p><p>关于上面所举的一切，毛泽东那时在自己的日记里写道：</p><p>与天奋斗，其乐无穷！<br/> 与地奋斗，其乐无穷！<br/>与人奋斗，其乐无穷！</p><h3 id="摘录3为学之道">摘录3：为学之道</h3><p>毛泽东对湖南省立第一师范学校的环境感到满意，并学习和接触到不少新鲜知识和新的事物。他回想起过去几年的读书生活，认识到自己过去是太强调自学了。他重新思考，为自己定下新的为学之道。</p><p>1915年6月25日，毛泽东在写给湘生的信中说道：</p><p>湘生足下：初一日接君书，今二十五日矣，未作复者，吾夏假住处未定也。前友人招往浏阳，继吾不欲往，寓省城又无钱，故只有回家一法。学校试验今日完，吾于课程荒甚。从前拿错主意，为学无头绪，而于学堂科学，尤厌其繁碎。今闻于师友，且齿已长，而识稍进。于是决定为学之道，先博而后约，先中而后西，先普通而后专门。质之吾兄，以为何如？前者已矣，今日为始。昔吾好独立蹊径，今乃知其非。学校分数奖励之虚荣，尤所鄙弃，今乃知其不是。尝见曾文正家书有云：吾阅性理书时，又好做文章；做文章时，又参以他务，以致百不一成。此言岂非金玉！吾今日舍治科学，求分数，尚有何事？别人或谓退化，吾自谓进化也。阅足下所定课程及为学之功，使愧慑无地。不知足下之意，学校与自修果已定否？看君欲学英文、数学，又似预备进学校。如言自修，吾举两人闻君。其一康有为。康尝言：吾四十岁以前，学遍中国学问；四十年以后，又吸收西国学问之精华。其一梁启超，梁固早慧，观其自述，亦是先业词章，后治各科。盖文学为百学之原，吾前言诗赋无用，实失言也。足下有志于此乎？来日之中国，艰难百倍于昔，非有奇杰不足言救济，足下幸无暴弃。同学陈子，有志之士，余不多见。屠沽贾炫之中，必有非常之人，盍留意焉！人非圣贤，不能孑然有所成就，亲师而外，取友为急，以为然乎？读君诗，调高意厚，非我所能。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reflection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献整理 · 旁搜博采篇</title>
    <link href="/2024/03/14/papers5/"/>
    <url>/2024/03/14/papers5/</url>
    
    <content type="html"><![CDATA[<h2 id="stfuse">STFuse</h2><p>STFuse: Infrared and Visible Image Fusion via Semisupervised TransferLearning, 2023(IEEE)</p><h3 id="abstract">Abstract</h3><p>作者提出了一种基于半监督迁移学习的 IVIF（infrared and visible imagefusion）方法，称为STFuse，其目的是将知识从信息丰富的源域转移到目标域，从而突破标注信息（groundtruth）或先验信息（priorknowledge）缺乏的限制。方法的关键是借用多焦点图像融合 MFIF（multi-focusimage fusion）任务的监督知识，并使用引导损失（guidanceloss）过滤掉特定任务的属性知识（MFIF相关的），这激发了其在 IVIF任务中的跨任务使用。使用这种跨任务知识有效地缓解了缺乏 ground truth对融合性能的影响，监督知识约束下的互补表达能力比先验知识更有指导意义。此外，作者还设计了一个交叉特征增强模块CEM（cross-feature enhancementmodule），该模块利用自己实现的自注意和互注意特征来引导每个分支细化特征，然后促进跨模态互补特征的整合。</p><h3 id="motivation">Motivation</h3><p>有监督方法的有效性通常依赖于具有标注信息的大量训练数据，且应与测试数据表现出一致的统计特征。因此，对于IVIF任务，由于传感器硬件特性和任务复杂性限制，收集这些数据通常很昂贵，要耗费很大的人力，或在技术上具有挑战性。虽然一些方法利用fusion definitions 标注小批量的训练数据来实现IVIF，但训练数据不足使模型无法充分挖掘源图像的内容，导致泛化能力有限。在这种情况下，基于DL 的 IVIF方法通常需要结合某种形式的标注或先验知识来促进融合过程，减轻由于缺乏ground truth 约束而导致的限制。</p><p>针对上述问题，本文提出了一种基于半监督迁移学习的 IVIF 模型STFuse，该模型通过参数学习估计每个源图像的融合贡献，得到融合图像。本文的主要思想是将监督情况下的多焦点图像融合MFIF 的互补特征提取能力转移到IVIF，以指导跨模态信息的融合。因为每个子融合任务基本上都是通过捕获源图像之间的互补特征来进行融合的。然而，由于子任务具有不同的任务属性，研究人员在设计具有互补特征的感知方案时考虑了任务属性的差异。</p><p>本文的核心是利用梯度信息构建引导损失，有效地从原始模型中过滤掉与 IVIF任务无关的非增益知识。具体来说，在研究 MFIF 和 IVIF之间的共性后，作者观察到这两个任务都旨在生成具有清晰纹理和丰富细节的高质量融合图像，图像中具有丰富边缘和纹理特征的梯度信息。这就是说，两种不同方法的融合图像都有效地保留了源图像的梯度信息，这是二者的共性所在。此外，为了提高解码器预测的融合贡献的准确性，本文引入了一个跨特征增强模块CEM。该模块采用跨通道注意力机制细化来自不同分支的特征信息，从而防止源图像信息的冗余，优化融合过程。</p><h3 id="method">Method</h3><p>在 IVIF融合子任务中，融合图像应包含来自不同源图像的互补特征。也就是说，每个源图像都应该以互补的方式对融合图像做出贡献。所以可将融合任务看作是一个估计任务，目标是估计每个源图像的融合贡献。因此，融合图像可以表示为：<spanclass="math inline">\(F = w_{A} \otimes I_{A} + w_{B} \otimesI_{B}\)</span>。其中 w 表示源图像 A、B 对融合图像 F 的贡献度，<spanclass="math inline">\(\otimes\)</span> 表示对应元素相乘（Hadamardproduct，哈达玛积）。</p><p>只要估计出 <span class="math inline">\(w_A\)</span> 和 <spanclass="math inline">\(w_B\)</span>，融合问题就迎刃而解了。怎么估计呢？让我们转向MFIF 这个融合子任务。首先，MFIF得是个有监督模型，然后我们才能利用里面的知识。但我们也不能采用“拿来主义”，因为MFIF 与 IVIF 的属性是不一样（换个高级点儿的词：不匹配）的，直接使用 MFIF的有监督模型肯定对 IVIF 起不到任何好的作用。经过分析，MFIF 和 IVIF都试图尽可能多的感知和利用源图像的互补信息，以生成满足各自任务需求的高质量图像。高质量融合图像是有共同点的：纹理细节信息十分丰富（要不然也谈不上质量高）。说到细节信息，你第一时间能想到什么？——Yes，梯度！梯度信息可以作为从 MFIF 到 IVIF的跨任务转移知识进行利用的一种指导。</p><p>接下来出场的就是本文的核心：Semisupervised transfer learning-basedfusionmodel，即基于转移知识学习的半监督融合模型。这个模型有点像教师—学生模型（知识蒸馏与迁移学习在模型优化中的应用）。知识蒸馏采取Teacher-Student 模式：将复杂且较大的模型作为Teacher，结构较为简单的模型作为 Student，用 Teacher 模型来辅助 Student模型的训练，Teacher模型学习能力强，可以将它学到的知识迁移给学习能力相对弱的 Student模型，以此来增强 Student 模型的泛化能力。复杂笨重但是效果好的 Teacher模型不上线，就单纯是个导师角色，真正部署上线进行预测任务的是灵活轻巧的Student 模型。</p><p>但本文中不是套用知识蒸馏的框架（真的只是有点像而已），因为 MFIF 和IVIF 各自学习能力很难说孰强孰弱（都不弱~）。STFuse包含一个学生模型和一个教师模型，其中教师模型通过基于学生模型的EMA（exponential meanaverage，指数平均）方式更新。学生模型最初使用标记数据进行预训练。随后，未标记数据和标记数据形成混合数据，传入学生模型中进行训练，这是为了避免训练过程中的知识遗忘。在每次训练迭代中，教师模型使用未标记数据来用于生成伪标签，以便伪标签监督未标记的数据，标签监督标记数据。同时，引导损失<span class="math inline">\(L_g\)</span>确保保留跨模态的通用性知识（专注于挖掘互补的梯度信息），同时过滤任务专有的知识，尽量避免任务属性的影响（也就是学好的方面别学坏的）。最终让学生模型（作为目标模型：targetmodel）用于 IVIF 任务。</p><blockquote><p>STFuse contains a student model and a teacher model, where theteacher model is updated by EMA manner based on the student model. Thestudent model is initially pretrained with labeled data. Subsequently,unlabeled and labeled data form the mixed data. And in each trainingiteration, the teacher model is used to generate pseudo-labels so thatthe pseudo-labels supervise the unlabeled data and the labels supervisethe labeled data. Meanwhile, guidance loss ensures that generalityknowledge of cross-modal is retained while individual knowledge isfiltered.</p></blockquote><figure><img src="/img/stage2/009.png"alt="Overview of our proposed STFuse method: (a) cooperative training process, (b) proposed fusion network, and (c) architecture of CEM in (b)." /><figcaption aria-hidden="true">Overview of our proposed STFuse method:(a) cooperative training process, (b) proposed fusion network, and (c)architecture of CEM in (b).</figcaption></figure><p>上图是 STFuse的总体框架和流程。图（a）是训练的策略。图（b）是网络的架构，包含一个双分支、权重共享的编码器Encoder 和一个解码器 Decoder，Encoder 负责提取信息，Decoder负责重建图像（生成融合图像）。很明显，Encoder的性能直接影响最终的融合结果。为了进一步提高 Encoder的信息提取能力，作者加了如图（c）所示的 CEM模块，其利用自注意力和互注意力（不是 Attention机制，是自己实现的网络结构）来精炼不同分支的特征，提高模型对互补特征的敏感性。</p><p>图中：<span class="math inline">\(I_A^i\)</span> 和 <spanclass="math inline">\(I_B^i\)</span> 代表源图像，i 代表第 i个图像，经过卷积模块（卷积、BN、ReLU）得到聚合的特征 <spanclass="math inline">\(F^A_{i}\)</span> 和 <spanclass="math inline">\(F^B_{i}\)</span>。然后传入 CEM 模块，一条分路经过GAP（global adaptivepooling）操作计算各自的全局信息，再经过卷积（卷积、LeakyReLU、Sigmoid）、Multiplication（对应元素相乘，即哈达玛积）得到self-refining feature（抑制了不必要的场景理解信息）；另一条分支是经过GAP、卷积、Softmax（SM）、Multiplication 得到 mutual-refiningfeature（信息交互，加强互补特征提取）。最后经Concatenation（向量特征拼接）操作 + 卷积得到最终的 refinementfeature：<span class="math inline">\(\widetilde{F}_i^A\)</span> 和 <spanclass="math inline">\(\widetilde{F}_i^B\)</span>。</p><h3 id="loss">Loss</h3><p>labeled dataset: <span class="math inline">\(D_l = \{(X_i^l, \Y_i^l)\}^N_{i=1}~~\)</span> 取自：多聚焦数据集<br/> unlabeled dataset:<span class="math inline">\(D_u = \{(X_i^u)\}^N_{i=1}~~\)</span>取自：红外可见光数据集<br/> mixed dataset: <spanclass="math inline">\(D_t = \{D_l \cup D_u\}\)</span>（正式训练阶段学生模型使用的训练集）</p><p>X 包含两类源图像 A、B：<span class="math inline">\(X_i = \{I_A^i, \I_B^i\}^N_{i=1}\)</span></p><p>在使用 <span class="math inline">\(D_l\)</span> 的预训练阶段，Student模型可以学习 generic knowledge <span class="math inline">\(\phi_g\)</span>（i.e., 通用互补特征提取能力）和 attribute task knowledge<span class="math inline">\(\phi _a\)</span>（i.e.,聚焦区域检测能力）。之后在自训练框架（图a）中，Student 模型将着重提取<span class="math inline">\(\phi _g\)</span>。</p><p>学生模型是要训练的目标模型，它使用指数平均 (EMA)将每一轮更新的学生模型参数 <span class="math inline">\(\theta_s\)</span> 分配给教师模型参数 <span class="math inline">\(\theta_t\)</span>，而教师模型的预测结果（伪标签）将被视为学生模型学习的额外监督。</p><p>学生模型的优化目标：最小化总损失 <spanclass="math inline">\(L_{total}\)</span>：</p><p><span class="math display">\[L_{total} = L_{un} + L_s + \lambdaL_g\]</span></p><p>上式中，<span class="math inline">\(L_{un}\)</span> 代表 unsupervisedloss，<span class="math inline">\(L_s\)</span> 代表 supervisedloss，<span class="math inline">\(L_g\)</span> 代表 guidance loss。</p><p><span class="math display">\[ L_{un} = \Vert \theta _s(X_i^u) -\theta _t(X_i^u) \Vert_1\]</span></p><p><span class="math display">\[ L_s = \Vert \theta _s(X_i^l) - Y_i^l\Vert_1\]</span></p><p><span class="math inline">\(L_s\)</span> 用于确保 <spanclass="math inline">\(D_l\)</span> 中 <spanclass="math inline">\(X_i^l\)</span> 的融合结果与其对应的标签 <spanclass="math inline">\(Y_i^l\)</span> 尽量相似，<spanclass="math inline">\(L_{un}\)</span> 用来确保 <spanclass="math inline">\(D_u\)</span> 中 <spanclass="math inline">\(X_i^u\)</span>的融合结果与其对应的伪标签尽量一致。在功能上，二者都旨在最小化输出和输入之间的差异，从而促进模型从MFIF 中获取监督知识。</p><p>然而 <span class="math inline">\(\phi _a\)</span> 的存在会影响模型在IVIF的性能，因此作者使用梯度信息作为“过滤器”来促进监督知识的跨任务利用。作为指导项，我们不需要它准确地计算图像的梯度信息，只要从广义的角度指导模型学习就够了。因此作者选择Sobel 算子作为梯度信息的统计工具。引导损失 <spanclass="math inline">\(L_g\)</span> 可以表示为：</p><p><span class="math display">\[\begin{align}L_g &amp;= \Vert \nabla \theta _s(X_i^u) - \nabla X_i^u \Vert_1 \\&amp;= \Vert \nabla \theta _s(X_i^u) - \nabla (I_A)_i^u \Vert_1 + \Vert\nabla \theta _s(X_i^u) - \nabla (I_B)_i^u \Vert_1 \nonumber\end{align}\]</span></p><p>其中 <span class="math inline">\(\nabla\)</span> 表示 Sobeloperator。</p><h3 id="summary">Summary</h3><p>本文的一大亮点是将多聚焦融合任务和红外可见光融合任务进行了关联，通过分析二者的异同，利用MFIF 和 IVIF 之间的共性（梯度约束），借助 MFIF 的优势，完成缺乏 groundtruth 的 IVIF 任务。</p><p>本文模型整体比较简单，思路清晰，但是未公开源代码，因此对实验结果的真实性验证和复现需要费一番功夫。不过本文的思想还是很新颖的，值得学习。</p><p>不过阅读完本文后还有一个问题：本文提出的 Student 和 Teacher模型的网络结构分别是什么？个人认为二者都是上图（b）中的结构。因为学生模型作为处理IVIF 任务的目标模型，需要从 MFIF任务中进行学习，而教师模型则需要根据红外-可见光训练数据生成伪标签，进而用于损失函数之中。再加上教师模型的参数由学生模型的参数通过EMA 方式更新，因此我觉得二者网络应该一样，以保证上述功能的实现。</p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summarize</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Knowledge Mining</title>
    <link href="/2024/03/14/knowledge/"/>
    <url>/2024/03/14/knowledge/</url>
    
    <content type="html"><![CDATA[<h2 id="embedding">Embedding</h2><p>参考文章：<ahref="https://mp.weixin.qq.com/s/7kPxUj2TN2pF9sV06Pd13Q">没有思考过Embedding，不足以谈AI</a></p><h3 id="编码文字的数字化">编码：文字的数字化</h3><p>Embedding这个词直译为中文是：嵌入，这是让人摸不着头脑的两个字。啥是嵌入？嵌入了啥？跟自然语言又有啥关系？</p><p>嵌入的体现形式是一组具有固定长度的数组（向量），接下来我们将探讨它的本质以及它在计算机理解自然语言的过程中所扮演的角色。</p><p>要解答以上问题，不妨先思考：让计算机理解自然语言，我们需要做什么？</p><p>计算的基础是数，而自然语言是文字，因此很容易想到要做的第一步是让文字数字化——编码。要设计编码的方法，需要思考的问题是：哪些性质是编码规则必须要满足的？</p><p>有一条是显然可以给出的：</p><p><font color="blue">性质一：每一个词具有唯一的量化值，不同词需要具有不同的量化值</font></p><p>背后的逻辑不言自明：一词多数，或多词一数，都会增加计算机理解语言的难度，这种难度就如同多音字或多义词给人类造成的困难，尽管智慧让我们可以克服这些障碍，但对计算机来说，为它降低一些难度显然是必要的。</p><p>满足性质一的方法非常容易设计，例如：首先穷举出人类所有的文字或词组 ——这个集合必定是有限集，例如汉字有10万个，字母有26个，英语单词数小于100万个。由于是有限集，我们可以给每一个词分配一个固定的数字。</p><p>很显然，这一方法存在一个很大的问题：数的值与词的义是割裂的。</p><p>可以通过一个简单的例子来思考：在英语中，a和an是完全同质的词，而a和abnormal则是差异极大的词。如果按照上述编码方式，可能会有以下赋数方式：a=1，abnormal=2，an=100，这个时候我们会发现a和abnormal似乎在数值上更加靠近，而a和an这两个同质的词却隔得非常远。因此，需要添加一条规则来确保数字化后的数值与词义之间具有关联：</p><p><font color="blue">性质二：词义相近的词需要有“相近”的量化值，词义不相近的词量化值需要尽量“远离”</font></p><p>这一性质很容易理解，如果近义词具有相近的量化值，那么意思相近的句子编码后相关性也更大，即同义的句子在序列特征上会更加接近，这将有利于计算机而言更高效地理解共性、区分特性；反之则会给计算机制造非常多的困难，难以捕捉同质内容之间的共性，就意味着模型需要更多的参数才能描述同等的信息量，学习过程自然就会更加困难。</p><h3 id="基于语义的编码">基于语义的编码</h3><p>OpenAI的JackRae在Standford的分享中提到了一个很深刻的理解语言模型的视角：语言模型就是一个压缩器。</p><p>所有的压缩，大抵都能被概括在以下框架内：提取共性，保留个性，过滤噪声。带着这个视角去看，就更容易认识到性质二的必要性。不同词所编码的数值，是否基于词义本身的相似性形成高区分度的聚类，会直接影响到语言模型对于输入数据的压缩效率。</p><p>对于神经网络模型，词的量化值可以全部是整数，但是语言模型的输出则不一定是整数。例如当模型输出1.5，词表只定义了1和2，这时该如何处理呢？</p><p>我们会希望1和2都可以，甚至3也不会太离谱，因此1和2所代表的词在词义上最好有某种共性，而不是像"a"和"abandon"一样，几乎找不到词义上的关联。当相近的词聚集到一起，推断出有效输出的概率就会更高。</p><p>但是新的问题又出现了（或许应该说本来就存在，只是刚被发现）：词义具有多维性。例如A和B词义相似，B和C词义相似，但并不意味着A和C词义也相近。</p><p>当用一个标量来表示一个词时，词和词之间的关系只能基于两个标量间的差值得到，从而只有“远”和“近”两种状态，但实际情况是两个词只在某些维度上接近。如“Love”和“Passion”接近的地方是：情感浓度，二者都表示存在强烈的情感，但是在情感色彩方面（消极or积极），“Love”是积极的，“passion”具有更加中性的色彩，于是同样具有浓烈情感的“Rage”也与“Passion”相近，但是“Rage”的情感色彩却是消极的。</p><p>于是我们需要一个多维的数字形态，即使用向量 ——对于每一个词，我们可以表达为一组数，而非一个数。这样一来，就可以在不同的维度上定义远近（距离），词与词之间复杂的关系便能在这一高维的空间中得到更详细的表达。<font color="red">这，就是Embedding！</font>“嵌入”这个名字其实并不贴切，不妨可以叫它“词义向量”，其所处的空间可以称为“词义空间”。</p><h3 id="编码器的设计">编码器的设计</h3><p>目前为止，我们已经找到了可以用于表达词义的数字化形式 ——向量，也知道了一个好的编码方式应当满足的性质。如何设计一套方法，来完成我们所期望的编码，就成了最后的问题。</p><p>一个比较容易想到的方法是，令词义的不同维度和向量的不同维度进行关联。例如，对词义的维度进行全面的拆分：名词、动词、形容词、数量特征、颜色特征、人物、主动、被动、情感色彩、情感强度、空间特征等等，只要维度的数量足够多，一定可以把词义所包含的信息全都囊括在内。一旦我们给出每一个维度的定义，就可以给出每个词在相应维度上的数值，从而完成词的向量化，并且完美地符合以上给出的两点性质。但这个看似可行的设计，并不具备可实现性。</p><p>首先要能够囊括所有词义的不同维度，需要的维度数量必然极高，而要对词义进行这么精细的切分，本身就非常困难，其次即使切分成功了，要将每个词不同维度的意义赋予有效的数值，哪怕是资深的语言学家恐怕也会感到棘手。今天大家所熟知的语言模型中，并没有一个是用这一方式对词进行向量化的。但是这个思想方案却是有意义的，词义向量的不同维度之于计算机，就如同上面我们列举的维度—— 词性、数量、时间、空间等等之于人类。</p><p>纯构建的方式是不可行的，但今天我们已经知道了一套有效的解决办法：神经网络加大数据，暴力出奇迹。这套范式的起源是：Word2Vec。语言模型基于词义向量，而词义向量真正开始有效，正是从Word2Vec模型开始的。</p><p>Word2Vec的关键是：一个词的意义，可以被它所出现的上下文定义。换一种说法：上下文相似的词在词义上也存在一定的相似性。Word2Vec的两类做法分别是：</p><p><font color="green">中心词 --&gt; 神经网络 --&gt; 上下文</font></p><p><font color="green">上下文 --&gt; 神经网络 --&gt; 中心词</font></p><p>这个方法当然不是终点，它的局限性是明显的，但开创性已经足够了。本质上，Word2Vec并没有尝试去理解句子的语义。因此对于完全相同的上下文，不同的中心词的词义相似性是容易捕捉的。当词义向量的聚类逐渐形成，由近义词构成的上下文，也一定程度上能够标记词义相近的中心词。但人类的语言结构非常复杂，当相同语义通过不同句式、语态、修辞进行表达时，某些近义词对的关系可能无法设别。</p><h3 id="浅谈gpt">浅谈GPT</h3><p>GPT（Generative Pre-Training LanguageModels）是一个有能力理解句子的模型。如果说此前讨论的Word2Vec这类构建词义向量的模型是教计算机“认字”的过程，那么GPT模型的训练，则是“认字”+“背书”的过程。老师最后只考书背的好不好，但为了把书背好，GPT也被动地强化了其认字的能力。</p><p>GPT推理的核心是Transformer，Transformer的核心是Attention机制，Attention机制是什么？</p><p>一言以蔽之：计算词义向量之间的“距离”后，对距离近的词注入更多的注意力，而收到高注意力的词义则获得更高的激活值，当预测完成后，通过反向传播算法，特定的激活帮助了最终的预测，对应词之间关联将被强化，反之则被弱化，也即：通过计算注意力分数和对值进行加权求和来产生关注的输出，模型便是通过这一方式学到了词之间的关系。</p><p>本文作者的理解我觉得有一定的道理：Attention机制之所以重要和好用，原因之一是可以有效帮助词义向量（Embedding）聚类。</p><p>GPT的例子想想其实很有趣，一般的工程思维是将大的问题拆分成多个小问题然后逐个解决，但对与计算机处理问题而言有所不同。正如刚开始提出的问题：让计算机理解自然语言，我们需要做什么？然后分析：计算的基础是数，而自然语言是文字，因此第一步是让文字数字化。这其实是走了这样一条解决问题的路径：先将文字数字化后，再考虑理解句子。有趣的是，对词进行向量化编码的最好方法，是直接训练一个理解句子的语言模型。这就像为了让婴儿学会走路，我们直接从跑步开始训练。人类会摔跤会受伤，但机器不会—— 至少在Embodied <span class="math inline">\(^{[1]}\)</span>之前不会，因此人类自身为了降低代价所建立的步骤化学习过程或许并不适合人工智能。其实不难发现，深度学习中许多好的解决方案往往都是一步到位的。</p><p>[1]在深度学习领域，"Embodied"通常指的是将模型嵌入到具有物理实体的环境中进行学习和交互。在传统深度学习中，模型通常是在静态数据集上进行训练和测试的，而不考虑模型在真实环境中的交互。然而，在一些应用领域（机器人学、自动驾驶等），模型需要在真实环境中进行学习和决策。在这种情况下，"Embodied"深度学习侧重于将模型放置在与环境交互的设置中，通过感知环境、采取行动并与环境进行反馈交互来学习。这样做的目的是使模型更加适应现实世界的复杂性和不确定性，从而能够更好地应对复杂的任务和场景。这种方法可以带来更加鲁棒和智能的系统，因为模型需要考虑到环境的动态变化，并根据实时反馈进行决策和调整，可以更好地理解和解决现实世界中的问题。</p><h2 id="感受野">感受野</h2><p>感受野（Receptive Field）定义：卷积神经网络每一层输出的FeatureMap上的像素点映射回输入图像上的区域大小，即卷积神经网络能看到的输入图像的区域。</p><h3 id="感受野的大小">感受野的大小</h3><p>输入图片在经过不同的卷积层时，卷积核能看到的图像结构是不一样的。当经过较浅的卷积层作用后，生成的图像（更准确的说应该是特征图）中每个像素点只是对原图像局部信息的一个特征提取（卷积的作用：通过卷积核提取图像的特征，卷积核的大小决定了对图像局部加权的范围），图像的细节信息丰富，但是图像的上下文信息很少，我们将其称之为图像的感受野小。反之，图像经过深层的卷积层作用之后，图像能看到的原图像的范围更大，但同时细节信息缺失（这很容易理解：看得更多更广了，自然会忽视掉部分细节），我们将其称之为图像的感受野大。</p><p><img src="/img/stage2/002.jpg" /></p><h3 id="大感受野的作用">大感受野的作用</h3><p>一般任务要求感受野越大越好，比如图像分类中最后的卷积层感受野要比输入图像的尺寸大。理论上，网络越深、感受野越大，性能越好。</p><p>密集预测任务（Dense Prediction，源自semanitc imagesegmentation，图像语义分割的目标是将图像的每个像素所属类别进行标注。因为是预测图像中的每个像素，这个任务通常被称为密集预测）要求输出像素的感受野足够大，确保做出决策时没有忽略重要信息，网络深度也要够深。</p><p>目标检测任务中设置Anchor（先验框、锚点、prior boundingbox，是提前在图像上预设好的不同大小、不同长宽比的框，使得模型更容易学习目标的位置、大小和其中的特征）要严格对应感受野，Anchor的太大或者偏离目标太多都会严重影响检测性能。</p><h3 id="增大感受野的方法">增大感受野的方法</h3><p>主要的方法是增加网络的深度。</p><ul><li><p>Pooling（池化）。对数据降维，减小网络参数，提升计算效率，同时增加感受野，但是会造成分辨率降低，损失图像的细节信息。</p></li><li><p>Dilatedconv（空洞卷积）。可以解决池化操作增加感受野后图像信息缺失的问题。</p></li></ul><p><img src="/img/stage2/001.png" /></p><p>图（a）是普通卷积的运算看到的感受野大小，卷积后的每个像素能看到的卷积前图片的区域为3x3。图（b）可以当成使用卷积核为7x7进行的卷积运算，但其中只有标记为红色的9个点参与计算（dilated为2），能看到的感受野范围是7x7大小。同理图（c）可以当成是使用卷积核为15x15进行卷积运算，但其中只有标记为红色的9个点参与计算（dilated为4），能看到的感受野范围是15x15大小。</p><p>空洞卷积与普通卷积相比，增加了感受野，但是不会增加需要训练的参数量，因为增加的感受野范围内的其他像素点是选择性跳过的，卷积层能看到，只是不需要参与卷积运算而已（并不是增加padding，填充像素0的操作）。</p><h2 id="模型梯度和优化器梯度">模型梯度和优化器梯度</h2><p>模型梯度和优化器梯度是深度学习中的两个重要概念，它们在训练过程中起着关键作用。</p><h3 id="模型梯度">模型梯度</h3><p><strong>定义：</strong></p><p>在机器学习和深度学习中，模型梯度是指损失函数相对于模型参数（如权重和偏置）的导数。这个导数指示了如果改变参数，损失函数会如何变化。</p><p><strong>作用：</strong></p><p>模型梯度是优化过程中的关键因素，它指出了损失函数下降最快的方向，即函数值增大最快的方向的反方向。在反向传播过程中，通过链式法则计算得到的梯度，用于指导参数的更新，以便减少损失值。</p><p><strong>理解：</strong></p><p>梯度是一个计算图中的张量（Tensor）的属性。当你进行前向传播时，PyTorch会构建一个计算图，图中的节点是张量，边是从输入张量到输出张量的操作（运算关系）。</p><p>当你调用.backward()方法进行梯度反向传播时，PyTorch会自动计算图中所有具有<strong>requires_grad=True</strong>属性的张量的梯度，并将这些梯度存储在各自张量的.grad属性中。</p><p>模型梯度指的是模型参数（通常是神经网络的权重和偏置）在训练过程中通过反向传播计算出的梯度。这个梯度反映了模型参数在当前值下，损失函数变化最快的方向。模型梯度由.backward()方法梯度反向传播</p><p>这意味着每个模型参数张量都有一个与之关联的梯度张量，该梯度张量表示的是损失函数关于该参数的导数，即模型梯度。</p><h3 id="优化器梯度">优化器梯度</h3><p><strong>定义：</strong></p><p>优化器梯度通常指的是优化算法中使用的梯度信息，它不仅仅是当前批次数据的梯度，还可能包括之前批次的梯度信息，以及学习率、动量等超参数。</p><p><strong>作用：</strong></p><p>优化器在反向传播过程中，指引损失函数（目标函数）的各个参数往正确的方向更新合适的大小（使用模型梯度信息来决定参数更新的方向和步长），使得更新后的各个参数让损失函数值不断逼近全局最小。不同的优化器有不同的策略来利用历史梯度信息，例如SGD优化器使用当前批次的梯度直接更新模型参数，而像Adam这样的优化器则结合了一阶动量（指数加权平均梯度）和二阶动量（指数加权平均梯度平方）来调整更新的步长和方向。</p><p><strong>理解：</strong></p><p>优化器（即优化算法）是用来求取模型的最优解的一个独立的对象，它保存了模型参数的引用以及当前的学习率和其他超参数。优化器需要知道前向传播过程中哪些参数是可训练的（即哪些张量具有requires_grad=True属性）。优化器不计算梯度，它只是梯度的更新者，他决定了以什么样的形式更新参数。</p><p>优化器梯度指的是优化器根据模型参数的梯度来更新这些参数的规则和状态。优化器通常有自己的状态，比如学习率、动量等，它会根据模型参数的梯度来调整模型参数的值，以便在下一次迭代中得到更小的损失值。常见的优化器有SGD、SGDM、Adagrad、RMSProp和Adam等。</p><p>当你创建一个优化器实例时，你将模型的参数传递给它，例如：optimizer =torch.optim.SGD(model.parameters(),lr=0.01)。优化器对象通常保存在它自己的内存空间中，它维护了当前的参数状态（比如动量项在torch.optim.SGD的情况下）和更新规则。当你调用optimizer.step()时，优化器就会根据存储的梯度来更新它所保存的参数。</p><h3 id="二者的关系">二者的关系</h3><p>梯度存在于模型的参数（即张量）中，而优化器则以一个单独的实体存在，维护着参数的更新规则和状态。在每次训练迭代中，优化器都会使用参数的.grad属性来更新其值。</p><p>总的来说，模型梯度是损失函数对模型参数的导数，而优化器梯度则是优化器根据模型梯度和其他信息（如历史梯度、学习率等）计算出的用于更新模型参数的信息。两者紧密相连，共同作用于模型训练过程中的参数更新。</p><p>在训练循环中，通常会先清除上一步迭代中计算的梯度（使用.zero_grad()方法），然后进行前向传播和反向传播计算新的梯度，最后由优化器根据这些梯度来更新模型参数。这个过程会在整个训练过程中重复进行，直到模型收敛或达到预定的迭代次数。</p><h2 id="深入理解resnet">深入理解ResNet</h2><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/101332297"class="uri">https://zhuanlan.zhihu.com/p/101332297</a></p><h3 id="引言">引言</h3><p>残差神经网络（ResNet）是由微软研究院的何恺明、张祥雨、任少卿、孙剑等人提出的。ResNet在2015年的ILSVRC(ImageNetLarge Scale Visual Recognition Challenge)中取得了冠军。</p><p>残差神经网络的主要贡献是发现了“退化现象（Degradation）”，并针对退化现象发明了“快捷连接（Shortcutconnection）”，极大的消除了深度过大的神经网络训练困难的问题。神经网络的“深度”首次突破了100层、最大的神经网络甚至超过了1000层。</p><p>在2012年的ILSVRC挑战赛中，AlexNet取得了冠军，并且大幅度领先于第二名，由此引发了对AlexNet广泛研究，并让大家树立了一个观念：网络越深则准确率越高。随着VGGNet、Inceptionv1、Inceptionv2等相继出现，这个观点被不断验证和强化，得到越来越多学者的认可。那么问题来了：它真的正确吗？</p><p>它是正确的，至少在理论上是正确的。</p><h3 id="退化现象">退化现象</h3><p>假设一个层数较少的神经网络已经达到了较高准确率，我们可以在这个神经网络之后，拼接一段恒等变换的网络层，这些恒等变换的网络层对输入数据不做任何转换，直接返回y =x，就能得到一个深度较大的神经网络，并且这个深度较大的神经网络的准确率等于拼接之前的神经网络准确率，准确率没有理由降低（毕竟只做了恒等变换，没有进行任何别的数据层面的操作）。</p><p>层数较多的神经网络，可由较浅的神经网络和恒等变换网络拼接而成，如下图所示：</p><p><img src="/img/stage2/003.png" /></p><p>通过实验，ResNet随着网络层的不断加深，模型的准确率先是提高，直到达到最大值（准确率饱和），然后随着网络深度的继续增加，模型准确率毫无征兆的出现大幅度降低。这个现象与“越深的网络准确率越高”的理念显然是矛盾的。ResNet团队把这一现象称为“Degradation”，即退化。</p><p>ResNet团队把退化现象归因为深层神经网络难以实现“恒等变换(y=x)”。这乍一看让人难以置信：能够模拟任何函数的深层神经网络，竟然无法实现恒等变换这么简单的映射？</p><p>让我们来追溯深度学习的起源。与传统的机器学习相比，深度学习的关键在于：网络层数更深、非线性转换（激活函数）、自动特征提取和特征转换。其中，非线性转换将数据映射到高维空间以便于更好的完成“数据分类”。随着网络深度的不断增大，所引入的激活函数也越来越多，数据被映射到更加离散（维度更高）的空间，此时已难以让数据回到原点（恒等变换）。或者说，神经网络将这些数据映射回原点所需要的计算量，已经远远超过我们所能承受的（硬件受限）。</p><p>退化现象让我们对非线性转换进行反思，非线性转换确实极大的提高了数据分类能力，但是随着网络的深度不断加大，我们在非线性转换方面已经走的太远，已然无法实现线性转换。显然，在神经网络中增加线性转换分支成为很好的选择，于是ResNet团队在ResNet模块中增加了快捷连接分支，在线性转换和非线性转换之间寻求一个平衡。</p><p>至于快捷连接（Shortcutconnection），我就不过多赘述了，之前的文章中也有提及。我在此之前只是不加思考的阅读各种论文、资料（可能看了转头又忘了），从未想过在现在来看很基础的ResNet里面还有这么有趣且严谨的分析过程，给我了很大的启发。所谓科研，或者进行别的学习和研究，甚至于阅读书籍，都需要带着问题和审视的头脑，多问问为什么。十万个为什么不只是少儿读物，应是求知求学的最基本要素。引用毛泽东领袖的话就是：所谓学问，就要既学又问，学和问是不能分开的。书此以自省。</p><h2 id="大模型时代">大模型时代</h2><h3 id="预训练">预训练</h3><p>在很多的论文中都使用了“预训练”这个东西。为什么要预训练呢？下面就来揭开它的面纱。</p><p>很多机器学习模型都需要依托带标签的数据集做训练，此话怎讲？举个例子，让机器去学习和让小孩去学习是类似的。比如小孩辨别猫或狗，无非是父母每次看到一只猫或一条狗，告诉小孩这是猫/狗，小孩不断记忆猫狗的特征，久而久之，小孩见到一只新猫/狗，不用父母告诉TA，也能知道是猫还是狗。</p><p>机器也是一样的，给1000张猫的图片告诉机器是猫，机器不断记忆猫的特征，等给它第1001张不标注是猫的图片的时候，机器能立马认出来是猫，而前面这1000张猫的图片就是训练机器的过程，且通过已知样本不断校准机器的判断能力、不断迭代降低误差(误差= 真实结果与实验结果的差距)。</p><p>但是我们身边存在大量没有标注的数据，例如文本、图片、代码等等，标注这些数据需要花费大量的人力和时间，标注的速度远远不及数据产生的速度，所以带有标签的数据往往只占有总数据集很小的一部分。而如果手头任务的训练集数据量较少的话，那现阶段好用的CNN比如Resnet、Densenet、Inception等网络结构层数很深（几百万上千万甚至上亿的参数量），当训练数据少则很难很好地训练这么复杂的网络，但如果先把好用的这些大模型的大量参数通过大的训练集合比如ImageNet预训练好（大规模图像数据集ImageNet有超过1000万的图像和1000类物体的标注），即直接用ImageNet初始化大模型的大部分参数。接下来再通过手头上少的可怜的数据去Fine-tuning（即微调参数），以更适合解决当前的任务，那事情就顺理成章了。</p><h3 id="transformer">Transformer</h3><p>关于Transformer的理解，可以看这篇文章：<ahref="https://blog.csdn.net/v_JULY_v/article/details/127411638">Transformer通俗笔记</a>。</p><p>作者用了通俗易懂的文字详细解读了Transformer的知识，令人受益匪浅。文章涉及大量的知识点，包括但不限于：向量化（Onehot-&gt;Embedding）、神经网络语言模型NNLM（NeuralNetwork Language Model）、Encoder and Decoder、Attention、Multi-HeadAttention、预训练（双层双向LSTM）+特征融合的模式ELMO（Embedding fromLanguageModels）、预训练+微调（Fine-tuning）的模式迁移学习、GPT与BERT。</p><p>Transformer的时空复杂度可以参考此文：<ahref="https://blog.csdn.net/v_JULY_v/article/details/133619540">FlashAttention</a>。在现代GPU中，计算速度已经远超过显存访问的速度，Transformer中的大部分计算操作的瓶颈是显存访问。所以，减少对HBM（HighBandwidthMemory，高带宽存储器，一款CPU/GPU内存芯片，即“RAM”）的读写次数，有效利用更高速的SRAM来进行计算是非常重要的，而对于性能受限于内存带宽的操作，进行加速的常用方式就是kernel融合。也就是说，要避免反复执行“从HBM中读取输入数据，SRAM执行计算，最后将计算结果写入到HBM中”，将多个操作融合成一个操作，减少读写HBM的次数，是降低计算耗时的重点优化目标。尽量把计算过程都在SRAM中进行，但SRAM内存不够大，因此需要进行分块计算。这是针对Transformer中注意力机制的二次复杂度<spanclass="math inline">\(O(N^2)\)</span>分析，以提高计算效率的一种方法，其中涉及很多硬件相关的技术，我没有看明白，先放在这吧，等日后有机会再攻略。</p><h3 id="mamba">Mamba</h3><p>参考文章：<ahref="https://blog.csdn.net/v_JULY_v/article/details/134923301">一文通透想颠覆Transformer的Mamba：从SSM、HiPPO、S4到Mamba</a>。</p><p>Mamba与RNN颇有相似之处。RNN中的隐藏状态会随着时间的推移而忘记靠前面的信息，且RNN具有非线性的激活函数如tanh，无法写成卷积的形式，没法并行训练。Mamba最早提出是用来解决NLP问题的，它处理长程信息的能力优于RNN，并且计算复杂度低于Transformer。Mamba是一种状态空间模型SSM（StateSpace Model），利用了选择性扫描算法（Selective scanalgorithm）、硬件感知算法（Hardware-aware algorithm）、HiPPO以及FlashAttention等技术。</p><p>Mamba建立在更现代的适用于深度学习的结构化SSM（简称S6）基础上，相当于S4模块的改进，解决了S4参数固定导致的无法对输入进行针对性推理的问题。Transformer的注意力机制虽然有显著效果但效率不算很高，毕竟其需要显式地存储整个上下文（storingthe entirecontext，也就是KV缓存），直接导致训练和推理消耗算力很大。Transformer就像人类每写一个字之前，都把前面的所有字和输入都复习一遍，所以写的慢。RNN的推理和训练效率高，但性能容易受到对上下文压缩程度的限制，容易忘掉更前面的内容。而SSM的问题在于其中的矩阵A、B、C始终是不变的，无法针对不同的输入针对性的推理。Mamba的解决办法是，相比SSM压缩所有历史记录（HiPPO技术，通过将看到的所有输入信息压缩/投影为系数向量，产生隐藏状态来记忆历史），Mamba设计了一个简单的选择机制，通过“参数化SSM的输入”，让模型对信息有选择性处理，以便关注或忽略特定的输入。这样一来，模型能够过滤掉与问题无关的信息，并且可以长期记住与问题相关的信息。</p><p>总的来说，这篇文章通过RNN的不足引入状态空间模型SSM，继而逐步解读S4、S6(Mamba)的相关理论知识，循序渐进，是了解Mamba的绝佳之作！</p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>会议和期刊</title>
    <link href="/2024/01/20/Conference/"/>
    <url>/2024/01/20/Conference/</url>
    
    <content type="html"><![CDATA[<h2 id="工学类论文级别">工学类论文级别</h2><h3 id="会议论文conference">会议论文Conference</h3><p>《中国计算机学会推荐国际学术会议和期刊目录》（简称《目录》）是中国计算机学会（ChinaComputer Federation,CCF）发布的评级。《目录》由CCF学术工委主持并组织CCF相关领域的专家完成评定，分为三个阶段：提议受理阶段、领域责任专家审议和初审推荐阶段、终审核准阶段。CCF推荐目录的确定既考虑了会议和刊物的影响力，也考虑了不同领域间的大致平衡，最终对会议和刊物分十个领域评定了A、B、C三类。</p><p>2018年12月，CCF启动了新一轮《目录》更新工作。本次更新的原则是：在既有基础上进行微调，领域分布、期刊和会议的推荐类别以及分类等级均保持不变。其中，会议论文指“Fullpaper”或“Regularpaper”（正式发表的长文），对于会议上以其他形式发表的论文如Shortpaper、Demo paper、TechnicalBrief、Summary及作为伴随会议的Workshop等不计入《目录》考虑的范围。需要说明的是，一些出版社和学术社团编发的杂志未纳入本《目录》的推荐期刊列表中。</p><p>在计算机、人工智能等相关领域，相关学者（圈内）对顶级会议论文的认可度甚至高于SCI一区期刊论文。</p><blockquote><p>计算机视觉（图像）领域三大顶会：CVPR、ICCV、ECCV。</p></blockquote><p>CCF国际学术会议和期刊目录（2018）一览：</p><h4id="人工智能与模式识别计算机视觉">人工智能与模式识别（计算机视觉）</h4><p>CCF A:</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">AAAI</span><span class="hljs-params">(AAAI Conference on Artificial Intelligence)</span></span><span class="hljs-function"><span class="hljs-title">CVPR</span><span class="hljs-params">(IEEE Conference on Computer Vision and Pattern Recognition)</span></span><span class="hljs-function"><span class="hljs-title">ICCV</span><span class="hljs-params">(International Conference on Computer Vision)</span></span><span class="hljs-function"><span class="hljs-title">ICML</span><span class="hljs-params">(International Conference on Machine Learning)</span></span><span class="hljs-function"><span class="hljs-title">IJCAI</span><span class="hljs-params">(International Joint Conference on Artificial Intelligence)</span></span></code></pre></div><p>CCF B:</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">COLT</span><span class="hljs-params">(Annual Conference on Computational Learning Theory)</span></span><span class="hljs-function"><span class="hljs-title">NIPS</span><span class="hljs-params">(Annual Conference on Neural Information Processing Systems)</span></span><span class="hljs-function"><span class="hljs-title">ACL</span><span class="hljs-params">(Annual Meeting of the Association for Computational Linguistics)</span></span><span class="hljs-function"><span class="hljs-title">ECCV</span><span class="hljs-params">(European Conference on Computer Vision)</span></span><span class="hljs-function"><span class="hljs-title">ICRA</span><span class="hljs-params">(IEEE International Conference on Robotics and Automation)</span></span><span class="hljs-function"><span class="hljs-title">ICAPS</span><span class="hljs-params">(International Conference on Automated Planning and Scheduling)</span></span></code></pre></div><p>CCF C:</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ACCV</span><span class="hljs-params">(Asian Conference on Computer Vision)</span></span><span class="hljs-function"><span class="hljs-title">ICTAI</span><span class="hljs-params">(IEEE International Conference on Tools with Artificial Intelligence)</span></span><span class="hljs-function"><span class="hljs-title">ICANN</span><span class="hljs-params">(International Conference on Artificial Neural Networks)</span></span><span class="hljs-function"><span class="hljs-title">ICPR</span><span class="hljs-params">(International Conference on Pattern Recognition)</span></span><span class="hljs-function"><span class="hljs-title">IJCNN</span><span class="hljs-params">(International Joint Conference on Neural Networks)</span></span><span class="hljs-function"><span class="hljs-title">BMVC</span><span class="hljs-params">(British Machine Vision Conference)</span></span></code></pre></div><h4 id="计算机图形学与多媒体">计算机图形学与多媒体</h4><p>CCF A:</p><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">ACM</span> <span class="hljs-function"><span class="hljs-title">MM</span>(<span class="hljs-variable">ACM</span> <span class="hljs-variable">International</span> <span class="hljs-variable">Conference</span> <span class="hljs-variable">on</span> <span class="hljs-variable">Multimedia</span>)</span><span class="hljs-function"><span class="hljs-title">SIGGRAPH</span>(<span class="hljs-variable">ACM</span> <span class="hljs-variable">SIGGRAPh</span> <span class="hljs-variable">Annual</span> <span class="hljs-variable">Conference</span>)</span><span class="hljs-variable">IEEE</span> <span class="hljs-function"><span class="hljs-title">VIS</span>(<span class="hljs-variable">IEEE</span> <span class="hljs-variable">Visualization</span> <span class="hljs-variable">Conference</span>)</span></code></pre></div><p>CCF B:</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ICMR</span><span class="hljs-params">(ACM SIGMM International Conference on Multimedia Retrieval)</span></span><span class="hljs-function"><span class="hljs-title">ICME</span><span class="hljs-params">(IEEE International Conference on Multimedia &amp; Expo)</span></span></code></pre></div><p>CCF C:</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ISMAR</span><span class="hljs-params">(International Symposium on Mixed and Augmented Reality)</span></span><span class="hljs-function"><span class="hljs-title">ICIP</span><span class="hljs-params">(International Conference on Image Processing)</span></span></code></pre></div><p>ICCV/CVPR/ECCV并称为三大顶会，ICCV和CVPR是CCF-A类会议，ECCV是CCF-B类会议，但是ECCV的难度并不比ICCV和CVPR低，注重视觉技术的应用与新方法的提出。另外还有一些偏理论的顶会：NIPS/ICML/ICLR，也具有很大的业界影响力。稍次一些：AAAI/IJCAI。再次一些的：BMVC和ACCV，中等难度。还有一些相当凑合的，如ICIP、ICPR、IJCNN，算是业界还可以的。注：ICLR(InternationalConference on LearningRepresentations)不在CCF推荐国际学术会议和期刊目录之中。</p><h3 id="期刊论文journal">期刊论文Journal</h3><h4 id="sci-科学引文索引">SCI 科学引文索引</h4><p>大名鼎鼎的SCI(Science CitationIndex)，是由美国科学信息研究所创建的引文数据库，收录自然科学各学科的核心期刊3700多种。所谓引文数据库，可以类比为百度、谷歌等搜索引擎。SCI是覆盖生命科学、临床医学、物理化学、农业、生物、兽医学、工程技术等方面的综合性检索刊物，尤其能反映自然科学研究的学术水平。自然科学领域内至少有几万本期刊，质量参差不齐，SCI从中选取了三千多种它认可的期刊，并根据期刊各自的影响因子进行排名。</p><blockquote><p>影响因子IF（Impact Factor）计算公式：IF =(该期刊前两年发表的论文被引用的次数) /(该期刊前两年发表的论文（包括Article和Review）的总数)。</p></blockquote><p>根据IF的大小，有两套排名分区方式：一是JCR分区，二是中科院（SCI）分区。</p><p>JCR分区：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Q1</span>区：IF排名前<span class="hljs-number">25</span>%<span class="hljs-attribute">Q2</span>区：IF排名位于<span class="hljs-number">26</span>%-<span class="hljs-number">50</span>%<span class="hljs-attribute">Q3</span>区：TF排名位于<span class="hljs-number">51</span>%-<span class="hljs-number">75</span>%<span class="hljs-attribute">Q4</span>区：IF排名在<span class="hljs-number">76</span>%之后</code></pre></div><p>中科院分区：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">SCI</span>-<span class="hljs-number">1</span>区：IF排名前<span class="hljs-number">5</span>%）<span class="hljs-attribute">SCI</span>-<span class="hljs-number">2</span>区：IF位于<span class="hljs-number">6</span>%-<span class="hljs-number">20</span>%<span class="hljs-attribute">SCI</span>-<span class="hljs-number">3</span>区：IF位于<span class="hljs-number">21</span>%-<span class="hljs-number">50</span>%<span class="hljs-attribute">SCI</span>-<span class="hljs-number">4</span>区：IF排名<span class="hljs-number">51</span>%往后</code></pre></div><p>另外，有两个最负盛名的顶级科技期刊（正刊）：Science、Nature，前者是美国的，是非营利期刊，比较看重创新性，可读性较强；后者是英国的，是商业期刊，有很多子刊。</p><h4 id="ei-工程索引">EI 工程索引</h4><p>EI(EngineeringIndex)，学科覆盖面比SCI更加广泛，是工程领域的索引数据库。一般情况下，在SCI中收录的文献也会在EI中收录。EI不收录纯基础理论方面的论文。</p><p>ISTP(Index to Scientific &amp; TechnicalProceedings)，科技会议录索引，不同于SCI和EI，主要收录各种会议文献，包括一般性会议、座谈会、研究会、讨论会、发表会等，其中工程技术与应用科学类文献约占35%，其他涉及学科与SCI基本相同。</p><h4 id="ieee-美国电气和电子工程师协会">IEEE美国电气和电子工程师协会</h4><p>IEEE(Institute of Electrical and ElectronicsEngineers)和SCI是两个不同的学术组织或检索工具，它们之间存在一定的关系。</p><p>IEEE是一个学术组织，致力于电气、电子、计算机工程和与科学有关的领域的开发和研究，是全球最大的非营利性国际性专业技术学会之一。IEEE旗下有许多出版物，其中包括期刊、会议录等文献，这些文献的资源会被收录在IEEE的数字图书馆中。IEEE会收录很多电子电气行业相关期刊并印刷出版，同时IEEE也会举办很多会议，因此会有一定量的会议论文被收录。IEEE定义的标准在工业界有极大影响。</p><p>IEEE会员常见的有四级：Student member，Member，Seniormember，Fellow。Studentmember是学生会员，相关专业的本科生或研究生交钱可以加入。Member是会员，硕士或者博士毕业后可以将学生会员（或者准会员）升级为会员。Seniormember是高级会员，一般申请者是IEEE相关领域内的工程师、科学家、教师、技术主管或发明家，要具有一定的学术成就或突出业绩。IEEE所能达到的最高会员级别是Fellow（会士），在相关领域内有卓越贡献或杰出成绩经过评审与引荐方可授予，也是一种荣誉称号。</p><p>SCI是一个学术检索工具，主要用于科学、技术、医学和工程领域的学术论文检索和评价。SCI收录了全球范围内的优秀学术论文，其中包括许多被IEEE出版的文献。因此，SCI和IEEE可以说存在一定的包含与被包含的关系。另外，SCI极少收录会议论文。</p><p>虽然SCI和IEEE是两个不同的学术组织和检索工具，但它们在学术界都有着广泛的影响力。如果作者需要发表电子相关专业的国际学术论文，可以考虑发表在IEEE旗下的期刊上，这样也有可能被SCI收录。</p><blockquote><p>图像领域的期刊</p></blockquote><p>图像领域的期刊，最顶级的是TPAMI(IEEE Transactions on Pattern Analysisand Machine Intelligence)和IJCV(International Journal of ComputerVision)，是图像领域的“双牛”并立。还有一个JMLR(Journal of MachineLearningResearch)，业界影响力也很大，但在JCR分区被分为三区，国内投这个期刊的学者较少。次一级的有：TIP(IEEETransactions on Image Processing)、PR(PatternRecognition)，业内也非常认可，TIP的发表难度可能略大于PR。另外，一些不是纯图像领域的期刊也会接收图像相关的论文，如T-cyber、SMCA(TransactionsonSystem)，由于这些期刊本身影响力比较大，都是JCR一区，因此认可度也都不错，有一定的发表难度。</p><p>戳这里：<ahref="https://www.zhihu.com/question/37687006/answer/1866953904">计算机视觉顶尖期刊与会议有哪些？</a></p><p>还有这里：<ahref="https://www.zhihu.com/question/284242946/answer/1338595630">图像领域有哪些高级期刊和会议？</a></p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔系列6：计算机基础</title>
    <link href="/2023/12/21/Computer/"/>
    <url>/2023/12/21/Computer/</url>
    
    <content type="html"><![CDATA[<p><strong>宝藏学习网站：</strong><ahref="https://xiaolincoding.com">小林coding之图解计算机网络和操作系统</a></p><h2 id="磁盘">磁盘</h2><h3 id="分区知识1簇">分区知识1：簇</h3><p>在磁盘（如U盘）格式化的时候，有一项是“分配单元大小”，这就是分区中的“簇”。“簇”是分区的最小存储单元。一个数据在存入硬盘前，会事先按照簇的大小将其分成N等份，然后分别存入分区中不同的簇内。例如名叫“毕业论文.pdf”的文件，大小是1600KB，将其存入磁盘时有以下情况：</p><p>（1）如果分配单元大小设置为512KB，那么意味着该磁盘的“簇”大小为512KB。在数据存入前，系统会先将其分为512KB、512KB、512KB、64KB四份，然后分别存入硬盘对应的四个簇中，这样一来存在一个问题，最后的64KB不够填满一个512KB的簇，那么剩下的448KB空间也就被浪费了。其实，即使最后一个簇中仅使用了1个字节（Byte），这个簇剩下的全部空间也会被弃之不用。</p><p>（2）如果将分配单元大小设置为64KB，那么数据存入前，系统会按64KB将这个数据分为25份，然后存入对应的25个簇中。</p><p>将簇设置为512KB时，最后会有一部分空间被浪费，但是它存取数据时只需分成4份就完成了，因此理论上讲效率更高。而将其分成64KB时，虽然对空间的利用率更高、不容易造成浪费，但存取效率也会相对降低。故簇越小，效率越低，但浪费的空间也小；簇越大，效率越高，浪费的空间也多。在格式化时，如果不调整这个参数，系统默认将“分配单元大小”设置为4096字节，即4KB，由于在x86时代，每个内存页的大小被定义为4KB，因此认为将硬盘的块大小也分成4KB可以与内存页吻合而提升硬盘的运行效率。</p><p>另外，目前市面上主流的硬盘格式有三种：APFS、NTFS、exFAT，特点如下。</p><div class="code-wrapper"><pre><code class="hljs stata">APFS：优点：可靠，安全。对配合苹果电脑使用友好。缺点：不兼容Windows系统。NTFS：优点：采用日志式，稳定安全，Windows系统使用友好，是主流格式。缺点：<span class="hljs-keyword">Mac</span>只支持读，写入要第三方驱动。exFAT：优点：对Windows和<span class="hljs-keyword">MAC</span>格式都兼容，对闪存SSD硬盘优化更好。缺点：机械硬盘用这格式数据容易丢。</code></pre></div><h3 id="易混淆知识1磁盘与硬盘">易混淆知识1：磁盘与硬盘</h3><p>磁盘是计算机主要的存储介质，可以存储大量的二进制数据。早期的计算机使用的磁盘是软磁盘（FloppyDisk，简称软盘），如今常用的是硬磁盘（Harddisk，即硬盘）。磁盘是一个广泛概念，包括多种存储介质，如磁盘、光盘（用激光打上去的数据）等，其中磁盘以磁性原理存储数据，包括盘片、磁头、盘片主轴、控制电机、磁头控制器、数据转换器等，存储容量由扇区数、磁道数、磁头数决定。</p><p>硬盘，即硬盘驱动器，英文名称是Hard DiskDrive，简称是HDD。硬盘可分为固态硬盘（Solid StateDrive，SSD）、机械硬盘（Hard Disk Drive，HDD）、混合硬盘（Hybrid HardDrive，SSHD orHHD），而硬盘就是磁盘的一种。硬盘是一种常见的外部存储设备，它将数据保存在一个磁盘上，使用一个磁头扫描磁盘上的磁道，读取或者写入数据，主要采用磁盘作为存储媒介（机械硬盘）。</p><h3 id="易混淆知识2内存外存与硬盘">易混淆知识2：内存外存与硬盘</h3><p>存储器分类：存储芯片种类很多，依据不同的特性有多种分类方法。</p><p>1.按存取方式分类</p><p>(a)随机存取存储器(Random Access Memory, RAM)这种存储器每个单元读写时间一样，且与各单元所在位置无关。我们平常说的手机内存，8G或者12G的，指的就是这种。（注：这里的读写时间一样主要强调地址译码时间相同。现在的DRAM芯片采用行缓冲，因而可能因为位置不同而使访问时间有所差别）</p><p>(b)顺序存取存储器(Sequential Access Memory, SAM)数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置有关。例如：磁带。</p><p>(c)直接存取存储器(Direct Access Memory, DAM)直接定位到读写数据块，在读写数据块时按顺序进行。例如：磁盘。</p><p>(d)相联存储器(Associate Memory, AM)按内容检索到存储位置再进行读写。例如：快表，一种高速缓冲存储器(Cache)。</p><p>2.按存储介质分类</p><p>(a)半导体存储器：双极型、静态SMOS型、动态DMOS型。</p><p>(b)磁表面存储器：磁盘（Disk）、磁带（Tape）。</p><p>(c)光存储器：CD、CD-ROM、DVD。</p><p>3.按信息的可更改性分类</p><p>(a)读写存储器(Read/Write Memory)：可读可写。</p><p>(b)只读存储器(Read Only Memory, ROM)：只能读不能写。</p><p>4.按断电后信息的可保存性分类</p><p>(a)非易失性存储器(NonvolatileMemory)：信息可一直保留，不需电源维持。如：ROM、磁表面存储器、光存储器等。</p><p>(b)易失性存储器(VolatileMemory)：电源关闭时信息自动丢失，如：RAM、Cache等。</p><p>5.按功能/容量/速度/所在位置分类</p><p>(a)寄存器(Register)这种存储器封装在CPU内，用于存放当前正在执行的指令和使用的数据。用触发器实现，速度极快，容量很小（几个字节到几十字节）。</p><p>(b)高速缓存(Cache)位于CPU内部或附近，用来存放当前要执行的局部程序段和数据。用SRAM实现，速度可与CPU匹配，容量小（几十KB到几MB）。</p><p>(c)内存储器MM(又称主存储器Main(Primary) Memory)位于CPU之外，用来存放已被启动的程序及所用的数据。用DRAM实现，速度较快，容量较大（目前来说通常是2GB到16GB）。</p><p>(d)外存储器AM(又称辅助存储器Auxiliary/Secondary Storage)位于主机之外，用来存放暂不运行的程序、数据或存档文件。用磁表面或光存储器实现，容量大而速度慢。</p><p>目前我们讨论较多的还是按照第4种分类方式，因为这样分只有2类，描述方便，当然第3种方式也是分为两类，不过目前存储器都支持读写，只读的很少，所以一般说第4类种分法较多。这里再补充个闪存（FlashMemory）：内存RAM使用寄生电容充放电来表示0和1，充了电的电容需要不断的被充电维持状态，否则会很快漏电，所以需要持续供电，但是速度块。Flash闪存使用MOS管中间的一个绝缘体包括层来储备电子，充电之后可以长期保存，外部使用senseamp比较放大器来感受每个MOS管内的状态，从而输出0和1状态，断电后数据依然保存，比RAM慢一个数量级，但是比磁盘快多个数量级。闪存相当于一种电子式可擦除程序化只读存储器（EEPROM）的变种，与EEPROM不同的是，EEPROM能在字节水平上进行删除和重写而不是整个芯片擦写，而闪存的大部分芯片需要块擦除。</p><h3 id="手机电脑的文件存储">手机、电脑的文件存储</h3><p>前面说到，内存是保存进程的相关数据。一旦关机（断电），内存里面的数据就随之清空。对手机来说，像照片、文档什么的，并不是保存在内存中，而是存在闪存里面，也就是手机中的128G、256G等。内存越大，可以同时运行的软件就越多，闪存越大，可以存储的文件就越多。目前的手机闪存大多用的是NandFlash（eMMC和UFS是两种通信协议/标准），也有少数用Nor Flash的。</p><p>对电脑来说，电脑除了内存，也要有存文件的地方，那么是不是和手机一样也是闪存呢？有人马上会说：不是闪存，是固态硬盘或者机械硬盘。这种说法不算错，但不够准确。接下来先从协议和接口开始简述，然后再叙述硬盘的种类。</p><p>目前电脑大多使用固态硬盘SSD，SSD数据通信普遍是PCle标准。注意，M.2不是通信协议，也不是数据通道，而是接口标准。举个简单的例子：USB接口，常见的有Type-A和Type-C，拿type-c来说，它可以支持多种通信协议，比如雷达协议、dp协议等。M.2接口类型既可以走PCle通道，也可以走SATA通道，所以有双M.2的说法。值得注意是的是，PCle通道有专门的PCle接口类型。当然，SATA通道也有专门的接口类型：SATA接口。</p><p>也就是说，硬盘与主板连接的接口，主要有SATA、PCIe、M.2三种形式，但从主板插槽到主板芯片之间，传输数据的总线（就是上面提到的“数据通道”）有SATA和PCIe两种。基于此，M.2接口有两种规范，一种是socket2，一种是socket3，前者支持SATA3和PCIex2的总线接口，后者支持PCIe x4的总线接口。</p><p>最后还有个NVMe协议。电脑bios里面硬盘的一个设置项，可选择为AHCI或者ATAPI。一块SATA接口的硬盘，可以选择使用AHCI传输协议或者ATAPI传输协议。不过ATAPI是一个并行ATA传输协议，主要用在旧式的IDE接口上，现在大多数情况下已经不再被使用。对M.2接口来说，如果走SATA通道，只能使用AHCI协议，而不能用NVMe协议；如果走PCle通道，既可采用AHCI协议，也可以采用NVMe协议。NVMe是一个专门为固态硬盘设计的协议，它比AHCI更高效，更适合高速的固态硬盘。因此，对于高性能的M.2接口固态硬盘，NVMe协议通常是首选。</p><h3 id="总线协议接口">总线、协议、接口</h3><p>总线是一组传输通道，是各种逻辑器件构成的传输数据的通道，一般由数据线、地址线、控制线等组成。接口是一种连接标准，常被称为物理接口。协议就是传输数据的规则。</p><p>协议就是总体框架，定义接口设备、器件及信号、总线及通道之间需要满足的关系，即要实现信号的传输，所有这些组成成员必须通力合作，各自满足协议要求的各种必要条件。</p><h4 id="总线">总线</h4><p>一台电脑由多个电子元器件组成，如CPU、内存、硬盘等，各元器件之间往往需要相互传递数据。数据传输的公用通道，就是总线。</p><p>通道就好似公路，公路有乡间小道、柏油马路和高速公路之分，总线自然也有其区分标准。</p><p>区分总线承载能力的一个概念，叫带宽，也就是单位时间内能够传递的数据量。带宽越大，单位时间内能够传递的数据量越多。</p><p>我们常见的总线（通道）有SATA总线和PCI-E总线两种。</p><p>SATA总线常见的就是SATA 3.0，理论最高速度只有6Gbps（6G bits persecond），磁盘以 1G = 1000M 进行换算，所以 6Gb = 6000/8MB =750MB，但实际上是除以10的：6Gb = 6000/10MB =600MB，所以此类接口的固态硬盘理论传输速度为600MB/s，再考虑10%左右的带宽折扣，实际速度约是550MB/s。PCIe总线常见的有PCIe3.0和PCIe 4.0，通道数量不同，速度也会不同。以PCIe3.0×4总线为例，它的带宽高达32Gbps，此类接口的固态硬盘实际传输速度可以轻松突破1000MB/s，顶级产品甚至可以到达4000MB/s以上。</p><p>若继续用公路来类比，那SATA 3.0是乡间小路的话，PCIe3.0就是柏油马路了。综上，同为固态硬盘，走的是哪种总线，至关重要。</p><h4 id="协议">协议</h4><p>协议，全称是网络协议，是数据传递双方共同遵循的一种规定、准则。</p><p>举个例子，A向B传输视频数据，但是B不接收视频，只接收图片，这就会导致视频数据无法传输。这个时候，只有双方都使用图片格式，才可以正常传输数据，这就是协议。</p><p>目前，硬盘常用的协议，主要有AHCI和NVMe两种。NVMe与AHCI都是逻辑设备接口的一种标准，不过NVMe相比AHCI在延时性、功耗、IPOS等一些方面性能要强。不过，并非是说NVMe协议的固态硬盘一定比AHCI协议的速度快，具体的速度还要看走的是哪种总线，以及硬盘本身的性能。</p><h4 id="接口">接口</h4><p>最常见的硬盘接口，主要是SATA接口以及M.2接口。</p><p>SATA接口，主流硬盘接口之一，是SerialATA的缩写，即串行ATA。它使用SATA总线、AHCI协议，主要功能是用作主板和大量存储设备（如硬盘及光盘驱动器）之间的数据传输。</p><p>M.2接口，又称为NGFF，是新一代接口标准，拥有比SATA接口更小的尺寸，同时提供更高的传输性能。按金手指的类型，M.2接口又细分为M-Key、B-Key、B&amp;M-Key。</p><p>M.2接口支持SATA总线和AHCI协议、PCIe总线和AHCI协议以及PCIe总线和NVMe协议。当使用SATA总线和AHCI协议时，其和普通的SATA硬盘没有什么区别，速率同样会被限制在550MB/s左右。当使用PCIe总线和AHCI协议以及PCIe总线和NVMe协议时，速率上限由PCIe的版本和长度决定。</p><p>PCIe既可以作为总线，承担传输通道的存在，也可以直接以接口的形式存在。如果在PCIe接口上安装固态硬盘，使用的就是PCIe总线和NVMe协议。</p><p>还有一种接口：SAS，支持SAS总线和SCSI协议、SATA总线和AHCI协议。这种接口（以及SAS总线）常见于服务器中，可以理解为强化版的SATA接口。其在SATA接口的基础上增加了更多的功能，并且支持更高速率的SATA总线。SAS接口可以一分多，以满足服务器柜中多硬盘的要求。</p><p>由于SAS接口是在SATA接口上改动而来的，SAS接口可以向下兼容SATA硬盘，使用AHCI协议。但SAS硬盘只能接在支持SAS总线上，使用SCSI协议。</p><p>理论上，一款固态硬盘选择M.2接口，走PCIe总线，用NVMe协议，性能发挥是最好的。</p><h4 id="reference">Reference</h4><p>这篇文章总结的不错：<ahref="https://blog.csdn.net/zero_wind/article/details/125550652">固态硬盘的总线、接口、协议之间的关系和区别</a></p><p>这篇文章也可以，包含很多图片：<ahref="https://zhuanlan.zhihu.com/p/378437760">一文看懂主板的协议、总线和接口</a></p><h3 id="ssd和hdd">SSD和HDD</h3><p>固态硬盘SSD是用固态电子存储芯片阵列而制成的硬盘，由闪存（FLASH）作为基础存储介质的存储设备。手机上的闪存和电脑的固态，存储介质都是NandFlash，也就是说它们的存储芯片是一样的，只是控制芯片不同。FLASH的速度比机械硬盘速度快很多，所以被广泛应用到存储设备。不仅是手机的闪存和电脑的固态硬盘，目前的U盘、SD卡等都是FLASH。还有一种SSD存储介质用的是DRAM。</p><p>SSD的优缺点：优点：读写速度快，防震抗摔能力强，功耗和噪音低，工作温度范围大。缺点：容量小，寿命短，价格高。</p><figure><imgsrc="https://picx.zhimg.com/v2-d2f31ec719f785b0e30e6e413ffcdb54_r.jpg?source=1def8aca"alt="固态硬盘" /><figcaption aria-hidden="true">固态硬盘</figcaption></figure><p>机械硬盘HDD所有盘片装在一个旋转轴上，每张盘片都是平行的，所有磁头连在一个磁头控制器上，由控制器负责各个磁头的运动。</p><p><imgsrc="https://picx.zhimg.com/v2-113779599ab48ab31795c3f75856e6ae_r.jpg?source=1def8aca" /><imgsrc="https://picx.zhimg.com/v2-4fd207fea287e89ab87d590697eb731d_r.jpg?source=1def8aca"alt="机械硬盘" /></p><h4 id="分区知识2磁盘接口与分区">分区知识2：磁盘接口与分区</h4><p>我们都知道一块磁盘是可以被分成多个分区（partition）的，以Windows系统来看，你会有一块磁盘并且将它分区成了C、D、E盘，这三个盘就是3个分区。</p><p>个人计算机常见的磁盘接口有两种，分别是IDE接口和SATA接口，目前主流的已经是SATA接口了。我们称可连接到IDE接口的设备为IDE设备，不管是磁盘还是光盘。</p><p>在Linux系统中，以IDE接口来说，主机会提供两个IDE接口，每个接口连接两个设备，所以最多可以连接到4个设备。每个接口的IDE设备又有Master和Slave之分。</p><p>再以SATA接口来说，由于SATA/USB/SCSIA等磁盘接口都是使用SCSI模块来驱动的，因此这些接口的磁盘设备文件名都是使用SCSI模块来驱动的，因此这些接口的磁盘设备文件名都是/dev/sd[a-p]的格式。但是与IDE接口不同的是，SATA/USB接口的磁盘设备文件名根本就没有一定的顺序，顺序是由Linux内核检测到磁盘的顺序决定的。</p><p>想了解硬盘分区，首先需要清楚硬盘的存储机制。硬盘的两个单位是扇区（Sector）和柱面（Cylinder），其中每个扇区大小为512Bytes。每个扇区的重要程度是不一样的，整块磁盘的第一个扇区特别重要，因为它记录了整块磁盘的重要信息。磁盘的第一个扇区主要记录了两个重要的信息，分别是：主引导分区（MasterBoot Record,MBR）：可以安装引导加载程序的地方，有446bytes；分区表（PartitionTable）：记录整块硬盘分区的状态，有64bytes。</p><p>硬盘默认的分区表仅能写入四组分区信息，这四组分区信息我们称为主（Primary）分区或扩展（Extended）分区。当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行数据的处理。虽然分区表只有记录四组数据的空间，但不代表一块硬盘最多只能分出四个分区。扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能被拿来格式化。我们可以通过扩展分区所指向的那个区块继续作分区的记录。由扩展分区分配继续切出来的分区，就被称为逻辑分区（Logicalpartition）。</p><p>逻辑分区是在扩展分区上面创建的，相当于一块存储介质，和操作系统还有别的逻辑分区、主分区没有什么关系，是独立的。逻辑分区可以看作是“裸”的分区，也就是一块“裸”的硬盘，没有操作系统在里面。逻辑分区相当于一个独立的个体，有自己的文件系统，有自己的操作系统。扩展分区则不是真正意义上的分区，它仅仅是一个指向下一个分区的指针，这种指针结构将形成一个单向链表。这样在主引导扇区中除了主分区外，仅需要存储一个被称为扩展分区的分区数据，通过这个扩展分区的数据可以找到下一个分区（逻辑磁盘）的起始位置，以此位置类推可以找到所有的分区。无论系统中建立多少个逻辑磁盘，在主引导扇区中通过一个扩展分区的参数就可以逐个找到每一个逻辑磁盘。</p><p>综上，主分区与扩展分区最多可以有四个（硬盘的限制），扩展分区最多只能有一个（操作系统的限制）且无法格式化。逻辑分区是由扩展分区继续切割出来的分区，能够被格式化后作为数据存取的分区为主分区与逻辑分区。逻辑分区的数量随着操作系统不同而不同。</p><p><ahref="https://zhuanlan.zhihu.com/p/27926239">硬盘基础知识科普</a></p><p><a href="https://www.cnblogs.com/hust-ghtao/"title="这里作者记载了很多互联网知识！">互联网相关知识学习-华科小涛的博客</a></p><h2 id="存储容量计量单位">存储容量计量单位</h2><h3 id="bit与byte">bit与Byte</h3><p>Bit（比特，用 b表示）是数据的最小单位，表示一个二进制位，只有两个值0和1，它可以用来代表一个晶体管的通断，或者某根导线上电压的有无。<br/>Byte（字节，用 B 表示）是数据的基本单位，一个字节等于8位比特，即：1byte= 8bit。即1个字节包括了 <span class="math inline">\(2^8 = 256\)</span>种组合。</p><h3 id="kibkb">KiB(KB)</h3><p>KB：全称是：KiloByte，意思是千字节。<br/>它是计算机数据存贮器存储单位字节的倍数形式，通常用于描述磁盘容量、文件大小、内存地址及其大小。<br/>1KB = 1024B。</p><p>根据IEC命名标准（国际电工委员会：International ElectrotechnicalCommission，简称IEC，是世界上最早的非政府性国际电工标准化机构之一，负责制定电气、电子和相关技术领域的国际标准），用于二进制存储单位的标准命名是：KiB。也就是说，像KiB、MiB、GiB这种写法，才是标准的计算机领域的术语，中间的i取自：binary，表示二进制幂的计数，即：</p><p><span class="math display">\[2^{10} = 1024 = 1K, ~~~ 1M = 1024K, ~~~1G = 1024M\]</span></p><p>这与数学领域或日常生活中的 1K = 1000、1M = 1000K、1G = 1000M是不同的。但在Windows系统中，KB通常也被视为1024B，以至于到现在大家很容易将KiB和KB混淆。硬盘商家标定的1GB 比计算机中的 1GB略小，就是硬盘销售时和计算机读取时用的换算单位不同所导致的。硬盘都是采用1000来进位的，与日常生活相符，因此当硬盘被计算机读取时，就跟计算机中的1024进位“格格不入”，那么我们自然就感觉硬盘空间“缺斤少两”。</p><p>换句话说，我们只需要明白，在计算机领域，KB、MB、GB、TB、PB、EB等都是互相以1024为进位的就行了，它跟KiB、MiB意思是一样的。本文也是总结计算机领域相关的知识，因此文中所述的MB、GB等单位其实是MiB、GiB。</p><h3 id="mbgb和tb">MB、GB和TB</h3><p>MB：全称是：MegaByte，意思是兆字节。<br/>它也是计算机存储容量的单位，通常用于描述数据或程序的存储需求。<br/>1MB等于1024KB，也等于<spanclass="math inline">\(1024^2\)</span>字节。</p><p>GB：全称是：GigaByte，中文称为吉字节，也被称为千兆字节。<br/>计算机存储容量单位，常简写为G。1GB等于1024MB，也等于<spanclass="math inline">\(1024^3\)</span>字节。</p><p>TB：全称是：TeraByte，意思是太字节。<br/>计算机存储容量单位，通常用于描述大型存储设备的容量。1TB等于1024GB。</p><p>此外，还有：PB(Petabyte)、EB(Exabyte)、ZB(Zettabyte)、YB(Yottabyte)等。1PB等于1024TB，1EB等于1024PB，以此类推。1TB相当于一家大型医院中所有的X光图片的资讯量；5EB相当于至今全世界所有人类讲过的话语；1ZB相当于全世界海滩上沙子数量的总和；1YB的数据量则如同7000位人类体内的微细胞数目的总和。</p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献整理 · 海纳百川篇</title>
    <link href="/2023/12/20/papers4/"/>
    <url>/2023/12/20/papers4/</url>
    
    <content type="html"><![CDATA[<h2 id="l-puif">L-PUIF</h2><p>A Lightweight Pixel-Level Unified Image Fusion Network,2023(IEEE)</p><h3 id="motivation">Motivation</h3><p>传统的图像融合虽然computationalcost很低，但是随着GPU的发展，高计算能力平台使其这一优势变得越来越平常。而且传统的像素级融合在提取特征和计算融合策略时高度依赖expertknowledge，且需要人工设计融合规则，这会限制模型的泛化能力，同时这些方法普遍需要根据融合的类型调整参数，这一过程比较复杂。因此深度学习技术成为unifiedimage fusion的主流。</p><blockquote><p>The feature extraction methods of these traditional methods are toosingle and difficult to adapt to different types of fusion tasks, whichgreatly limits the fusion performance.</p></blockquote><p>但是一些deep learning networks的网络性能仍然需要priorknowledge来支撑，比如需要groundtruth去指导融合的迭代过程，或者是使用fixed-parameter feature extractionnetwork分析源图像的信息。此外，还有一些深度学习网络使用大量的参数来达到更高的融合质量。现有的一些方法也没有过多关注不同类型源图像之间的dataspecificity，这将限制融合网络的性能。</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">Hence, how <span class="hljs-built_in">to</span> <span class="hljs-built_in">combine</span> <span class="hljs-keyword">the</span> specificity <span class="hljs-keyword">of</span> source images is <span class="hljs-keyword">the</span> key <span class="hljs-built_in">to</span> image fusion.</code></pre></div><p>The existing methods are only aimed at the fusion effect or therobustness of the model, ignoring the requirement of real-time needs. Infact, the FPS of the existing network is far lower than the standard of30 when facing high-resolution datasets.</p><p>为了克服上述问题或缺陷，作者设计了一个轻量化的像素级统一（联合）图像融合网络：L-PUIF，适用于三种融合场景：多模态、多聚焦和多曝光。</p><h3 id="introduction">Introduction</h3><p>作者发现广泛使用高维多尺度特征提取模式不适合构建轻型网络，因为高维、多尺度特征缺少局部细节信息，会增加计算成本和图像重建的复杂性。</p><p>基于此，作者提出一个basenetwork，由4个不同的卷积层组成，用于特征提取与重建；一个high-dimensionalrefinement(精炼、细化) process，增强特征提取的信息挖掘（informationmining）能力。</p><p>提取的高维特征通过应用于损失函数的information preservationmeasurement生成权重，引导网络对structure, intensity, and other info fromthe source images进行合理利用。</p><p>这样，网络就可以实现无监督图像融合过程，减少模型参数，实现统一、准确、高效率的图像融合。</p><p>作者的contributions总结如下：</p><blockquote><p>A lightweight network named L-PUIF is proposed, which avoids theredundant structural and can be adapted to different pixel-level imagefusions with one training model.</p></blockquote><blockquote><p>A new measurement method of information preservation degree for imagefusion has been proposed, which can adaptively enhance the gradient andintensity info extraction ability of the network.</p></blockquote><h3 id="method">Method</h3><p>作者提出的L-PUIF方法可以消除先验信息和人工操作的限制，轻量化网络模型，具有良好的实时性、较高的融合效率和较好的可视化融合结果。</p><p>特征提取在图像融合中是相当重要的环节。作者将特征提取分为两类主要的模式：一种是高维度特征提取，如FusionGAN，另一种是多尺度特征提取，如RFN-Nest。实验表明，small-scalefeatures和high-dimensionalfeatures包含的信息几乎都是全局信息和语义信息，而局部细节和强度信息丢失。这两种模式的网络结构很大，不利于图像重建的快速实现。然而，texture,intensity, and otherinfo可以从尺度不变特性和低维特征中获得，对图像融合和重建起重要作用。即：这两种patterns在构建轻量级融合网络中不是必需的。</p><h4 id="base-network">1.Base Network</h4><p>该网络主要由特征提取和特征重构模块两部分组成。首先，我们使用具有相同权重的特征提取模块来处理两个不同的输入。这样，网络的特征提取参数可以通过两个不同的源进行优化，可以减少网络模型的大小。特征提取模块有两层组合，每一层由卷积层和激活函数组成。</p><p>我们没有使用手动融合策略，例如加法或L1范数，而是选择拼接不同源图像生成的特征，并将它们放入特征重建模块中。特征重构模块的结构与特征提取模块相同。具体来说，它完全由3*3卷积构建，特征重建模块中最后一层的激活函数是tanh函数，而其余激活函数是LeakyReLU。最后，根据融合图像和源图像计算损失函数。</p><p><img src="/img/stage2/stage3/01.png" /></p><h4 id="high-dimensional-information-refinement">2.High-DimensionalInformation Refinement</h4><p>基础网络仅将来自不同来源的图像融合到一张图像中，但由于网络体积的限制，网络的特征提取能力并不突出。因此，需要通过其他方法提高基础网络的特征提取能力。我们针对基础网络提出了一种高维信息处理方法，增强了对所需信息的利用，优化了整个网络融合过程。</p><p>具体思想是：高维特征由基础网络的特征提取模块生成，该模块包含大量源信息。我们通过high-dimensionalinformationrefinement过程重新提取高维特征，并在随后的步骤中将提取的信息注入到损失函数中。这样，特征提取模块可以通过特征重构过程和高维特征提取过程进行优化。这种优化方法还增强了网络中前后特征的交互性。</p><p>我们使用1*1的卷积和tanh激活函数来进行高维特征提取，输入是基础网络的特征提取结果。将生成的张量提供给informationpreservation measurement过程进行进一步处理，网络架构如下图所示。</p><p><img src="/img/stage2/stage3/02.png" /></p><h4 id="information-preservation-measurement">3.Information PreservationMeasurement</h4><p>在基础网络中，来自不同源图像的信息对融合结果的影响是相等的，无法处理数据特异性和其他属性。因此，有必要为损失函数获得合理的权重来定义不同源图像的影响。U2Fusion为这个问题提供了初步解决方案。U2Fusion使用具有确定参数的VGG-16网络提取源图像不同维度和尺度的特征，然后计算这些特征的梯度，并为损失函数生成两个不同的权重。这样就考虑了不同的源图像对融合图像的影响。</p><p>然而，这些信息测量方法不是逐个像素地实现的，而且需要一些先验信息来提高测量精度。因此，我们提出了一种更好的方法来评估融合信息。首先，我们认为这个权重可以从像素级进行确定，其可以灵活地反映图像中不同区域的差异。其次，不需要预定义权重，而是通过从源图像训练网络来获得（学习）权重。基于上述考虑，我们提出了一种信息保存测量方法，该方法使用两个high-dimensionalinformationrefinement过程生成的张量作为输入，评估梯度和强度信息。梯度和强度是融合中最关键的两种信息类型，它们可以同时反映图像的局部和全局信息。这两种信息为损失函数生成两组不同的权重W1,W2; W3,W4。这种像素级融合权重可以根据源图像的特征自适应调整，使融合结果更适合不同类型的融合。同时，这些权重有利于信息的存储和计算。</p><p>梯度信息权重<span class="math inline">\(W_1\)</span>和<spanclass="math inline">\(W_2\)</span>计算方式如下：</p><p><span class="math display">\[W_1 = \varepsilon (\vert F_{grad}(\Phi_1)\vert - \vert F_{grad}(\Phi _2)\vert)\]</span> <spanclass="math display">\[W_2 = 1 - W_1\]</span></p><p><span class="math inline">\(\varepsilon()\)</span>表示阶跃函数，<span class="math inline">\(\Phi_1\)</span>和<span class="math inline">\(\Phi_2\)</span>表示不同中间信息层生成的特征。这样，我们就得到了融合图像中每个元素与源图像之间独特的对应关系。</p><p>为了进一步处理不同源图像强度的不均匀，我们减去同源元素的平均值，以减少非同源元素之间的差异。然后，使用sqrt函数扩大元素值之间的差异。因此，非同源元素被调节为平均值以促进元素强度的比较，可以表达为：</p><p><span class="math display">\[b_1 = sqrt(sigmoid(\Phi_1 -F_{mean}(\Phi_1)))\]</span> <span class="math display">\[b_2 =sqrt(sigmoid(\Phi_2 - F_{mean}(\Phi_2)))\]</span></p><p><spanclass="math inline">\(F_{mean}(\Phi)\)</span>表示元素的总和除以元素个数。为了获得<spanclass="math inline">\(b_1\)</span>和<spanclass="math inline">\(b_2\)</span>之间的相关性，将它们归一化为<spanclass="math inline">\(c_1\)</span>和<spanclass="math inline">\(c_2\)</span>：</p><p><span class="math display">\[[c_1, c_2] = [\dfrac{b_1}{b_1+b_2},\dfrac{b_2}{b_1+b_2}]\]</span></p><p>使用sigmoid函数对强度信息权重<spanclass="math inline">\(W_3\)</span>和<spanclass="math inline">\(W_4\)</span>归一化：</p><p><span class="math display">\[W_3 = sigmoid(c_1 -F_{mean}(c_1))\]</span> <span class="math display">\[W_4 = sigmoid(c_2 -F_{mean}(c_2))\]</span></p><p><span class="math inline">\(W_1, W_2, W_3,W_4\)</span>可以作为融合图像各个像素（元素）纹理和强度的约束信息，还可以帮助网络控制不同源图像的信息保存。这是L-PUIF的关键之处。</p><h4 id="loss-function">4.Loss Function</h4><p>损失函数在图像融合中起着重要作用，它决定了不同源图像之间的信息相关性程度。更具体地说，源图像不同区域的信息量有很大的差异。在像素级图像融合中，应根据这些差异确定不同信息的使用。因此，我们使用损失函数来限制各种类型的信息之间的比例关系。</p><p>损失函数主要包括两部分：梯度损失<spanclass="math inline">\(L_{grad}\)</span>和强度损失<spanclass="math inline">\(L_{int}\)</span>，系数<spanclass="math inline">\(\lambda\)</span>权衡二者的比重：</p><p><span class="math display">\[L_{L-PUIF} = \lambda _1 L_{grad} +\lambda _2 L_{int}\]</span></p><p><spanclass="math inline">\(L_{L-PUIF}\)</span>计算融合图像与源图像之间的相似性（差异）。<spanclass="math inline">\(\lambda_1\)</span> = 1、<spanclass="math inline">\(\lambda_2\)</span> = 0.4。<spanclass="math inline">\(W_1\)</span>和<spanclass="math inline">\(W_2\)</span>用于梯度损失中，用来衡量不同源图像的影响。结构相似度指数测度(SSIM)和均方误差(MSE)用于计算图像的结构相似度和细节相似度。因此，梯度信息可用于保留融合图像中的局部纹理信息：</p><p><span class="math display">\[L_{grad1} = 2 - SSIM_{(W_1 \odot I_1,\W_1 \odot I_f)} - SSIM_{(W_2 \odot I_2,\ W_2 \odot I_f)}\]</span> <spanclass="math display">\[L_{grad2} = MSE_{(W_1 \odot I_1,\ W_1 \odot I_f)}+ MSE_{(W_2 \odot I_2,\ W_2 \odot I_f)}\]</span></p><p>上式中<span class="math inline">\(I_1\)</span>和<spanclass="math inline">\(I_2\)</span>代表源图像，<spanclass="math inline">\(I_f\)</span>代表融合图像，<spanclass="math inline">\(\odot\)</span>代表multiplication，即张量之间对应元素相乘。</p><p><span class="math display">\[L_{grad} = L_{grad1} + \alphaL_{grad2}\]</span></p><p><spanclass="math inline">\(\alpha\)</span>用来平衡两个损失，文中取20来确保可以平衡图像信息的内容。</p><p>与梯度损失的信息约束类似，<spanclass="math inline">\(W_3\)</span>和<spanclass="math inline">\(W_4\)</span>用于梯度损失中，使用MSE计算融合图像和源图像之间的强度相似度：</p><p><span class="math display">\[L_{int} = MSE_{(W_3 \odot I_1, \ W_3\odot I_f)} + MSE_{(W_4 \odot I_2,\ W_4 \odot I_f)}\]</span></p><h4 id="multiple-rgb-inputs">5.Multiple RGB Inputs</h4><p>对于多通道彩色图像输入，将其转换至YCbCr颜色空间中，对Y通道进行L-PUIF融合，对Cb和Cr通道进行加权融合。融合完成后，将融合图像转为RGB图像即可。具体过程见下图所示。</p><p><img src="/img/stage2/stage3/03.png" /></p><h3 id="experiment">Experiment</h3><div class="code-wrapper"><pre><code class="hljs applescript">The parameter <span class="hljs-keyword">of</span> our network <span class="hljs-keyword">is</span> optimized <span class="hljs-keyword">by</span> RMSPropOptimizer <span class="hljs-keyword">with</span> a learning rate <span class="hljs-keyword">of</span> <span class="hljs-number">1e-4</span>.The batch size <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">to</span> <span class="hljs-number">32.</span></code></pre></div><p>实验证明，L-PUIF在多模态（红外可见光）、多曝光、多聚焦三类图像融合任务中都有比较好的效果。</p><p>Limitation:作者只选择了两类源图像中包含的两种主要信息：强度（显著信息）Intensity和梯度（纹理细节）Texture，没有考虑所有有助于提升融合性能的info。</p><hr /><h3 id="ps-postscript-附言">PS (PostScript, 附言)</h3><div class="code-wrapper"><pre><code class="hljs livecodeserver">对应元素相乘: <span class="hljs-keyword">a</span>*b | torch.mul(<span class="hljs-keyword">a</span>,b) | np.<span class="hljs-built_in">multiply</span>(<span class="hljs-keyword">a</span>,b)对应元素乘积，又叫哈达玛积：Hadamard product矩阵乘法: <span class="hljs-keyword">a</span>@b | torch.mm(<span class="hljs-keyword">a</span>,b) | np.matmul(<span class="hljs-keyword">a</span>,b) | np.dot(<span class="hljs-keyword">a</span>,b)</code></pre></div><h2 id="cddfuse">CDDFuse</h2><p>Correlation-Driven Dual-Branch Feature Decomposition forMulti-Modality Image Fusion, 2023(CVPR)</p><h3 id="motivation-1">Motivation</h3><p>当前已存在的基于自编码器（Auto-Encoder）多模态方法有以下三个主要缺点：</p><p>第一，CNN的内部工作机制难以控制、难以解释，导致跨模态特征提取不够充分（个人理解：可能是因为无法解析内部具体的工作机理从而难以针对具体状态进行分析和处理）。</p><blockquote><p>First, the internal working mechanism of CNNs is difficult to controland interpret, causing insufficient extraction of cross-modalityfeatures.</p></blockquote><p>第二，与上下文无关的CNN只能在相对较小的感受野里提取局部信息，很难提取全局信息来生成高质量的融合图像。</p><blockquote><p>Second, the context-independent CNN only extracts local informationin a relatively small receptive field, which can hardly extract globalinformation for generating high-quality fused images. Thus, it is stillunclear whether the inductive biases of CNN are capable enough toextract features for all modalities.</p></blockquote><p>第三，融合网络的前向传播经常导致高频信息的丢失。</p><blockquote><p>Third, the forward propagation of fusion networks often causes theloss of high-frequency information.</p></blockquote><h3 id="introduction-1">Introduction</h3><p>首先，我们在提取的特征中加入相关限制，从而提高特征提取的可控性和可解释性。本文假定：在Multi-ModalityImageFusion（MMIF）任务中，两种模态（红外、可见光）的输入特征在低频相关，表示模态共享信息；而高频特征不相关，表示各自模态的独有特征。因此，我们的目标是通过分别增加低频特征之间的相关性和减少高频特征之间的相关性来促进模态特定特征和模态共享特征的提取。</p><blockquote><p>Our assumption is that, in the MMIF task, the input features of thetwo modalities are correlated at low frequencies, representing themodality-shared information, while the high-frequency feature isirrelevant and represents the unique characteristics of the respectivemodalities.</p></blockquote><p>第二，我们结合CNN在局部上下文提取和计算效率方面的优势，以及Transformer<span class="math inline">\(^{[1][2]}\)</span>在全局关注（特征提取）方面的优势，完成MMIF任务。</p><blockquote><p>We propose integrating the advantages of local context extraction andcomputational efficiency in CNN and the advantages of global attentionand long-range dependency modeling in Transformer to complete the MMIFtask.</p></blockquote><p>第三，为了解决高频特征的丢失问题，我们采用可逆的神经网络INN（InvertibleNeural Networks）构建块，通过输入和输出特征相互生成来保留高频特征。</p><blockquote><p>INN was proposed with invertibility by design, which preventsinformation loss through the mutual generation of input and outputfeatures and aligns with our goal of preserving high-frequency featuresin the fused images.</p></blockquote><p>为此，我们提出了CDDFuse模型，模态特定和模态共享特征的提取由双分支编码器实现，融合图像重建由解码器实现。CDDFuse模型中包括以下几个重要模块：LiteTransformer <span class="math inline">\(^{[3]}\)</span>、Restormerblocks <span class="math inline">\(^{[4]}\)</span>、INNs <spanclass="math inline">\(^{[5]}\)</span>。</p><blockquote><p>To this end, we proposed the Correlation-Driven feature DecompositionFusion (CDDFuse) model, where modality-specific and modality-sharedfeature extractions are realized by a dual-branch encoder, with thefused image reconstructed by the decoder.</p></blockquote><figure><img src="/img/stage2/stage3/04.png"alt="Vanilla fusion architectures and CDDFuse model" /><figcaption aria-hidden="true">Vanilla fusion architectures and CDDFusemodel</figcaption></figure><h3 id="method-1">Method</h3><p>CDDFuse详细的工作流程如下图所示：</p><figure><img src="/img/stage2/stage3/05.png"alt="The architecture of CDDFuse method" /><figcaption aria-hidden="true">The architecture of CDDFusemethod</figcaption></figure><p>CDDFuse包括四个模块：双分支编码器（提取和分解特征）、解码器（重建原始图像和生成融合图像）、基础融合层（融合低频特征）、细节融合层（融合高频特征）。</p><blockquote><p>Our CDDFuse contains four modules, i.e., a dual-branch encoder forfeature extraction and decomposition, a decoder for reconstructingoriginal images (in training stage I) or generating fusion images (intraining stage II), and the base/detail fusion layer to fuse thedifferent frequency features, respectively.</p></blockquote><h4 id="encoder">Encoder</h4><p>编码器有三个components：the Restormer block -based <em>share featureencoder</em> (SFE)、the Lite Transformer(LT) block -based <em>basetransformer encoder</em> (BTE)、the Invertible Neural networks(INN)block -based <em>detail CNN encoder</em>(DCE)，分别用S(·)、B(·)、D(·)表示。</p><p>SFE用来从红外、可见光图像 {I,V} 中提取浅层共享特征：{<spanclass="math inline">\(\Phi _I^S\)</span>,<spanclass="math inline">\(\Phi _V^S\)</span>}，即：<spanclass="math inline">\(\Phi _I^S = S(I)\)</span>，<spanclass="math inline">\(\Phi _V^S =S(V)\)</span>。在SFE中使用Restormer是因为其可以通过跨特征维度应用自注意力从高分辨率输入图像中提取全局特征。</p><p>BTE用来从共享特征中提取低频基本特征：<span class="math inline">\(\Phi_I^B = B(\Phi _I^S)\)</span>，<span class="math inline">\(\Phi _V^B =B(\Phi_V^S)\)</span>。为了提取长距离依赖特征，并平衡性能与计算效率，在BTE中使用了带空间自注意力的轻量化（Lite）Transformer。</p><p>DCE与BTE相反，从共享特征中提取高频细节信息：<spanclass="math inline">\(\Phi _I^D = D(\Phi _I^S)\)</span>，<spanclass="math inline">\(\Phi _V^D = D(\Phi_V^S)\)</span>。利用CNN强大的特征提取能力尽可能多的保留边缘、纹理等细节信息。INN模块通过输入和输出特征相互生成，使得输入信息能尽可能多的被保存下来。因此，它可以被看作是一个无损特征提取模块。</p><p>DCE中的INN模块比较复杂，计算公式请参考论文原文，计算细节可以看Figure2(b)，其中<span class="math inline">\(\Phi_{I,k}^{S}[1:c]\)</span>表示第k个可逆层输入特征的第c个通道的第一个元素，<spanclass="math inline">\(I_i \ (i=1 23)\)</span>是任意的映射函数。最终，<span class="math inline">\(\Phi _I^D= \Phi _{I,k}^{S}\)</span>，<span class="math inline">\(\Phi _V^D = \Phi_{V,k}^{S}\)</span>。</p><h4 id="fusion-layer">Fusion layer</h4><p>考虑到inductive bias for base/detail featurefusion应该与编码器中的base/detail featureextraction相似，我们对基础融合层和细节融合层采用LT和INN块。</p><p><span class="math display">\[\Phi ^B = F_B(\Phi _I^B,\Phi _V^B), ~~~~\Phi ^D = F_D(\Phi _I^D,\Phi _V^D)\]</span></p><p>其中，<span class="math inline">\(F_B\)</span>和<spanclass="math inline">\(F_D\)</span>分别代表基础融合层和细节融合层。</p><h4 id="decoder">Decoder</h4><p>Decoder表示为DC(·)，输入是已分解的在通道维度拼接后的特征，输出是（重建的）原始图像（训练阶段1）或者融合图像（训练阶段2），公式如下。</p><p>Stage 1: <span class="math inline">\(~~~ \widehat{I} = DC(\Phi_I^B,\Phi _I^D), ~~~ \widehat{V} = DC(\Phi _V^B,\Phi _V^D)\)</span></p><p>Stage 2: <span class="math inline">\(~~~ F = DC(\Phi ^B,\Phi^D)\)</span></p><p>由于输入涉及跨模态和多频特征，我们保持解码器的结构与SFE一致，即使用Restormerblock作为解码器的基本单元。</p><h4 id="two-stage-training">Two-stage training</h4><p>这一部分相当于对上述内容的总结，这里直接引用论文原文的内容：</p><p>Training stage I: In the training stage I, the paired infrared andvisible images <span class="math inline">\({I,V}\)</span> are input intothe SFE to extracts shallow features <span class="math inline">\({\Phi^S_I,\Phi ^S_V}\)</span>. Then the LT block-based BTE and the INN-basedDCE are employed to extract lowfrequency base feature <spanclass="math inline">\({\Phi ^B_I,\Phi ^B_V}\)</span> and high-frequencydetail feature <span class="math inline">\({\Phi ^D_I,\Phi^D_V}\)</span> for the two different modalities, respectively. Afterthat, the base and detail features of infrared <spanclass="math inline">\({\Phi ^B_I,\Phi ^D_I}\)</span> (or visible <spanclass="math inline">\({\Phi ^B_V,\Phi ^D_V}\)</span>) images areconcatenated and input into the decoder to reconstruct the originalinfrared image <span class="math inline">\(\widehat{I}\)</span> (orvisible image <span class="math inline">\(\widehat{V}\)</span>).</p><p>Training stage II: In the training stage II, the paired infrared andvisible images <span class="math inline">\({I,V}\)</span> are input intoa nearly well-trained Encoder to obtain the decomposition features. Thenthe decomposed base features <span class="math inline">\({\Phi ^B_I,\Phi^B_V}\)</span> and detail features <span class="math inline">\({\Phi^D_I,\Phi ^D_V}\)</span> are input into the fusion layer <spanclass="math inline">\(F_B\)</span> and <spanclass="math inline">\(F_D\)</span>, respectively. At last, the fusedfeatures <span class="math inline">\({\Phi ^B,\Phi ^D}\)</span> areinput into the decoder to obtain the fused image <spanclass="math inline">\(F\)</span>.</p><h4 id="training-loss">Training loss</h4><p>In training stage I, the total loss <spanclass="math inline">\(L_{total}^{I}\)</span> is:</p><p><span class="math display">\[L_{total}^{I} = L_{ir} + \alpha _1L_{vis} + \alpha _2 L_{decomp}\]</span></p><p>where <span class="math inline">\(L_{ir}\)</span> and <spanclass="math inline">\(L_{vis}\)</span> are the reconstruction losses forinfrared and visible images, <spanclass="math inline">\(L_{decomp}\)</span> is the feature decompositionloss, and <span class="math inline">\(\alpha _1\)</span> as well as<span class="math inline">\(\alpha _2\)</span> are the tuningpapameters. The reconstruction losses mainly ensure that the informationcontained in the images is not lost during the encoding and decodingprocess, i.e.</p><p><span class="math display">\[L_{ir} = L_{int}^{I}(I,\widehat{I}) +\mu L_{SSIM}(I,\widehat{I})\]</span></p><p>where <span class="math inline">\(L_{int}^{I} = \Vert I-\widehat{I}\Vert _2^2\)</span> and <spanclass="math inline">\(L_{SSIM}(I,\widehat{I}) =1-SSIM(I,\widehat{I})\)</span>. <spanclass="math inline">\(L_{vis}\)</span> can be obtained in the sameway.</p><p><span class="math display">\[L_{decomp} =\dfrac{(L_{CC}^{D})^2}{L_{CC}^{B}} = \dfrac{(CC(\Phi ^D_I,\Phi^D_V))^2}{CC(\Phi ^B_I,\Phi ^B_V)+\epsilon}\]</span></p><p>where CC(·) is the correlation coefficient operator（相关系数算子）,and <span class="math inline">\(\epsilon\)</span> here is set to 1.01 toensure this term always being positive.</p><p>根据作者MMIF的假设，分解的特征<span class="math inline">\({\Phi^B_I,\Phi^B_V}\)</span>包含更多的模态共享特征，如背景（background）和大范围环境（large-scaleenvironment），因此它们通常是高度相关的。而<spanclass="math inline">\({\Phi ^D_I,\Phi^D_V}\)</span>表示可见光图像中的纹理细节信息和红外图像中的热辐射以及清晰的边缘信息，是特定模态的，相关性较低。按照经验，<spanclass="math inline">\(L_{decomp}\)</span>这个损失项会随着梯度下降算法逐渐变小（趋于0）。</p><h3 id="evaluation">Evaluation</h3><p>这篇文章的对比实验和消融实验做的很充分，评估指标很全面，值得推敲。本文提出了可见光-红外图像融合（VIF）领域中目前存在的三个问题，然后分别给出自己的解决方法，条理清晰。利用Restormer、LiteTransformer和Invertible neural networkblock，对modality-specific和modality-shared特征进行更有效的提取，并且采用correlation-drivendecomposition loss对模型进行优化，我个人感觉都是很不错的创新。</p><hr /><p>[1] Transformer, firstly proposed by Vaswani et al. for naturallanguage processing (NLP). Title: Attention Is All You Need (2017).</p><p>[2] ViT, proposed by Dosovitskiy et al. for computer vision. Title:An Image is Worth 16X16 Words: Transformers for Image Recognition atScale (2021).</p><p>[3] Considering the large computational overhead of spatialself-attention, Wu et al. proposed a lightweight LT structure for mobileNLP tasks. Title: Lite Transformer with Long-Short Range Attention(2020).</p><p>[4] Restormer improves transformer block by the gated-Dconv networkand multi-Dconv head attention transposed modules, which facilitatemulti-scale local-global representation learning on high-resolutionimages. Title: Restormer: Efficient Transformer for High-ResolutionImage Restoration (2022).</p><p>[5] The invertible neural network is an important module of theNormalized Flow model, a popular kind of generative model. It was firstproposed by NICE, and later the additive coupling layer in NICE wasreplaced by the coupling layers in RealNVP. Subsequently, 1×1 invertibleconvolution was used in Glow, which can generate realistichigh-resolution images. Relevant: NICE: Non-linear IndependentComponents Estimation (2014), Density estimation using Real NVP (2016),Glow: Generative Flow with Invertible 1×1 Convolutions (2018), AnalyzingInverse Problems with Invertible Neural Networks (2018).</p><hr /><h3 id="引申">引申</h3><p><font color="red">通用图像融合评估指标归纳</font>：</p><ul><li>基于图像特征的指标：平均梯度（AG）、空间频率（SF）、标准差（SD、STD）</li><li>基于相关的指标：相关系数（CC）、非线性相关系数（NCC）、差异相关性总和（SCD）</li><li>基于图像结构的指标：结构相似性度量（SSIM）、多尺度结构相似性度量（MS-SSIM）</li><li>基于信息熵的指标：信息熵（EN）、互信息（MI）、特征互信息（FMI）、标准化互信息（NMI）、峰值信噪比（PSNR）、关于边缘信息的指标（<spanclass="math inline">\(Q^{AB/F}\)</span>）、关于伪影的指标（<spanclass="math inline">\(N^{AB/F}\)</span>）</li><li>基于人类感知的指标：视觉保真度（VIF、VIFF）、人类视觉感知的度量（<spanclass="math inline">\(Q_{CB}\)</span>）</li></ul><p><mark>选取准则</mark>：尽量覆盖以上5大类评估指标，同时尽量避免使用太多表征相同特性的指标，比如AG和SF。</p><p><font color="purple">部分术语解释</font>（公式自己查）：</p><ul><li>AG(AverageGradient)，用于衡量融合图像的清晰程度，平均梯度越大，图像越清晰</li><li>SF(SpatialFrequency)，反映图像灰度的变化率，空间频率越大，图像越清晰</li><li>SD(StandardDeviation)，是度量图像信息丰富程度的客观评价指标，标准差越大，图像灰度级分布越分散，携带信息量越多，质量越高</li><li>CC(CorrelationCoefficient)，衡量两个变量之间的线性关系的强度和方向，如皮尔逊相关系数，取值范围是[-1,1]，取值：1说明完全正相关，-1说明完全负相关，0说明无线性相关性</li><li>NCC，衡量两个变量之间的非线性关系，如斯皮尔曼等级相关系数，取值范围是[-1,1]，取值：1说明完全正相关，-1说明完全负相关，0说明无相关性</li><li>SSIM，结构相似性度量，取值范围是[-1,1]，该值越接近1，说明两幅图像越相似</li><li>MS-SSIM，多层级SSIM，能更好地与人眼视觉系统的感知相一致，在一定尺度下，评价效果优于SSIM</li><li>EN(Entropy)，度量图像包含信息量的多少，信息熵越高，表示融合图像信息量越丰富，质量越好</li><li>MI(MutualInformation)，度量两幅图像之间的相似程度，即融合图像获取了源图像的多少信息，互信息越大，说明融合图像保留更多的源图像信息，质量越好</li><li>FMI，特征互信息，由Mohammad在2011年发表的论文中提出，是基于互信息的图像融合质量评价指标，该值越大，表示融合图像质量越好</li><li>NMI(Normalized mutualinformation)，是度量图片相似度的一种方式，NMI值越大，表示融合图像保留了更多源图像的信息，融合效果越好</li><li>PSNR，衡量信号的质量，一般超过50dB就说明信号质量已经非常好了</li><li><spanclass="math inline">\(Q^{AB/F}\)</span>，是论文中提出的方法，比较新，值越高，表示融合图像质量越好</li><li>VIF(Visual Information Fidelity (forfusion))，是论文中提出的方法，取值通常在0-1之间，基于人眼感知系统，VIF的值越大，表示融合图像的质量越高</li></ul>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summarize</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献整理 · 脉络篇（二）</title>
    <link href="/2023/12/20/papers3/"/>
    <url>/2023/12/20/papers3/</url>
    
    <content type="html"><![CDATA[<p>地址：<a href="https://zhuanlan.zhihu.com/p/467039982"title="温柔的博士师兄写的文章~">部分基于深度学习的红外与可见光图像融合模型总结</a></p><hr /><h2 id="tc-gan">1.TC-GAN</h2><p>Infrared and Visible Image Fusion via Texture Conditional GenerativeAdversarial Network (Transactions on Circuits and Systems for VideoTechnology, 2021)</p><p>本文模型TC-GAN的一大亮点是使用了引导滤波器，引导滤波器首次于2013年由K.He,J.Sun, andX.Tang提出，可以充分利用相邻像素之间的相关性，让图像包含特定的一致性。具体原理是引导滤波器会用一个引导图像Y来对输入图像X进行滤波，输出图像Z便能在保持X信息的基础上获得引导图像Y的变化趋势。</p><p>TC-GAN会生成一个组合纹理图来捕获梯度变化。生成器是编码器结构，用来提取细节，中间有一个SE-Net模块来提高纹理图中显著纹理信息的权重。判别器的作用是让融合图像的纹理细节更接近可见光图像。为了获得更好的纹理信息，作者们提出了一种使用组合纹理图和自适应引导滤波器的基于多决策图的融合策略。换句话说就是：组合纹理图记录了原图像的纹理，被用作自适应引导滤波器（AGF）的引导图像，然后采用AGF生成的多个决策图来设计融合策略重建融合结果。</p><p><imgsrc="https://pic2.zhimg.com/v2-e9276d6564b7334ca9c578aa9491cbed_r.jpg" /></p><p>首先红外与可见光图像会一起送入TC-GAN中生成组合纹理图，然后组合纹理图会被作为引导图像，用引导滤波器对源图像进行滤波，获得多个决策图。最后用多个决策图融合并重建图像。其中TC-GAN的具体结构如下图。</p><p><imgsrc="https://pic4.zhimg.com/v2-e2b79a5847c2d12984b2192401c3b7b3_r.jpg" /></p><p>生成器由编码器、SE-Net、解码器三部分组成。中间的SE-Net模块学习到的尺度向量对编码器提取的特征进行加权，可以在训练过程中增强有用的纹理特征，因此用在编码器后面来增强特征。要生成组合纹理图，需要在组合纹理图的监督下训练生成器，然而组合纹理图并不存在（还没生成呢）。因此本文是采用GAN的训练模式，定义了一个判别器，以包含丰富纹理细节的可见光图像作为标签来训练生成器。判别器是一个全卷积网络，对图像进行像素级别的分类，可以判断生成图像中的纹理分布是否与可见图像的纹理分布一致。</p><p>损失函数的设计：生成器损失函数包含gradient loss和adversarialloss两个部分，梯度损失是为了让生成的纹理图包含更多的细节，将对抗损失和梯度损失加权求和得到生成器的损失。判别器引导TC-GAN生成器的训练来识别融合图像与可见光图像，促使生成器得到的融合图像包含更多纹理细节，因此判别器利用交叉熵作为损失来计算融合图像与可见光图像之间的差异。</p><div class="code-wrapper"><pre><code class="hljs">对抗损失adversarial loss在所有用GAN模型的文章中都出现了，建议回顾相关资料</code></pre></div><p>附上CSDN关于对抗Loss理解的文章链接：<ahref="https://blog.csdn.net/qq_38784454/article/details/112464701">对抗Loss的理解</a></p><p>在经过TC-GAN获得组合纹理图作为引导图像对源图像进行滤波后，可以获得多个决策图，下面就是对这些决策图进行融合了。多决策图的融合包含两个步骤：1.基于组合纹理图创建多个决策图（组合纹理图作为引导滤波器的引导图像）；2.多决策图被用于获得初步的融合结果。最终的融合图像是通过加权法获得的。</p><h2 id="attentionfgan">2.AttentionFGAN</h2><p>Infrared and Visible Image Fusion Using Attention-Based GenerativeAdversarial Networks (Transactions on Multimedia, 2021)</p><p>AttentionFGAN将多尺度注意力机制加入GAN来进行红外-可见光图像的融合。对于判别器，优势主要是可以限制判别器对注意力区域关注得更多，而非全图都关注；对于生成器，多尺度注意力网络被用来训练学习一个特征的权重，使重要特征被赋予更多注意，冗余特征则被忽略。为了保留注意力区域更多信息，设计了attention损失函数。判别器改用Wassersteindistance计算源图像和融合图像之间的差异。从结果来看AttentionFGAN对红外显著性区域保护的很不错。</p><p>模型的结构如下图。生成器包含2个多尺度注意力网络和1个融合网络，两个多尺度注意力网络分别获得红外与可见光图像的注意力图，融合网络在重建图像时会更关注重点区域。2个判别器会让融合结果更好地保留像素幅度与细节信息，作用分别是区分融合图像与红外/可见光图像。</p><figure><imgsrc="https://pic2.zhimg.com/v2-ae207cc3db61021987f911f3caf658b1_r.jpg"alt="AttentionFGAN模型结构图" /><figcaption aria-hidden="true">AttentionFGAN模型结构图</figcaption></figure><p>生成器部分的两个多尺度注意力模块首先分别获得红外与可见光图像的注意力图，然后将这两个注意力图和源图像在通道维度拼接后送入融合网络。两个判别器分别用来区分融合图像与红外/可见光图像，结构完全相同，但是参数不共享。在训练阶段，将输入图像（融合图像）送入多尺度注意力网络计算注意力图，然后将注意力图和输入图像在通道维度拼接，让判别器能更关注具有区分力的区域。为了提高效果，这里用了WGAN中的Wassersteindistance来计算融合图像与源图像之间的距离。由于WGAN是专门计算Wassersteindistance的，可以看做为一个回归问题，因此在计算损失的时候将log函数去除了，判别器最后一个sigmoid层也被移除了。</p><p>上图中的多尺度融合网络，在生成器中的作用是获得注意力图，在判别器中的作用是让模型更关注具有判别能力的区域，它的结构如下图。</p><figure><imgsrc="https://pic2.zhimg.com/v2-8e772b2c1df5c6e388dbc728867b9d3d_r.jpg"alt="多尺度融合模块" /><figcaption aria-hidden="true">多尺度融合模块</figcaption></figure><p>首先使用卷积层提取特征，这里用最后两个卷积层的输出作为深层特征图。单尺度的特征难以提取到有效的空间信息，因此通过多个尺寸的全局池化来获得多尺度特征。但是在池化操作会产生太多冗余特征图，最好是选择重要特征，去除冗余特征，所以这里让网络基于每个特征图的全局信息来重新计算权重。这个过程由GP+FC+Sg三个模块实现。全局池化GP结束后用全连接层和sigmoid来计算权重。</p><p>获得了最终的权重后，用上采样算子对多尺度特征图进行上采样，获得相同尺寸的特征图。然后，用刚才获得的权重和上采样后的特征图乘累加，再通过一次标准化算子，最后的注意力图需要用最大选择策略，即不同尺度在各自分支获得的Features先在通道维度上拼接，再用最大值法获得最终的注意力图。以上就是多尺度融合网络的机制。</p><p>生成器的损失函数包含adversarial loss、content loss、attentionloss三项，contentloss让生成器生成和红外图像数据分布更接近的图像，因为红外图像对热量敏感，体现在像素幅度上；attentionloss是由于引入了多尺度注意力机制。当判别器无法区分融合图像和源图像时，判别器的两个输入应该具有相同的注意区域。例如，最终的融合结果应该从红外图像中保留足够的典型信息，然后当判别器无法区分融合图像和红外图像时，融合结果和红外图像应该具有相同的注意力图。因此为了从源图像中保留更多注意力区域的信息，设计了融合图像与源图像之间的attentionloss，对融合图像的注意力图与源图像的注意力图之间的差异进行惩罚（约束），具体的公式参考<ahref="https://zhuanlan.zhihu.com/p/467039982">专栏3.10</a>。</p><h2 id="drf">3.DRF</h2><p>Disentangled Representation for Visible and Infrared Image Fusion(Information Fusion, 2021)</p><p>这篇文章的损失函数和之前的方法差异较大。本文将图像分解为场景特征图和属性向量，分别表示两个模态的共同信息和不同信息，个人认为这也是对互补信息的一种探讨。</p><p>大致思想：本文将Disentangledrepresentation应用于可见光和红外图像融合。根据成像原理，将可见光和红外图像中的信息来源进行分解，即分别通过相应的编码器将图像分解为与场景模态和传感器模态（属性）相关的表示。这样，由属性（传感器模态）相关表示定义的唯一信息更接近于每种传感器单独捕获的信息。因此，可以缓解独特信息提取不当的问题。然后应用不同的策略来融合这些不同类型的表示。最后融合的表示被输入到预训练的生成器中以生成融合结果。</p><p>传统的图像分解方法会使用同种方法对图像进行分解，一般来说可能会造成关键信息丢失，也可能会生成冗余信息。一些方法针对不同的模态采取了不同的信息描述，例如对红外图像用像素幅度来描述，对可见光图像用梯度来描述，然而这种人工设计的信息分离方法也不能完整地描述图像信息。为了解决这个问题，应该尽可能地从源图像中的公共信息中分离出唯一信息。为此，可以从源图像的成像过程这个方向探讨信息的保留方式。无论源图像是从可见光传感器还是从红外传感器捕获的，它们都是从同一场景中拍摄的，其中包含大量（共同的）场景信息。不同之处在于这两种类型的传感器使用其特定的成像方式来捕获原始信息，具体方法是将源图像分解为两个部分：场景信息和传感器模态相关的信息。由于与传感器模态相关的信息反映了传感器或源图像的属性，我们将这类信息定义为唯一的属性表示；而来自场景的信息，即场景表示，是两者的共同信息。基于以上思考提出了新的融合模型：disentangledrepresentation for visible and infrared image fusion (DRF) 。</p><p>在DRF中，用disentangledrepresentation来解构源图像中的场景和属性表示。场景信息通过一个场景编码器被作为公共信息来提取，属性表示通过一个属性编码器被作为唯一信息来提取，结构如下图所示。</p><p><imgsrc="https://pic2.zhimg.com/80/v2-2c4280d2522c317019d7b7d34a761099_720w.webp" /></p><p><img src="/img/stage2/3_13.png" /></p><p><imgsrc="https://pic1.zhimg.com/80/v2-60b1c567cdfc12b80029083011a91f44_720w.webp" /></p><p>考虑到场景信息直接和空间、位置相关，所以场景表示就用特征图的方式来呈现（Fig1的形式）。而属性是和传感器模态相关的，不必捕获场景信息，所以属性更适合通过一个向量来表示。</p><p>为了实现Disentangledrepresentation，提出以下三个策略。首先，红外图像域X和可见光图像域Y的场景编码器最后一层参数共享，通过这样的方法就可以使两个域图像的场景特征嵌入到同一空间中了，但是共享高层权重的方式不能保证场景编码器对来自两个不同域的相同信息进行编码。所以第二个策略是对场景特征进行约束，让X和Y的场景编码器对来自两个域的相同场景特征进行编码。第三个策略，为了压缩属性空间中的场景信息，要对属性向量的分布进行约束，因此属性编码器不会对场景相关信息进行编码。</p><p>接下来，为了能让场景和属性两种信息表示源图像，那么通过场景S和属性A必须能够恢复源图像，因此加了一个生成器G来学习这种逆映射。考虑到Ax和Ay对生成器来说是不一致的，并考虑到后续的融合过程，{S,Sx}到X、{S,Ay}到Y的（逆）映射过程共享一个生成器，希望G能同时具有这两种映射的能力。</p><p>一方面，重建得到的x和y应该尽量和源图像x和y相似，这个容易理解。另一方面，S最好跨域X和Y捕获信息，而Ax和Ay应该捕获相应域的特定属性，而不携带域不变的场景相关线索。那么，假设X和Y是对同一场景的描述，那么<spanclass="math inline">\(s_x\)</span>和<spanclass="math inline">\(s_y\)</span>应该是相似的。相反地，给定不同的属性向量，生成器G生成的图像应该和提取属性向量那个模态的图像相同，而和没有提取属性向量那个模态的图像不同。举个例子，以<spanclass="math inline">\(s_x\)</span>和<spanclass="math inline">\(a_y\)</span>为条件，G生成的图像形式应该是这样的：<spanclass="math inline">\(y_x\)</span>是一个由X场景信息和Y的属性信息生成、重建结果看起来像Y的图像，<spanclass="math inline">\(y_x\)</span>和Y应该保持像素连续性。</p><p>网络结构：场景编码器分为红外场景编码器和可见光场景编码器，结构如下图，一共包含七个层，5个残差模块和2个卷积层。</p><p><imgsrc="https://pic1.zhimg.com/80/v2-89bda80f8e9896e943b202242316d188_1440w.webp" /></p><p>其中残差块的结构如下图所示：</p><p><imgsrc="https://pic4.zhimg.com/v2-448aa9b1b001efa7af25ff28d4acc247_r.jpg" /></p><p>属性编码器结构如下图，卷积层都是5×5的卷积核搭配长度为2的步长，然后在通道维度上进行全局平均池化，属性信息就被映射到向量形式了。</p><p><imgsrc="https://pic2.zhimg.com/v2-d850ada815fd015ec69af01efdbf2ad1_r.jpg" /></p><p>生成器结构：</p><p><imgsrc="https://pic4.zhimg.com/v2-2075bda13fb90502ce9b886a0e2651ef_r.jpg" /></p><p>对场景特征，首先通过一个残差块处理，而对属性向量，会被平铺到和场景特征图一样的尺寸，这样就能和场景特征图在通道维度上进行拼接了。再经过几个残差块后用反卷积层对特征图进行上采样。场景特征图的空间分辨率降低到原始图像的四分之一，因此丢失了许多高质量的纹理细节，为了弥补损失，将场景编码器中第一个残差块的输出，和生成器中第二个反卷积层的输出进行拼接，送入后续的卷积层中。再经过多个卷积层，通道数量被削减到和输入图像通道数量一样，最后一个tanh后就是重建得到的图像。</p><p>融合模块，由于场景特征共享同一场景，因此用平均策略融合<spanclass="math inline">\(s_x\)</span>和<spanclass="math inline">\(s_y\)</span>，属性特征<spanclass="math inline">\(a_x\)</span>和<spanclass="math inline">\(a_y\)</span>直接加权求和。以上两种特征图用一个预训练的生成器G来获得融合图像：<spanclass="math inline">\(f = G(s_f,a_f)\)</span></p><p>损失函数由以下几项构成：</p><p>(1)场景特征一致性损失Scene Feature Consistency Loss给定描述同一场景的源图像x和y，它们的场景特征需要类似。因此该项损失用1-范数或者Frobenius-norm进行约束。但是本文发现L1-norm更合适，因为红外和可见光传感器的成像原理不同，这两种源图像中的场景信息不可能完全相同，但是整体而言场景信息不同的区域还是非常小的，大部分区域的场景信息能保持相同就可以了，那些小部分场景信息不同的区域实在不行就算了。换句话说，希望两个模态场景信息中的差异是稀疏的，因此相比较Frobenius-norm，L1-norm更合适。</p><p>(2)属性分布损失Attribute Distribution Loss 基于Disentangledrepresentation的考虑，希望能在属性空间中尽量压缩场景信息，预计属性表示将与先验高斯分布一样接近。KL项会促进disentanglement，因此对x和y属性向量的分布施加约束，通过测量它们的分布和先验高斯分布之间的KL散度并对此进行约束。</p><p>(3)自重建损失Self-Reconstruction Loss原始源图像将根据场景和与之分离的属性表示进行重建。也就是说，生成器G应该能够将场景特征和属性向量解码回原始源图像。因此，我们执行自重建损失以使重建的图像与原始图像达到高保真度：<spanclass="math inline">\(L_{reconstruction} = \Vert x - \hat {x} \Vert_1 +\Vert y - \hat {y} \Vert_1\)</span></p><p>(4)域转换损失Domain-Translation Loss转换后的图像是根据一张源图像的场景特征和另一张源图像的属性向量生成的。<img src="/img/stage2/3_0.png" /></p><h2 id="年论文小结">19-21年论文小结</h2><p>总体来说自监督模型在损失函数方面，像素幅度的信息的计算使用的还是L2-norm/MSE较多，细节纹理信息的计算使用的是SSIM和梯度算子较多。2020年之前的很多模型为修改网络结构和损失函数的形式，早期的融合规则方面有使用attention形式的规则，但仍然是人工设计的融合规则，其中非学习方式产生的显著性图不能反映原图信息的有效性，还是应该用网络来学习融合规则。早期还有用预训练好的VGG进行特征提取，然后融合特征图的方法，但是提取到的特征不一定准确，毕竟不是专门通过多模态图像训练的网络。不过也逐渐有文章开始探讨什么是互补信息，以及如何在实际的融合过程中找出图像对中每个模态的互补信息（或者说一个区域中该模态有，而其他模态没有的信息）。</p><p>基于GAN的方法可以利用无监督对抗学习模型，充分利用源图像的信息。损失函数主要是设计contentloss和adversarialloss。难点是生成器和判别器之间的平衡难以达到。对于图像融合的模型结构，综述Imagefusion meets deep learning: A survey andperspective中认为当前用于图像融合的网络结构最有效的三种是残差连接、dense连接和双分支。提升深度学习模型的两种方式：1.设计高质量的指标用于无监督学习（高质量的评价指标不光可以用于损失函数，也对模型的真实效果评价有利）；2.构建接近真实场景的数据用于有监督学习。</p><p>未来需要根据任务设计更具有针对性的网络，比如做任务驱动的模型，根据下游任务来决定融合的损失函数，例如SeAFusion，不然的话融合效果的评价还是比较主观的。</p><h2 id="补充-4.transmef">补充 4.TransMEF</h2><p>A Transformer-Based Multi-Exposure Image Fusion Framework usingSelf-Supervised Multi-Task Learning (AAAI, 2022)</p><p>目前用CNN做融合的模型很多都把CNN用在编码器上用于特征提取，但是CNN本身存在感受野小、不能提取长程信息的问题。而图像融合中，融合图像的质量不仅和感受野内的每个像素相关，也和图像整体的像素强度与纹理信息有关，所以同时对全局和局部信息建模是有必要的。所以本文针对多曝光图像融合提出了transMEF模型，这是一种基于transformer的自监督多任务学习模型，也采用编码器-解码器结构，在大规模自然图像数据集上进行自监督训练。融合过程中，首先使用编码器提取源图像的特征图，然后用解码器生成融合图像。</p><p>总结本文创新点：1.根据多曝光图像的特点提出三个自监督重建任务，基于多任务学习训练出了一个自编码器，所以模型不仅能在大规模自然图像上训练，也可以学习到多曝光图像的特点；2.为了克服CNN难以捕获长程信息的缺陷，提出了包含transformer结构的编码器结构，这样在特征提取过程中局部和全局信息都能捕获；3.在一个benchmark上和其他12种模型，依据11个指标进行了对比。</p><p>模型总体结构图： <imgsrc="https://pic3.zhimg.com/v2-ee6336a02679c775d68ccf9473b4789e_r.jpg" /></p><p>网络的训练和以前使用CNN的编码器-解码器融合网络类似，即直接将整体作为一个图像重建来训练自编码器。给定一个输入图像，通过三种不同的变换（Gamma-basedtransformation: TG(·), Fourier-based transformation: TF (·) and globalregion shuffling:TS(·)）对源图像的多个区域产生失真，产生三种不同的失真图像，然后将这些失真图像送入编码器中。编码器包含一个特征提取模块（TransBlock）和一个特征增强模块（EnhanceBlock）。其中TransBlock包含CNN和transformer，CNN的输入直接将整图输入即可，而transformer则是将图像先分为多个patch，再送入transformer中训练。TransBlock的输出再送入EnhanceBlock对特征图进行聚合与增强，完成之后送入解码器中重建图像。上述三个任务使用多任务学习同时进行。自编码器训练好后，输入图像就能通过编码器得到特征图了，用上图b的方式对特征图进行融合。</p><p>基于transformer的编码器-解码器结构：前述所说第一阶段的重建训练首先要使用三种方式生成三种失真图像，具体做法是：在每种方式下，对一张输入图像随机产生10个子区域，每个子区域的宽和高是1到25之间的随机整数，然后每张图像在这10个子区域中进行变换，产生失真的子区域，替换源图像的该区域。而三种变换方式就对应TG(·)、TF(·) andTS(·)，和结构图中的三种方式一一对应。然后把这些失真图像送入TransBlock进行特征提取即可。而EnhanceBlock则是将TransBlock输出特征图的全局和局部信息进行聚合，具体是先将CNN和transformer分别输出的特征图在通道维度进行拼接，然后再送入两个卷积块（ConvBlock）中，以此来强化特征。结构图c展示了Transformer和ConVBlock模块的具体组成，每个卷积块包含两个3×3、padding为1的卷积层，解码器中的卷积块也是如此。</p><p>TransBlock：该模块下的CNN部分比较简单，直接级联三个卷积块即可，输入就是完整的三类失真图像。而transformer部分则是先将三类失真图像分成多个P×P大小的patch序列，再用Linearprojection获得embedding，将这些embedding送入L层的transformer，得到输出。Transformer的结构包含多头注意力MSA、LayerNorm、残差连接和MLP，其中MLP是两个使用RELU激活函数的线性层。</p><p>损失函数：损失函数用于多任务学习，针对三类失真图像同时训练三种图像重建任务，在上面的结构图a中最上方有Loss的公式，三项分别对应三类重建任务的损失。每一项任务的损失<span class="math inline">\(Loss_{Task_i}\)</span>都不仅考虑像素级损失，还要考虑结构性损失和梯度信息。三项分别设计为：计算像素级损失的MSE、计算结构损失的SSIM和计算总变分损失的TV范数。</p><p><span class="math display">\[L_{MSE} = \Vert I_{out} -I_{in}\Vert_2\]</span> <span class="math display">\[L_{SSIM} = 1 -SSIM(I_{out},I_{in})\]</span></p><p>第三项的totalvariation项（TV损失）用来减少图像的虚假边缘和噪声等失真，同时能保留源图的边缘信息。计算公式如下：</p><p><span class="math display">\[R(p,q) = I_{out}(p,q) -I_{in}(p,q)\]</span> <span class="math display">\[L_{TV} =\sum\limits_{p,q} (\Vert R(p,q+1) - R(p,q) \Vert_2 + \Vert R(p+1,q) -R(p,q)\Vert_2)\]</span></p><p>从上式能看出R其实计算的是源图和重建图像之间的差分。</p><p>融合规则：直接将两个原始图像经过编码器得到的F1和F2平均即可。</p><p>三类图像重建任务：用于在训练编码器-解码器阶段，对原始输入图像进行变换，产生失真图像，该失真图像作为训练图像重建任务的输入图像。</p><p>1.首先是使用基于Gamma的变换方式来学习场景内容和亮度信息。过曝图像对于实际场景中较暗区域的细节信息保持的较好，欠曝图像则对实际场景中较亮区域的细节保持的较好，因此希望融合图像在能保持每个区域丰富细节的同时也能让图像的亮度较为统一。所以这里用Gamma变换对源图像的多个子区域进行亮度改变，使编码器能应对不同亮度条件下保持细节和结构信息的能力。</p><p>2.使用基于傅里叶变换的方式在频域学习细节和纹理信息。对一张图像进行离散傅里叶变换DFT后得到的频谱图中，振幅确定图像的强度信息，相位主要确定图像的高级语义，并包含有关图像内容和物体对象位置的信息。欠曝和过曝图像的直方图都不是很居中，所以希望网络能学习到合适的曝光度。而相位则较好地保持了物体的形状和内容信息，所以也需要网络能够捕获形状和内容信息。这一步具体做法是先把源图转换到频域，然后对子区域在频域上进行失真处理，针对振幅采用高斯模糊，针对相位对所有相位值执行np次随机交换，np是在1到5之间的随机正整数。</p><p>3.使用全局shuffle学习结构和语义信息。该方法来源于Kang等人的一篇论文内容，具体做法是：对于待失真处理的每个子区域，在图像中随机选一块和该子区域尺寸相同的子区域，然后将这两个区域调换位置，重复10次就完成了一张源图的全局shuffle失真变换处理。</p><p>彩色图像融合：首先将图像转换为YCbCr通道，Y通道的融合方式和上述方式保持一致，而Cb和Cr的融合使用传统的加权求和方式。</p><h2 id="补充-5.vif-net">补充 5.VIF-Net</h2><p>An Unsupervised Framework for Infrared and Visible Image Fusion(IEEE, 2020)</p><p>图像融合是信息融合的一种，本质就是增强技术，运用多传感器获得的不同数据来提高网络性能。相对于单传感器的数据局限于一种的特性，多传感器能同时利用多种数据的特性，在视频监控、卫星成像、军事上都有很好的发展前景。对于本文来说，可见图像提供了丰富的纹理细节和环境信息，而红外图像则受益于夜间可见性和对高动态区域的抑制。</p><p>图像融合最关键的技术是怎么样能融合（利用）多种数据的优势。往往引入的多种数据是双面性的，所以要抑制不同类型数据带来的干扰。</p><figure><img src="/img/stage2/5_0.png" alt="图像融合基本框架" /><figcaption aria-hidden="true">图像融合基本框架</figcaption></figure><p>上图展示了图像融合的基本操作，将可见光和红外图像同时输入网络中，依次进行特征提取、特征融合、特征重建，最终生成融合图像。中间网络的部分就是作者提出的VIF-Net，全称为Visibleand Infrared image Fusion Network，就是可见光和红外图像融合网络。</p><p>本文提出自适应端到端的无监督深度学习模型VIF-Net，比较新颖的地方是损失函数中使用像素强度来衡量每个源图像局部区域红外温度显著性，然后根据红外信息的显著性程度，决定保留相应模态下源图像局部区域的特征信息，也就是指导网络让融合图像的相应位置的局部区域特征更接近红外温度信息更显著的那张源图像。</p><p>模型结构如下：</p><p><imgsrc="https://pic4.zhimg.com/v2-d9d1296109a12552fc53e38a159e082b_r.jpg" /></p><p>红外图像<span class="math inline">\(I_B\)</span>和可见光图像<spanclass="math inline">\(I_A\)</span>各占一个分支进行特征提取，并且两个支路的卷积层参数是共享的（权重相同以提取相同类型的模式或者说深度特征，同时又可以降低计算复杂度）。C11和C12提取底层特征，具体的卷积层设置情况如下表所示。</p><p><imgsrc="https://pic3.zhimg.com/v2-db54cd9a06573ee90f5d22cac371ffae_r.jpg" /></p><p>得到提取的特征图后，融合方法是直接将两个模态下的特征图在通道维度上拼接，然后将拼接好的特征图继续用卷积层C2~C6进行处理（重建），输出最终的融合图像。假设输入都是单通道的图像，经过前面的特征提取层，由于密集连接的作用，每一层的输出都会与后面所有层的输出直接相连（这里是通道叠加）。这样，可见光通道会输出16+16+16+16=64通道的特征图，两个网络通路会输出128通道的特征图，因此C2特征重建的输入是128个通道。</p><p>损失函数使用了Modified Structural Similarity（MSSIM）和TotalVariation（TV-Norm），用这两项对网络进行无监督训练：</p><p><span class="math display">\[Loss = \lambda L_{SSIM} +L_{TV}\]</span></p><p>SSIM是一种衡量图像结构相似性的算法，结合了图像的亮度、对比度和结构三方面对图像质量进行测量。原本的SSIM公式为：</p><p><span class="math display">\[SSIM(X,Y) = \dfrac{(2\mu _X\mu _Y +C_1)(2\sigma _{XY} + C_2)}{(\mu _X^2 + \mu _Y^2 + C_1)(\sigma _X^2 +\sigma _Y^2 + C_2)}\]</span></p><p>本文模型想要设计一种专门处理红外与可见光融合的结构项损失，ImageNet中曾经指出：亮度在较低分辨率下，不能测量全局亮度一致性，因此局部patch中的亮度信息就不是很重要了，所以本文将SSIM中计算亮度的相似度项去掉了，新的SSIM损失项计算如下：</p><p><span class="math display">\[SSIM_M(X,Y|W) = \dfrac{(2\sigma _{XY} +C)}{(\sigma _X^2 + \sigma _Y^2 + C)}\]</span></p><p>这样就能分别计算融合图像与红外图像、可见光图像的结构相似度了。W代表一个滑动窗口，实际计算时本文通过11×11的滑窗遍历整幅图像就能得到计算结果了。</p><p>对于红外图像的温度显著性，温度越高的目标其像素值也会越大，所以一般用像素强度E(I|W)来衡量红外图像的温度信息。所以作者就产生了这样的想法：用每个滑窗内E(I|W)的大小来指导SSIM的计算。具体的做法是：对于两张源图像A和B，如果A一个滑窗内的像素强度值E(I|W)大于B中该位置对应滑窗内的像素强度值E(I|W)，那么就会认为A在该局部区域内的红外温度信息比B的显著，所以就希望网络多保留一些A的特征信息，也让融合图像的该局部区域和A的该区域更相似。最后提出了下面这种计算损失函数的方式（式中的E(I|W)实际上是计算的是该滑窗内所有像素点值的和，而非MSE或者L2范数这种方式）。</p><p><img src="/img/stage2/5_1.png" /></p><p>除了SSIM项，损失函数还有一个总变分项来保留源图像的边缘信息，去除噪声。TV全称是TotalVariation，译为总体变化，是一种衡量图片噪声的指标。</p><p>理解TV的原理可以参考“专业笔记”栏目中距离度量-范数篇附的链接，传统的TV计算公式为：</p><p><span class="math display">\[R_{V^{\beta}(x)} = \sum\limits_{i,j}\Big((x_{i,j+1} - x_{i,j})^2 + (x_{i+1,j} - x_{i,j})^2\Big)^{\frac{\beta}{2}}\]</span></p><p>其中，<spanclass="math inline">\(x_{i,j}\)</span>代表一个像素，将其与水平方向+1的像素做差的平方，并且与垂直方向+1的像素做差的平方，两者之和开<spanclass="math inline">\(\frac{\beta}{2}\)</span>的次方，如此遍历除最后一行和最后一列之外的所有像素点，就可以计算出TV。如果有噪声，噪声点与其他像素之间的变化会很大，TV会明显变大。如果TV很小，说明相近的像素差值较小甚至为0，图像会比较模糊。</p><p>作者运用下列公式计算<span class="math inline">\(L_{TV}\)</span>：</p><p><span class="math display">\[R(i,j) = I_{A}(i,j) -I_{F}(i,j)\]</span> <span class="math display">\[L_{TV} =\sum\limits_{i,j} (\Vert R(i,j+1) - R(i,j) \Vert_2 + \Vert R(i+1,j) -R(i,j)\Vert_2)\]</span></p><p>上式相当于对可见光图像与融合图像做差分，<spanclass="math inline">\(\beta\)</span>取2。</p><p>总的损失函数是：<span class="math inline">\(Loss = \lambda L_{SSIM} +L_{TV}\)</span>，而这两项的实际差值较大，在100至1000之间。如果SSIM项的值较低，会造成融合图像对比度不高，质量低的结果。TV项的结果如果较低，融合结果会丢失更多可见光图像的细节。所以这里引入<spanclass="math inline">\(\lambda\)</span>来平衡两项。</p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summarize</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献整理 · 脉络篇（一）</title>
    <link href="/2023/12/20/papers2/"/>
    <url>/2023/12/20/papers2/</url>
    
    <content type="html"><![CDATA[<p>声明：本文是根据Visual Information Processing Laboratory (VIPLab)的一位博学多才的博士师兄的知乎专栏内容进行归纳总结的，地址：<ahref="https://zhuanlan.zhihu.com/p/467039982"title="温柔的博士师兄写的文章~">部分基于深度学习的红外与可见光图像融合模型总结</a></p><hr /><h2 id="引言">引言</h2><p>传统方法用于图像融合的一些问题：1.没有完全考虑不同模态图像的特性，使用同种方法对不同模态图像进行特征提取可能不会提取到最有效的信息；2.融合规则是人工设计的简单规则，例如最大值法、平均值法，对于融合结果有限制。</p><p>深度学习方法做融合的优势：1.不同的网络分支可以对不同模态的图像进行特征提取，甚至对同种模态使用不同分支提取多种信息；2.融合策略可以通过学习得到，可不经过人工设计的融合规则获取融合结果。</p><p>近两年做红外-可见光图像融合的深度学习模型也是以下面的模态特点为基础的：&gt;红外图像独有的信息为像素值幅度信息，能够体现温度显著性，温度越高的目标像素值越大；可见光图像独有的信息为纹理细节信息，多数红外图像中模糊的区域在可见光图像中则具有良好的细节，所以一些自监督模型在设计损失函数时针对红外图像的损失项使用的是MSE/L2-norm，保持温度显著性信息，而针对可见光图像使用的是SSIM或者梯度算子，保持细节纹理信息。自监督方法需要设计出合理的指标作为损失函数。</p><p>根据时间来分类，2019年之前基本都是有监督模型或者直接套用预训练模型，2020年开始有自监督和GAN模型出现，整体还是修改网络结构和损失函数，个别模型思考了不同模态信息的保留方式，亦有加入了self-attention机制的融合模型。到了2021年，涌现了很多的深度学习模型，也相应诞生了很多新的处理思路。很多学者开始思考到底在红外与可见光图像融合中该如何定义互补信息、如何计算每种模态下图像具有的互补信息，以及如何有效地融合这些信息？展现在模型上，就有了基于显著性的模型、基于transformer的模型等，不再是简单地修改损失函数和网络结构，不再简单地将红外图像的特有信息定义为像素幅度、可见光图像的特有信息定义为纹理细节。同时，还出现了多任务融合模型，例如将超分和融合一起做的端对端模型CF-Net。任务驱动的融合方法也是一种趋势，如SeAFusion。</p><p>总体来说，红外与可见光图像融合包含有监督模型、无监督/自监督模型、GAN、显著性模型、transformer/self-attention、多任务驱动、不同分辨率下的融合模型、引导滤波辅助的模型等。下面根据年份对其中一部分模型做简单的介绍。</p><h2 id="densefuse">1.DenseFuse</h2><p>A Fusion Approach to Infrared and Visible Images (Transactions onImage Processing, 2018)</p><p>DenseFuse一般认为是第一个使用深度学习模型对红外与可见光图像进行融合的方法，也是一种有监督学习模型。该模型将红外与可见光图像分解为basepart和detail part两部分，其中base part直接用平均法进行融合，detailpart通过一个预训练的VGG网络先进行特征提取，然后使用multi-layers fusionstrategy基于已有特征图得到融合权重图，将权重图和特征图相乘，再和另一模态的结果相加视为融合特征图的结果。</p><p><imgsrc="https://pic1.zhimg.com/v2-1c849a57e96fa6aa833257b9857a9ae4_r.jpg" /></p><p>实现：经过L1-norm和average获得activity levelmap，然后继续基于该activity level map，使用softmax计算final activitylevel map，该结果和两个模态的detail part分别相乘后再相加就是detailpart的融合结果，这一思想与Infrared and Visible Image Fusion using a DeepLearning Framework(International Conference on Pattern Recognition,2018)中的融合策略一致。Base part和detailpart都完成融合后，将这两个结果相加得到最终的融合结果。</p><p>图像分解与重建使用的是预训练过的自编码器，而此前的论文中对图像分解还多用的是传统的变换域分解方法。可以说DenseFuse不再使用传统图像融合的图像分解方法，取而代之的是利用了卷积层最擅长的特征提取能力，一个优势是提取到的特征对不同场景图像的适应性要好。</p><p>模型的训练是以可见光图像作为输入和输出训练得到一个自编码器，编码器中加入了denseconnection，有利于层之间信息的传播。使用的损失函数为MSE和SSIM。训练完成后直接在编码器和解码器之间加入以上提及的特征图融合方法即可。</p><p><imgsrc="https://pic3.zhimg.com/v2-37f40ceff40885e3435b3fd69f6d2cb2_r.jpg" /></p><p>DenseFuse整体思路和2020年很多模型的思路差不多，其实都是用卷积神经网络作为特征提取与重建模块，不过由于DenseFuse在训练自编码器时使用的只有可见光图像，对红外图像的特征提取能力有一定限制，因此针对融合所需要的互补信息的提取能力可能也存在一定的限制。不过相对于传统方法提升较好，尤其是不同场景下融合结果中的伪影较少。</p><h2 id="fusiongan">2.FusionGAN</h2><p>A generative adversarial network for infrared and visible imagefusion (Information Fusion, 2019)</p><p>这是首个使用GAN来融合红外与可见光图像的模型，通过生成器和判别器之间的对抗学习避免人工设计activitylevel和融合规则。其中生成器同时将红外图像与可见光图像作为输入，输出融合图像；判别器将融合图像与可见光图像作为输入，得到一个分类结果，用于区分融合图像与可见光图像。在生成器和判别器的对抗学习过程中，融合图像中保留的可见光信息将逐渐增多。训练完成后，只保留生成器进行图像融合即可。由于可见光图像的纹理细节不能全部都用梯度表示，所以需要用判别器单独调整融合图像中的可见光信息。</p><p>实际训练中的生成器和判别器的平衡不好把握，FusionGAN的融合结果对比度不是很好，红外目标的显著性保留的不是很好。</p><h2 id="nestfuse">3.NestFuse</h2><p>An Infrared and Visible Image Fusion Architecture Based on NestConnection and Spatial/Channel Attention Models (IEEE Transactions onInstrumentation and Measurement, 2020)</p><p>NestFuse可以说是DenseFuse的升级版本，仍然是有监督模型，在第一阶段训练自编码器时用多张可见光图像作为输入输出来训练网络。编码器的结构与DenseFuse没有太大差异，不同之处就是多个卷积层输出的特征图都会进行融合，因此NestFuse是一种多尺度融合模型，对下采样带来的细节损失有一定保护效果。融合模块使用spitalattention和channel attention生成显著图来进行融合，解码器加入了nestconnection，保护编码器提取到的多尺度特征。</p><p><imgsrc="https://pic4.zhimg.com/v2-f85aa4bd3c89c975845e44469f91fe03_r.jpg" /></p><p>训练完成后的融合模块则不需要训练，仍然是传统方法，采用了两个通道的attention：Spitalattention和channelattention分别在同一图像内对不同像素生成显著性和不同特征图之间的通道维度生成显著性。经过spitalattention和channelattention后可以得到两个特征图，直接进行平均法得到融合特征图。</p><p>NestFuse虽然在解码器阶段使用了nestconnection，不过和之前的有监督模型一样，针对模态之间的互补信息提取的较少，并且融合规则仍然是人工设计的方法，不能针对红外与可见光特有的信息进行融合。</p><h2 id="didfuse">4.DIDFuse</h2><p>Deep Image Decomposition for Infrared and Visible Image Fusion(International Joint Conferences on Artificial Intelligence, 2020)</p><p>最早使用深度学习方法的模型，基本都是先用传统方法将输入图像分解为basepart和detailpart，相当于图像中的低频部分和高频部分。DIDFuse则是将深度图像分解方法引入红外与可见光图像融合模型中，在训练阶段通过编码器将图像分解为背景部分和细节部分，测试阶段将红外与可见光图像的背景部分和细节部分分别进行融合后，再送入解码器进行图像重建，得到融合结果。</p><p><imgsrc="https://pic1.zhimg.com/v2-012dfb0a77a6c984a1e948e132475ba0_r.jpg" /></p><p>为了避免细节信息损失，在网络中加入shortconnection，分别将编码器的前两个卷积层输出特征图与解码器后两个卷积层输出的特征图进行直接拼接。编码器输出的背景特征图和细节特征图需要通过训练得到，因此设计了相应的损失函数。损失函数各项包括编码器损失L1（Figure 1(a) <spanclass="math inline">\(L_{total}\)</span>中的前两项）和解码器损失L2（<spanclass="math inline">\(L_{total}\)</span>的后三项）。L1用于图像分解，希望两种模态背景部分相差较小、细节部分相差较大，因此第一项和第二项分别为正、负。经过tanh函数，可以将二者的差距限定在-1到1之间。L2用于图像重建，第三、四项目的是保持源图像和重建图像的像素幅度信息和细节纹理信息，很多2020年的自监督模型都是通过这种损失函数来训练网络的，用的是非常普遍的L2-norm和结构相似度SSIM，分别计算红外源图像与重建图像之间的损失、可见光源图像与重建图像之间的损失。具体形式如下：</p><p><img src="/img/stage2/2_3.png" /></p><p>损失函数最后一项使用梯度算子来保留可见光图像的细节信息。自监督模型在计算纹理细节损失中，使用SSIM和梯度算子很普遍。</p><h2 id="ddcgan">5.DDcGAN</h2><p>A Dual-Discriminator Conditional Generative Adversarial Network forMulti-Resolution Image Fusion (Transactions on Image Processing,2020)</p><p>是2020年的GAN模型之一，融合效果在细节和对比度方面要优于FusionGAN，并且是针对红外图像分辨率低于可见光图像分辨率的情况。模型首先通过训练过的卷积层对分辨率低的红外图像进行上采样到可见光图像的分辨率（也可以将融合与超分一起做，具体的模型看CF-Net），然后生成器对这两张图像进行融合，两个判别器分别针对红外与可见光图像进行判断。损失函数方面和先前模型类似，都是基于保留红外图像像素幅度、可见光图像细节信息的基础上设计的。</p><p><imgsrc="https://pic3.zhimg.com/v2-d38428c0ec444dd44f06c5dbefd48b96_r.jpg" /></p><p>生成器的结构如下图，首先通过反卷积层将红外图像上采样到和可见光图像一样的尺寸（红外图像训练集手动下采样到原图的1/4大小），两张图像在通道维度拼接后送入5个加入denseconnection的编码层，再经过5个常规卷积层就能得到融合图像了。</p><p><imgsrc="https://pic3.zhimg.com/v2-00228a8f61da0bd5fbb9b21a4e33b726_r.jpg" /></p><p>判别器的结构如下图，红外图像和可见光图像各一个判别器。红外图像对应的判别器是从融合图像或红外原输入图像中随机选出一张作为输入，可见光图像对应的判别器是从融合图像或可见光原输入图像中随机选出一张作为输入，它们的输出都是一个代表概率的标量，表示输入图像是真实图像（原图）的概率。</p><p><imgsrc="https://pic2.zhimg.com/v2-e3e41342d77fe025435deb850101f55d_r.jpg" /></p><p>编码器的损失函数是由adversarial loss和content loss组成，其中Contentloss中红外图像的像素幅度计算通过Frobeniusnorm得到，而可见光图像的细节信息通过TV-norm得到。判别器的损失函数用于区分源（原）图像和融合图像，判别器的adversarialloss可以用来计算不同分布之间的Jensen-Shannon差异，因此可以用来判断像素强度和纹理细节分布的真实性并促使融合图像的分布更贴近真实分布。</p><h2 id="fast-uif">6.Fast-UIF</h2><p>Rethinking the Image Fusion: A Fast Unified Image Fusion Networkbased on Proportional Maintenance of Gradient and Intensity (AAAI,2020)</p><p>这是用于通用融合任务的模型，进行不同融合任务时需要调整损失函数中各项的权重。网络整体分为gradientpath和intensitypath两个分支，输入则是不同模态的混合输入，而非先前模型采用的gradient输入可见光图像（细节信息多的模态），intensity输入红外图像（像素幅度信息多的模态），在进行最终的融合前还有预融合模块。</p><p><imgsrc="https://pic1.zhimg.com/v2-bf617fd5154be3c8d0104ed4bf0ef9dc_r.jpg" /></p><p>Gradient path的输入由两张可见光图像和一张红外图像组成，intensitypath的输入由两张红外图像和一张可见光图像组成，也可以根据场景调整两个模态图像的比例。两个分支都是由卷积层组成，不包含下采样步骤，并且各自包含两次通道维度拼接过程和两个预融合模块（pathwisetransferblock），最后每个卷积块的输出都会全部进行一次通道维度的拼接，经过单层卷积后是最终的融合图像。损失函数的设计以像素幅度项与梯度项为主，不同的融合任务调整四个项的权重即可，比如红外与可见光的融合中红外图像包含的幅度信息多，所以计算像素幅度的项：红外对应的那一项权重应该大于可见光的；同理，计算梯度的项：可见光对应的权重应该大于红外的。</p><h2 id="fusiondn-u2fusion">7.FusionDN &amp; U2Fusion</h2><p>FusionDN和U2Fusion的融合思想是一样的，FusionDN作者先发表在AAAI(2020)上，后来作者将改进后的U2Fusion发表在了TPAMI上。</p><p>两篇文章都是对融合过程中每种模态图像信息量的测量与保留方法进行了研究，FusionDN通过已有的图像质量评价模型NR-IQA和熵Entropy的计算来测量每个模态图像的信息量得到权重，而U2Fusion通过FeatureExtraction、Information Measurement、Information PreservationDegree三个模块根据源图像直接得到其相应的信息量权重，作用就相当于FusionDN的NR-IQA和Entropy，其中FeatureExtraction使用的是预训练的VGG-16，在大量数据上预训练过的深度网络可以提取出图像中各类特征。信息权重作用于损失函数。另外，U2Fusion在损失函数中加了EWC(ElasticWeight Consolidation, 可塑权重巩固, <ahref="https://zhuanlan.zhihu.com/p/86365066">点击查看详细解读</a>)这一项，避免网络串行训练数据时遗忘先前的任务内容。融合网络比较简单，将两个输入在通道维度拼接后送入卷积层就OK了。</p><p>详情可以点击以下链接查看：</p><p><a href="https://zhuanlan.zhihu.com/p/467039982"title="温柔的博士师兄写的文章~">红外与可见光图像融合模型总结2.6</a></p><p><a href="https://zhuanlan.zhihu.com/p/397425256"title="这也是博士师兄写的文章哟~">无监督图像融合模型U2Fusion/FusionDN</a></p><h2 id="fusiongan-1">8.FusionGAN++</h2><p>Infrared and visible image fusion via detail preserving adversariallearning (Information Fusion, 2020)</p><p>本文的模型用于改善先前GAN模型带来的细节损失问题，并且加入了针对边缘的保护机制。模型的生成器产生融合图像，然后将融合结果与可见光源图像一起送入判别器，判断融合结果是否来自于可见光图像。当判别器不能区分融合结果与可见光图像时，此时认为融合结果包含了充足的细节信息，通过这种方式就能自动进行细节信息的表示和选择，不再通过人工设计融合规则。边缘保护体现在损失函数中。</p><h2 id="rfn-nest">9.RFN-Nest</h2><p>An end-to-end residual fusion network for infrared and visible images(Information Fusion, 2021)</p><p>RFN-Nest在2020年NestFuse的基础上，将融合模块从人工设计的融合规则变成了用网络进行融合，同时不再是单独用自然图像进行有监督训练，也和很多其他模型类似，加入了自监督学习方法，其中第一阶段训练和NestFuse一样，用大量自然图像训练一个自编码器，而第二阶段训练是RFN-Nest新增加的自监督训练方式，会生成四个用于多尺度融合的RFN(Residualfusionnetwork)模块。相较于其他自监督模型的不同之处是多尺度（很多融合模型为了避免细节损失不会使用任何下采样步骤）和大规模红外-可见光数据集参与了训练。</p><figure><imgsrc="https://pic4.zhimg.com/v2-5ff110ca353056e0f43c189c026d94b3_r.jpg"alt="Framework of proposed RFN-Nest" /><figcaption aria-hidden="true">Framework of proposedRFN-Nest</figcaption></figure><p>首先来说第一阶段训练，编码器和解码器与先前的NestFuse相同，并且第一阶段训练也仍然是用自然图像训练自编码器，采用的是COCO数据集的八万张图像。</p><p>第二阶段是训练四个RFN模块，其实也就是学习融合策略，需要先将编码器和解码器的网络参数都固定（相当于RFN的输入输出固定），然后用自监督方法专门训练该模块的网络。RFN结构如下：</p><figure><imgsrc="https://pic1.zhimg.com/v2-73b9e582ce5b2f0414a8e678879d9dbc_r.jpg"alt="the structure of RFN" /><figcaption aria-hidden="true">the structure of RFN</figcaption></figure><p>两个模态的特征图会分成两个分支，一个分支各自经过单个卷积层后在通道维度拼接，再用后续三个卷积层处理，另一个分支则经过单个卷积层后作为残差连接和另个分支的组合，得到的就是融合特征图。四个RFN模块均为这种结构，在四个尺度上对特征图进行融合。这阶段训练使用的数据集为KAIST数据集，包含八万个红外-可见光图像对。</p><h2 id="cf-net">10.CF-Net</h2><p>Deep Coupled Feedback Network for Exposure Fusion and ImageSuper-Resolution (Transactions on Image Processing, 2021)</p><p>本文提出的CF-Net是将超分和多曝光融合用一个网络做的端对端模型，这种多任务图像融合模型也是综述Imagefusion meets deep learning: A survey andperspective中提出的图像融合趋势。超分辨有利于目标检测的准确度，因此如果把多曝光任务和超分辨率任务一起做，应该也可以提高high-level的任务效果，因此CF-Net也可以认为是任务驱动的融合模型，即未来的发展趋势之一。</p><p>查看详情：<a href="https://zhuanlan.zhihu.com/p/467039982"title="温柔的博士师兄写的文章~">红外与可见光图像融合模型总结3.2</a></p><h2 id="stdfusionnet">11.STDFusionNet</h2><p>An Infrared and Visible Image Fusion Network Based on Salient TargetDetection (Transactions on Instrumentation and Measurement, 2021)</p><p>STDFusionNet是基于显著性目标检测的融合方法，可以保护红外显著性目标的纹理信息和温度信息。首先用mask对红外显著性目标进行标注，然后结合mask设计损失函数来进行提取特征和重建。mask只在训练阶段使用，也就是说本文模型可以隐式完成显著目标检测和关键信息融合。应该说STDFusionNet也考虑了红外与可见光融合的互补信息，只不过人为地将其定义为红外图像的显著目标和可见光图像中的背景纹理的组合。</p><p>网络结构如下图，可以看到网络的输入是完整的图像，只不过在计算损失函数时会用mask对红外图像中的显著性目标单独提出来，将可见光图像的背景区域单独提出来计算相应的损失。两个模态的特征图也是在通道维度拼接后送入图像重建网络中的。</p><p><imgsrc="https://pic2.zhimg.com/v2-f24e7babafa72572dbf86554da7681e5_r.jpg" /></p><p>损失函数：</p><p><img src="/img/stage2/3_4.png" /></p><h2 id="csfsaliency-based">12.CSF(Saliency-based)</h2><p>Classification Saliency-Based Rule for Visible and Infrared ImageFusion (Transactions on Computational Imaging, 2021)</p><p>本文也提出了一种基于显著性分类的融合方法classification saliency-basedfusion method(CSF)，不过和上一个STDFusionNet在图像内选择显著性区域不同，本文的模型是根据多个卷积层输出特征图的可解释性重要性来评估的，这种面向重要性的融合规则有助于保留有价值的特征图，得到的显著性信息就直接作为融合的加权系数。首先使用分类器对两种类型的源图像进行分类，可以测量源图像之的差异信息和独有信息。然后根据每个像素对分类结果的贡献程度计算它的重要性，该重要性将以分类显著图的形式呈现，根据这个分类显著图来融合各个特征图，这种通过预训练过的分类器来自动保留重要特征也是一个新颖的角度。</p><p>整体结构如下图，和其他深度学习模型一样，先提取特征图进行融合，然后对融合特征图进行重建。特征提取和重建都是普通的卷积层，重点就在于融合特征图这部分的设计，也是本文的核心。</p><p><imgsrc="https://pic1.zhimg.com/v2-c96de3a4ab9709d5d838a0bbfff9d628_r.jpg" /></p><p>分类显著性估计（Classification SaliencyEvaluation）：红外与可见光图像融合的一大策略就是将每个模态下图像的重要信息和互补信息提取出来进行融合，因此该融合的关键点就在于特征图每个区域的重要性评估，重要的区域需要被保留，冗余区域需要被压缩。</p><p>一种直观的评价方式是将部分可见光特征图替换为红外特征图，然后观察替换后结果的变化。如果这部分是多余的，在替换之后，重建的图像仍然会看起来像原始的可见光图像。如果不是多余的（这部分包含红外图像中的唯一/关键信息），替换后重建的图像将与红外图像相似。反之亦然。为了量化图像风格，使用一个二分类器测量图像属于任何一种风格的概率。此外，分类器能找到每种风格最明显的特性和不同风格之间最明显的差异，可以比较不同类型的信息并帮助识别重要且值得保留的信息，这种功能对融合很有用处，所以使用分类器来帮助定量设计融合规则。</p><p>上述思想的具体实现方法：以图像对为例进行通道替换。当24张输入的特征图全部都是红外特征图时，该特征图组被判断风格为红外的概率接近1，而将这组中的其中一张特征图替换为可见光图像特征图，再看风格被判断为红外的概率是多少。用这种方法，按照顺序依次将24张特征图的某一张替换为可见光特征图，概率值的变化就可以统计出来了。</p><p><imgsrc="https://pic4.zhimg.com/v2-209f505af521d3b3abeb754e1199295b_r.jpg" /></p><p>上图中有一些位置特征图被替换后，风格被判断为红外的概率大大降低，有的则基本没有下降，可以说那些被替换后概率没有下降太多的特征图，对于分类的贡献就不是很大，也就是说这个位置的特征图对分类没什么作用，即红外和可见光在这个通道位置上对应的特征比较一致，没有较大的区分度。相反地，一些位置的特征图被替换后，风格被判断为红外的概率大大降低，这些位置可以说对分类的贡献较大，红外和可见光在这些位置上的特征差异较大。根据特征图对分类结果的影响，可以评估重要性以反映这些特征图是否包含重要信息，将其称为分类显着性（classificationsaliency），以此作为融合时信息量保留的基础。</p><p>上面所说的是通道维度上的显著性，即channel-wise。在每个特征图上的每个像素也存在显著性差异，即pixel-wise，因此需要综合看待每个特征图上的单个像素对分类器判断为红外或可见光图像中概率较大的那个值的变化，从而计算出每个像素位置上的显著性值，即分类显著性图。</p><p>有了这两个权重图，下一步和先前NestFuse模型一样，每个模态的特征图和权重图相乘再相加即可。</p><p>另外，文中有一段阐述了现有人工设计融合方式的缺陷，写的很好：</p><blockquote><p>The reason why existing fusion rules are rough for fusing features isas follows. Because of the unexplainability and incomprehensibility ofCNNs, the specific characteristics represented in feature maps areunknowable. For instance, some convolution kernels extract brightregions, some extract dark regions while some may extract lines. If thisis the case, the max rule can well preserve the bright regions while theinformation with low brightness will suffer from distortion. Because ofthe unknown and variability, it is difficult to measure the importanceof different regions of feature maps. Thus, it is groundless to design afusion rule by assigning pixel-wise weight maps, which take thepixel-wise importance of feature maps into account. In this case, thelimited choices of fusion rules and their roughness restrict theimprovement of fusion results. Even a well-designed feature extractionway may fail to achieve its optimal performance because of therestriction of the fusion rule.</p></blockquote><h2 id="ganmcc">13.GANMcC</h2><p>A Generative Adversarial Network With Multiclassification Constraintsfor Infrared and Visible Image Fusion (Transactions on Instrumentationand Measurement, 2021)</p><p>以往提起红外与可见光图像，一般都认为红外图像细节差，但是目标显著性好、对比度高，要用像素幅度约束；可见光图像细节好，要用梯度或SSIM约束。GANMcC提出的思想是，红外图的细节不一定就比可见光差，可见光也有可能对比度优于红外图像，而在某些场景下确实如此。</p><p>此外要确保融合图像既有显著的对比度又有丰富的纹理细节，关键是保证源图像的对比度和梯度信息是平衡的，本质上是同时估计两个不同域的分布，GAN可以在无监督情况下更好地估计目标的概率分布，而多分类GAN可以进一步同时拟合多个分布特征，解决这种不平衡的信息融合。</p><p>具体做法是：用一个多分类器作为判别器，可以确定输入是红外图像和可见图像的概率。对于融合图像，在多分类约束下，生成器期望这两个概率都很高，即判别器认为它既是红外图像又是可见光图像；而判别器期望这两个概率同时很小，即判别器判断融合图像既不是红外图像也不是可见光图像。在此过程中，同时约束这两个概率，以确保融合图像在两个类别中的true/false程度相近/相同。经过不断的对抗学习，生成器可以同时拟合红外图像和可见光图像的概率分布，从而产生对比度显著和纹理细节丰富的结果。通过这两种设计的配合，可以生成具有良好视觉效果的融合图像。模型结构如下图所示。</p><p><imgsrc="https://pic2.zhimg.com/v2-33585597ce11890b9fafe430f2d1dba5_r.jpg" /></p><p>输入与上述第6个网络Fast Unified Image FusionNetwork一样，也是两个模态的混合输入，由生成器得到融合图像，判别器输出该融合图像属于红外/可见光的两个概率值，多轮对抗训练后，当两个概率值都比较大的时候，认为互补融合信息达到了平衡。</p><p>生成器的结构如下，其中在拼接特征图时是将两个分支特征图交叉拼接的，目的是为了更好融合信息。</p><p><imgsrc="https://pic3.zhimg.com/v2-d57089ccf6d96ab529bc4849200285d2_r.jpg" /></p><p>因为使用了GAN网络，故损失函数包含content loss和adversarialloss两项，而本文模型的思想是红外图像也有细节信息，可见光图像也有较好的对比度，因此contentloss的设计考虑了辅助信息，也就是红外图像的纹理细节与可见光图像的对比度信息。通过调整每一项损失的权重大小来决定每种信息的保留程度，首先主要信息的权重应该大于辅助信息的权重，并且梯度信息的权重一般要小于像素强度信息的权重。按照这个规则进行权值的设置。</p><p>判别器的结构如下，判别器也是一个多分类器，对输入图像（红外/可见光/融合图像任选一个输入）进行分类得到输入图像的类别，输出是一个包含两个概率值的向量。</p><p><imgsrc="https://pic2.zhimg.com/v2-238205700b307b4261bf2c6f8e5d4489_r.jpg" /></p><p>损失函数必须促使判别器不断提高其判别能力，才能有效地识别出什么是红外图像或可见光图像。损失函数由三项组成，分别为可见光图像、红外图像、融合图像的decisionloss。具体的损失函数设计就不摆在这里了，可以查看作者论文原文或者<ahref="https://zhuanlan.zhihu.com/p/467039982">专栏第3.7中的内容</a>。</p><h2 id="rxdnfuse">14.RXDNFuse</h2><p>A aggregated residual dense network for infrared and visible imagefusion (Information Fusion, 2021)</p><p>RXDNFuse是在融合网络中加入残差连接的模型，对损失函数也有一定的改进，分为像素级损失和特征级损失，像素级损失还是以像素幅度和结构相似度为基础计算的，特征级损失则是以VGG-19提取的深度特征图作为基础。</p><p><imgsrc="https://pic1.zhimg.com/v2-b47d8e450daf3e4754366633b1e034b0_r.jpg" /></p><p>这里知识简单说明文章的中心思想，网络子结构主要是添加了残差连接和密集连接，idea在损失函数方面要更多一点。</p><p>像素级损失的结构损失和像素幅度损失计算如下图，融合图像与红外、可见光源图都会进行像素幅度和SSIM的计算。</p><p><imgsrc="https://pic3.zhimg.com/v2-c401c565fa3a73ce26e5d29951f28faa_r.jpg" /></p><p>特征级损失其实就是perceptualloss，同样也需要分别计算结构损失和像素幅度损失。而使用深度网络特征图来计算损失的原因作者也引用了其他文章中的结论：通过深度神经网络对图像特征进行逐层处理，输入图像会转换为对图像实际内容越来越敏感的抽象表示，如果直接用较浅层的特征图进行重建，其实只是简单地将原始图像的每个像素进行了重现，与之相反的是深层特征可以捕获抽象语义特征。因此这里将每个输入图像复制为三个通道后送入VGG-19模型来提取高级（深层次的）语义特征，如下图所示。</p><p><imgsrc="https://pic3.zhimg.com/v2-2300d01da41d38aebef93d40b4b99dca_r.jpg" /></p><p>感知损失是论文Perceptual Losses for Real-Time Style Transfer andSuper-Resolution中提出的概念，用于实时超分辨任务和风格迁移任务，后来也被应用于更多的领域，如图像去雾。下面是论文的解读和损失函数说明的链接。</p><p><a href="https://zhuanlan.zhihu.com/p/24720434">论文解读</a></p><p><ahref="https://blog.csdn.net/qq_43665602/article/details/127077484">感知损失Perceptualloss</a></p><hr /><p>这篇文章到这里就结束啦！</p><p>本文总结了《部分基于深度学习的红外与可见光图像融合模型总结》3.8及以前的内容，3.9之后的内容和别的文章将在本系列（二）中进行更新，内容涉及：部分传统方法、更新的Paper等，敬请期待~</p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summarize</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像融合</title>
    <link href="/2023/12/16/Review/"/>
    <url>/2023/12/16/Review/</url>
    
    <content type="html"><![CDATA[<h3 id="融合方法分析">融合方法分析</h3><p>下面列了一些相关领域的作者写的文章可供参考：</p><p><ahref="https://cloud.tencent.com/developer/article/2200098">图像融合的方法及分析</a></p><p><ahref="https://zhuanlan.zhihu.com/p/558389374">一文详解50多种多模态图像融合方法</a></p><h4 id="图像融合分类">图像融合分类</h4><p>根据图像表征层次的不同，图像融合可以分为三个层次的融合：像素级融合、特征级融合、决策级融合。</p><p>图像融合的目的：图像增强，提高图像的分辨率和清晰度；增强图像的相关特征；补充相关信息，去除噪声和冗余；提高下游任务的精度和性能等。</p><h4 id="像素级融合">像素级融合</h4><p>直接对单幅图像的像素点进行融合（信息综合）。</p><p>由于原始图像规模很大（一个普通的小低分辨率图像可能都有几十万个像素点），直接处理像素很费时，且传感器采集的数据不经过各种处理可能会影响融合效果，对硬件设施的要求也很高（配准的精度要求），像素信息易受到污染（含有噪声等干扰），融合效果不稳定。</p><h4 id="特征级融合">特征级融合</h4><p>对图像特征进行抽取，将边缘、形状、轮廓、局部特征等信息进行综合处理，再在特征层面进行融合。</p><p>图像的特征是一种代价处理，降低了数据量，保留了大部分的“重要”信息，但是会损失部分细节信息。但是可操作性强，运用各种方法更加灵活多样。</p><h4 id="决策级融合">决策级融合</h4><p>在每种传感器独立完成决策或分类的基础上，将多个传感器的识别结果进行融合做出全局的最优决策。</p><p>需要根据一定的规则对提取特征和识别后的图像进行决策综合，获得融合图像。决策的输入是对目标的认识框架，认识框架是通过传感器观测同一场景目标后经过预处理、特征提取、识别的基本处理后形成的。对改框架通过最优化决策得到融合结果。</p><p>决策级是趋向智能逻辑的，综合多传感器的识别结果比单一识别更精准，但会增加误差和风险（传感器的错误会累加）。</p><p>我个人不是很明白决策级融合是什么意思，我的猜想是决策级融合在传感器采集信息后就进行了融合的初步操作，然后经过综合得到融合结果，不需要像像素级和特征级那样，由自行设计的算法和模型进行特征提取、融合。此外，我发现在有些论文中，像素级融合和特征级融合并没有明确的界限。</p><h3 id="实验">实验</h3><h4 id="对比试验">对比试验</h4><p>与其他SOTA方法进行对比，在多个不同数据集上验证，证明本论文中所述方法的有效性和先进性。</p><p><font color="green">对比指标：</font>各种融合指标、下游高级视觉任务的相关指标、计算效率（轻量化）、视觉效果（可视化）等。</p><h4 id="消融实验">消融实验</h4><p>分别去掉某关键模块（idea），与完整方法的效果进行对比，验证本方法所述模块（策略、模型或算法）的必要性。</p><h4 id="参数实验">参数实验</h4><p>确定模型中神经网络超参数Hyperparameters的最佳配置，并分析这些参数的作用。</p><h4 id="部分指标">部分指标</h4><p><font color="red">1.融合</font></p><ul><li>AP(AveragePrecision)，平均精度，指所有图片中具体某一类P-R曲线下的面积</li><li>mAP(Mean AveragePrecision)，均值平均精度，指所有图片中所有类别的AP的均值，用的较多</li></ul><p><font color="red">2.检测</font></p><ul><li>IoU(Intersection over Union)，交并比，指ground truth bbox与predictbbox交集面积占两者并集面积的比率</li></ul><p>bbox指的是bounding box。IoU越大说明预测框的模型算法性能越好。</p><p><font color="red">3.分类</font></p><p><font color="purple">以二分类为例介绍分类问题的一些常用评估指标。</font></p><p>混淆矩阵Confusion Matrix中的计算单元：</p><ul><li>真正例TP(True Positive)：预测结果为正例，真实结果也为正例</li><li>假正例FP(False Positive)：预测结果为正例，真实结果是反例</li><li>真反例TN(True Negative)：预测结果是反例，真实结果也是反例</li><li>假反例FN(False Negative)：预测结果是反例，真实结果为正例</li></ul><p>总样例数：<span class="math inline">\((Num)_{total} = TP + FP + TN +FN\)</span></p><p>错误率<spanclass="math inline">\(ER\)</span>：被错分的样本数占总样本数的比率：<spanclass="math inline">\(ER =\dfrac{FP+FN}{(Num)_{total}}\)</span>。注：<spanclass="math inline">\(1-ER\)</span>等于精度。</p><p>精确率（Accuracy）：精确率是最常用的分类性能指标，用来表示模型的精度，即模型识别正确的样本数/样本的总个数：<spanclass="math inline">\(Acc = \dfrac{TP+TN}{(Num)_{total}} =1-ER\)</span>。一般情况下，模型的精度越高，效果越好。</p><p>正确率或准确率（Precision）：又称查准率。预测出的正例中，真正的正例（真正例）所占的比率。<spanclass="math inline">\(P = \dfrac{TP}{TP+FP}\)</span>。</p><p>召回率（Recall）：又称查全率、真正例率TPR。预测正确的正例（真正例）占所有真实正例的比率。<spanclass="math inline">\(R = \dfrac{TP}{TP+FN}\)</span>。</p><p><font color="bluepurple">分类报告ClassificationReport，由一些评估指标对模型进行综合评价。指标如下。</font></p><p>Precision、Recall，上面已经介绍过。</p><p>F1-Score，F1分数，对查准率和召回率的综合考虑。查准率和召回率是一对矛盾的指标，一般查准率高时召回率低、召回率高时查准率低。<spanclass="math inline">\(F_1 = \dfrac{2\times P\timesR}{P+R}\)</span>。</p><p>Macro avg，宏平均，所有类别的F1进行简单算术平均。</p><p>Weightedavg，加权平均，所有类别的F1进行加权平均，考虑了各个类别所占的比重。</p><p>P-R曲线，依据Precision与Recall绘制的曲线，能直观显示学习器在样本总体上的查准率<spanclass="math inline">\(P\)</span>和查全率<spanclass="math inline">\(R\)</span>。P-R图纵轴是查全率P，横轴是查准率R，P =R的点是“平衡点” BEP（Break-Even(收支平衡) Point）。</p><p>ROC曲线，全称为“受试者工作特征”。ROC图纵轴是TPR（True PositiveRate，真正例率），横轴是FPR（False PositiveRate，假正例率），能反映学习器对样本学习后预测结果的好坏。曲线下方的面积AUC能反映学习器的整体性能。</p><p>TPR = Sensitivity(灵敏度) = TP / (TP + FN) <br/> FPR = 1 -Specificity = FP / (TN + FP)</p><p>Specificity(特异度) = TN / (TN + FP)</p><blockquote><p>特异性指标，表示模型识别为负类样本的数量占总的负类样本数量的比值。</p></blockquote><h3 id="融合展望">融合展望</h3><p>当前多模态图像融合具有的几个挑战：</p><ol type="1"><li>配准数据构造难。由于镜头畸变、尺度差异、视差以及拍摄位置的影响，输入图像都无法实现严格的空间对齐。现有方法依赖配准的多模态数据进行训练和测试，人工配准空间不对齐的不同模态图像具有较高的人工成本和配准难度。</li><li>复杂的多模态数据。真实场景和环境中，多模态数据复杂多样，具有不确定性、不一致性和数据噪声。现有的图像融合算法大多是基于正常成像场景设计的，极端环境下信息获取不充分，如夜间、雨雾、过曝、欠曝等极端问题需要被重视。</li><li>融合模型的轻量化。图像融合通常作为高层视觉任务的预处理手段或摄影设备的后处理过程，对实时性有一定要求。现有的多模态图像融合模型大多都含有大量的参数，计算量和存储负担大，不利于实时性的需求。在保障融合性能的前提下，开发轻量级的图像融合算法对扩宽图像融合应用场景具有至关重要的作用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献整理 · 开山篇</title>
    <link href="/2023/11/25/Papers/"/>
    <url>/2023/11/25/Papers/</url>
    
    <content type="html"><![CDATA[<h2 id="tardal">TarDAL</h2><h3 id="title">Title</h3><p>Target-aware Dual Adversarial Learning and a Multi-scenarioMulti-modality Benchmark to Fuse Infrared and Visible for ObjectDetection [CVPR] 2022</p><h3 id="motivation">Motivation</h3><p>Previous approaches:</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.Aiming <span class="hljs-built_in">at</span> generating an image of high visual quality<span class="hljs-number">2</span>.<span class="hljs-keyword">Discover </span>commons underlying the two modalities <span class="hljs-keyword">and </span>fuseupon the common space <span class="hljs-keyword">either </span><span class="hljs-keyword">by </span>iterative optimization <span class="hljs-keyword">or </span>deep networks<span class="hljs-number">3</span>.Neglect that modality <span class="hljs-keyword">differences </span>implying the complementary infomationwhich <span class="hljs-keyword">extremely </span>important for <span class="hljs-keyword">both </span>fusion <span class="hljs-keyword">and </span><span class="hljs-keyword">subsequent </span>detection task</code></pre></div><h3 id="intro">Intro</h3><div class="code-wrapper"><pre><code class="hljs maxima">Visible <span class="hljs-built_in">image</span>, provides rich details with high spatial <span class="hljs-built_in">resolution</span>(under welldefined lighting conditions)</code></pre></div><div class="code-wrapper"><pre><code class="hljs sqf">Infrared <span class="hljs-built_in">image</span>, capturing ambient temperature variations emitted <span class="hljs-keyword">from</span> objects, highlight structures of thermal <span class="hljs-built_in">targets</span> (insensive <span class="hljs-keyword">to</span> lighting changes)</code></pre></div><p>Their evident appearance discrepancy, it's challenging to fusevisually appealing images and/or to support higher-level vision tasks(by making full use of the complementary info from the infrared andvisible images)</p><p>The fusion emphasizes more on "seeking commons" but neglect thedifferences of these two modalities on presenting structure info oftargets and textural details of ambient background.</p><h3 id="method">Method</h3><p>Fusion network:</p><div class="code-wrapper"><pre><code class="hljs mipsasm">Composed of one generator <span class="hljs-keyword">and </span>two target-aware <span class="hljs-keyword">discriminators, </span><span class="hljs-keyword">and </span>a commonly used detection network  [Detection-<span class="hljs-keyword">oriented </span>fusion]<span class="hljs-symbol"></span><span class="hljs-symbol">Discriminator:</span><span class="hljs-keyword">Distinguishes </span>foreground(structure infomation of targets), i.e., thermal targets(infrared image), <span class="hljs-keyword">and </span><span class="hljs-keyword">differentiates</span><span class="hljs-keyword"></span>the <span class="hljs-keyword">background, </span>i.e., textural details(visible image)Derive a cooperative training <span class="hljs-keyword">scheme</span></code></pre></div><h3 id="structure-diagram">Structure diagram</h3><figure><img src="/img/stage1/11.png"alt="Methodology framework: (a) bilevel optimization formulation for fusion and detection, (b) target-aware adversarial dual learning network for fusion, and (c) cooperative training scheme." /><figcaption aria-hidden="true">Methodology framework: (a) bileveloptimization formulation for fusion and detection, (b) target-awareadversarial dual learning network for fusion, and (c) cooperativetraining scheme.</figcaption></figure><figure><img src="/img/stage1/12.png" alt="The details of network" /><figcaption aria-hidden="true">The details of network</figcaption></figure><figure><img src="/img/stage1/13.png"alt="The architectures of generator and discriminator" /><figcaption aria-hidden="true">The architectures of generator anddiscriminator</figcaption></figure><h3 id="loss-function">Loss function</h3><p>Detection network backbone: YOLOv5</p><p>Generator: 1.Structural similarity index (SSIM)</p><blockquote><p>Contributes to generate a fused image that preserves overallstructures and maintains a similar intensity distribution as sourceimages.</p></blockquote><figure><img src="/img/stage1/14.png" alt="Generator loss SSIM" /><figcaption aria-hidden="true">Generator loss SSIM</figcaption></figure><p>2.Pixel loss (based on the saliency degree weight (SDW))</p><blockquote><p>To balance the pixel intensity distribution of source images</p></blockquote><p><img src="/img/stage1/15.png" alt="Pixel Loss" /> w1, w2 arecalculated by saliency value of x and y.</p><p>Target and detail discriminators: Wasserstein divergence (with targetmask m)</p><blockquote><p>The target discriminator <span class="math inline">\(D_T\)</span> isused to distinguish the foreground thermal targets of fused result tothe infrared while the detail discriminator <spanclass="math inline">\(D_D\)</span> contributes to distinguish thebackground details of fused result to the visible.</p></blockquote><figure><img src="/img/stage1/16.png" alt="Discriminator loss" /><figcaption aria-hidden="true">Discriminator loss</figcaption></figure><h2 id="seafusion">SeAFusion</h2><h3 id="title-1">Title</h3><p>Image fusion in the loop of high-level vision tasks: A semantic-awarereal-time infrared and visible image fusion network [Image Fusion]2022</p><h3 id="intro-1">Intro</h3><p>The infrared sensor captures thermal radiation emitted from objects,which could highlight salient targets, but the infrared image neglectstexture and is vulnerable to noise.</p><p>The visible sensor captures reflective light infomation, the visibleimage usually contains abundant texture and structure info, but issensitive to the environment, such as illumination and occlusion.</p><p>Complementary info: to fuse Ir and Vis image, to generate a desiredimage.</p><p>Fused image has been broadly used as a preprocessing module forhigh-level vision tasks, e.g., object detection, tracking, semanticsegmentation.</p><h3 id="motivation-1">Motivation</h3><p>Pressing challenges:</p><div class="code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span>The existing fusion algorithms are inclined <span class="hljs-built_in">to</span> pursue better visual quality<span class="hljs-keyword">and</span> higher evaluation metrics but seldom systematically considerwhether fused image can facilitate high-level vision tasksSome studies: cannot effectively enhance/boost <span class="hljs-keyword">the</span> semantic info <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> fused image<span class="hljs-number">2.</span>Neither visual comparison nor quantitative evaluation (evaluation manners)reflects <span class="hljs-keyword">the</span> facilitation <span class="hljs-keyword">of</span> fused images <span class="hljs-keyword">for</span> high-level vision tasks<span class="hljs-number">3.</span>Not <span class="hljs-keyword">effective</span> <span class="hljs-keyword">in</span> extracting fine-grained detail features<span class="hljs-number">4.</span>Ignore <span class="hljs-keyword">the</span> demand <span class="hljs-keyword">for</span> real-<span class="hljs-built_in">time</span> image fusion</code></pre></div><p>Ours network:</p><p>SeAFusion, can be used for achieving real-time Ir &amp; Vis imagefusion</p><h3 id="method-1">Method</h3><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>Simultaneously obtaining superior performance <span class="hljs-keyword">in</span><span class="hljs-keyword">both</span> image fusion <span class="hljs-keyword">and</span> high-<span class="hljs-keyword">level</span> vision tasks.<span class="hljs-number">2.</span>A segmentation network <span class="hljs-keyword">to</span> predict the segmentation results<span class="hljs-keyword">on</span> fused images, which <span class="hljs-keyword">is</span> utilized <span class="hljs-keyword">to</span> construct semantic loss(<span class="hljs-keyword">is</span> leveraged <span class="hljs-keyword">to</span> guide the training <span class="hljs-keyword">of</span> the fusion network via back-propagation, so the loss can flow back <span class="hljs-keyword">to</span> the image fusion module<span class="hljs-keyword">to</span> forcing fused images <span class="hljs-keyword">to</span> contain more semantic infomation).<span class="hljs-number">3.</span><span class="hljs-type">Real</span>-<span class="hljs-type">time</span>: light-weight network based <span class="hljs-keyword">on</span> GRDB (gradient residual dense block)<span class="hljs-keyword">to</span> boost the description ability <span class="hljs-keyword">for</span> fine-grained details <span class="hljs-keyword">and</span> achieve feature reuse.<span class="hljs-number">4.</span>The authors proposed a joint low-<span class="hljs-keyword">level</span> <span class="hljs-keyword">and</span> high-<span class="hljs-keyword">level</span> adaptive training strategy<span class="hljs-keyword">to</span> achieve simultaneously impressive performance <span class="hljs-keyword">in</span> <span class="hljs-keyword">both</span>image fusion <span class="hljs-keyword">and</span> various high-<span class="hljs-keyword">level</span> vision tasks.</code></pre></div><h3 id="structure-diagram-1">Structure diagram</h3><figure><img src="/img/stage1/21.png"alt="The overall framework of the proposed semantic-aware infrared and visible image fusion algorithm." /><figcaption aria-hidden="true">The overall framework of the proposedsemantic-aware infrared and visible image fusion algorithm.</figcaption></figure><figure><img src="/img/stage1/22.png"alt="The architecture of the real-time infrared and visible image fusion network based on gradient residual dense block." /><figcaption aria-hidden="true">The architecture of the real-timeinfrared and visible image fusion network based on gradient residualdense block.</figcaption></figure><figure><img src="/img/stage1/23.png"alt="The specific devise of the gradient residual dense block. The Sobel operator is selected as the Gradient Operator to extract fine-grained detail information of feature maps." /><figcaption aria-hidden="true">The specific devise of the gradientresidual dense block. The Sobel operator is selected as the GradientOperator to extract fine-grained detail information of featuremaps.</figcaption></figure><h3 id="分析">分析</h3><figure><img src="/img/stage1/24.png" alt="Analysis1: fusion network" /><figcaption aria-hidden="true">Analysis1: fusion network</figcaption></figure><figure><img src="/img/stage1/25.png" alt="Analysis2: segmentation module" /><figcaption aria-hidden="true">Analysis2: segmentationmodule</figcaption></figure><figure><img src="/img/stage1/26.png" alt="Algorithm" /><figcaption aria-hidden="true">Algorithm</figcaption></figure><p>注：分割网络的backbone采用YOLOv5网络</p><h2 id="segmif">SegMiF</h2><h3 id="title-2">Title</h3><p>Multi-interactive Feature Learning and a Full-time Multi-modalityBenchmark for Image Fusion and Segmentation [ICCV] 2023</p><h3 id="abstract">Abstract</h3><p>Early efforts boost performance for only one task.</p><p>This paper, SegMiF can dual-task correlation to promote theperformance of both tasks (fusion and segmentation).</p><h3 id="intro-2">Intro</h3><p>Contributions:</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-number">1.</span>SegMiF <span class="hljs-keyword">contains</span> two modules, i.e., <span class="hljs-keyword">fusion</span> network<span class="hljs-keyword">and</span> common segmentation network.<span class="hljs-number">2.</span>Hierarchical interactive attention (HIA) block. Fine<span class="hljs-operator">-</span>grained mapping <span class="hljs-keyword">of</span> <span class="hljs-keyword">all</span> the vital infomation <span class="hljs-keyword">between</span> <span class="hljs-keyword">fusion</span> <span class="hljs-keyword">and</span> segmentation. Modality<span class="hljs-operator">-</span><span class="hljs-operator">/</span>Semantic<span class="hljs-operator">-</span> oriented features can be fully mutual<span class="hljs-operator">-</span>interactive(bridge the feature gap <span class="hljs-keyword">between</span> <span class="hljs-keyword">fusion</span> <span class="hljs-keyword">and</span> segmentation).<span class="hljs-number">3.</span><span class="hljs-keyword">Dynamic</span> weight factor, automatically adjust the <span class="hljs-keyword">corresponding</span> weights<span class="hljs-keyword">of</span> <span class="hljs-keyword">each</span> task (optimal parameters).<span class="hljs-number">4.</span>Interactive feature training scheme.<span class="hljs-number">5.</span>Construct an imaging <span class="hljs-keyword">system</span> (benchmark).</code></pre></div><h3 id="structure-diagram-2">Structure diagram</h3><figure><img src="/img/stage1/31.png"alt="Workflow of the proposed SegMiF. The left part depicts the latent interactive relationship between image fusion and segmentation. The middle part plots the concrete architecture of the SegMiF. The right part details the components of proposed hierarchical interactive attention." /><figcaption aria-hidden="true">Workflow of the proposed SegMiF. The leftpart depicts the latent interactive relationship between image fusionand segmentation. The middle part plots the concrete architecture of theSegMiF. The right part details the components of proposed hierarchicalinteractive attention.</figcaption></figure><figure><img src="/img/stage1/32.png" alt="Partial zoom" /><figcaption aria-hidden="true">Partial zoom</figcaption></figure><h3 id="分析-1">分析</h3><figure><img src="/img/stage1/33.png" alt="Fusion network and DRDB module" /><figcaption aria-hidden="true">Fusion network and DRDBmodule</figcaption></figure><p><img src="/img/stage1/34.png"alt="Detailed architectures of SoAM and MoAM" />注：分割网络是论文[SegFormer: Simple and Efficient Design for SemanticSegmentation with Transformers]的内容</p><p>分割网络： <img src="/img/stage1/36.png"alt="Segmentation network" /></p><h4 id="hia">HIA</h4><p>1.SoAM (Semantic-oriented attention module)</p><blockquote><p>SoAM utilizes the token <spanclass="math inline">\(F_{seg}^{s}\)</span> to generate the query <spanclass="math inline">\(Q_s\)</span>, which represents the inhere semanticinformation that needs to be enhanced.</p></blockquote><blockquote><p>The global context representation of each can be calculated by as<span class="math inline">\(K_{ir}^{T}\cdot V_{ir} (G_{ir})\)</span> and<span class="math inline">\(K_{vis}^{T}\cdot V_{vis} (G_{vis})\)</span>, 其中K, V ∈ {<span class="math inline">\(F_{ir}^{s}\)</span>, <spanclass="math inline">\(F_{vis}^{s}\)</span>}</p></blockquote><p><span class="math inline">\(S_{ir} = Q_s\cdot G_{ir}\)</span>, <spanclass="math inline">\(S_{vis} = Q_s\cdot G_{vis}\)</span></p><blockquote><p>SoAM to provide more semantic attention for the modality feature.</p></blockquote><p>2.MoAM (Modality-oriented attention module)</p><blockquote><p>MoAM introduce two modality queries <spanclass="math inline">\(Q_{ir}\)</span> and <spanclass="math inline">\(Q_{vis}\)</span> ∈ {<spanclass="math inline">\(F_{ir}^{m}\)</span>, <spanclass="math inline">\(F_{vis}^{m}\)</span>}</p></blockquote><blockquote><p>The global context of segmentation <spanclass="math inline">\(G_s\)</span> by <spanclass="math inline">\(K_{s}^{T}\cdot V_s\)</span></p></blockquote><p><span class="math inline">\(M_{ir} = Q_{ir}\cdot G_s\)</span>, <spanclass="math inline">\(M_{vis} = Q_{vis}\cdot G_s\)</span></p><blockquote><p>MoAM to investigate the significant feature from semanticcontexts.</p></blockquote><h4 id="目标函数">目标函数</h4><figure><img src="/img/stage1/35.png" alt="Joint formulation" /><figcaption aria-hidden="true">Joint formulation</figcaption></figure><p>损失函数： <img src="/img/stage1/37.png" alt="Loss" /></p><div class="code-wrapper"><pre><code class="hljs armasm">损失函数中涉及了两个常用的概念：结构相似度、显著性图<span class="hljs-number">1</span>.结构相似度SSIM主要用来衡量两幅图亮度、对比度和结构的相似性  详见<span class="hljs-string">&quot;专业笔记&quot;</span>中所述<span class="hljs-number">2</span>.显著性图主要用来计算MSE损失中的显著性参数m  源自论文: Infrared <span class="hljs-keyword">and</span> visible image fusion based on visual saliency <span class="hljs-meta">map</span>            <span class="hljs-keyword">and</span> weighted least square optimization</code></pre></div><h2 id="相关内容">相关内容</h2><div class="code-wrapper"><pre><code class="hljs mathematica">当<span class="hljs-variable">CNN</span>层数变深时，输出到输入的路径就会变得很长。梯度反向传播，到达输入层可能就会消失。<span class="hljs-variable">DenseNet</span>是一种深度卷积神经网络，引入密集连接（<span class="hljs-variable">Dense</span> <span class="hljs-variable">Connection</span>）将前面所有层与后面的层建立密集连接。与<span class="hljs-variable">ResNet</span>的关键区别是，<span class="hljs-variable">ResNet</span>是简单相加，<span class="hljs-variable">DenseNet</span>是进行连接。<span class="hljs-variable">DenseNet</span>通过基本构建单元<span class="hljs-variable">Dense</span> <span class="hljs-built_in">Block</span>实现稠密连接对特征进行重用，实现信息共享，并能增强梯度流动，避免梯度消失。过渡层（<span class="hljs-variable">Transition</span> <span class="hljs-variable">Layer</span>）控制通道数（稠密块会带来通道数的增加），防止模型过于复杂。<span class="hljs-variable">DenseNet</span>在模型精度和泛化能力上通常表现优异，训练更稳定，但结构仍比较复杂，需要消耗较多的计算资源和时间，内存占用大。<span class="hljs-variable">ResNet</span>（<span class="hljs-variable">Residual</span> <span class="hljs-variable">Neural</span> <span class="hljs-variable">Network</span>）是基于残差学习框架的神经网络，其在前向网络中增加了一些快捷连接<span class="hljs-variable">Shortcut</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Short</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">Connection</span><span class="hljs-operator">/</span><span class="hljs-built_in">Skip</span> <span class="hljs-variable">Connection</span>，这些连接会跳过某些层，将数据直接传到之后的层。<span class="hljs-variable">ResNet</span>对网络深度增加带来的梯度消失或爆炸、网络退化（由于训练和测试误差的积累导致正确率趋于饱和甚至下降，与过拟合（训练误差小，测试误差大，泛化能力差）不同）等问题具有一定的作用，增加了非线性，一定程度上抑制了语义间隙的影响，但模型表现可能略逊一筹。残差块（<span class="hljs-variable">Residual</span> <span class="hljs-built_in">Block</span>）是<span class="hljs-variable">ResNet</span>的基本组成成分。</code></pre></div><div class="code-wrapper"><pre><code class="hljs arcade">空洞卷积（Dilated/Atrous Convolution）可以增加卷积核的尺寸，如原本<span class="hljs-number">3</span>*<span class="hljs-number">3</span>的卷积核可以扩充至<span class="hljs-number">5</span>*<span class="hljs-number">5</span>，但有效的参数个数不变，仍为<span class="hljs-number">9</span>个，剩余的位置不予考虑（空洞/零），利用超参数“扩张率”来定义卷积核处理数据时各值的间距（可以理解为空洞数），在扩大了感受野的同时，避免了Pooling操作，从而保持分辨率不变。PS：正常扩大感受野会带来计算量的增加，后面进行池化的降采样处理可以降低计算量，但是空间分辨率也随之降低了。感受野（Receptive Field）越大，捕获的图像区域越大，对图像全局的特征提取能力也就越强。而且对于目标检测任务而言，最后一层特征图（<span class="hljs-built_in">Feature</span> <span class="hljs-built_in">Map</span>）的感受野大小要大于等于输入图像大小，否则分类性能会不理想。一般而言，感受野越大、网络越深，对复杂问题求解的模型性能越好。</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summarize</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>专业笔记</title>
    <link href="/2023/11/25/Professional/"/>
    <url>/2023/11/25/Professional/</url>
    
    <content type="html"><![CDATA[<h3 id="terminology-index">Terminology Index</h3><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">IQA</span>：图像质量评价，<span class="hljs-variable">image</span> <span class="hljs-variable">quality</span> <span class="hljs-variable">assessment</span>上游任务，预训练模型，对应 <span class="hljs-variable">low</span><span class="hljs-operator">-</span><span class="hljs-variable">level</span> <span class="hljs-variable">task</span>；下游任务，具体的 <span class="hljs-variable">task</span>，对应 <span class="hljs-variable">high</span><span class="hljs-operator">-</span><span class="hljs-variable">level</span> <span class="hljs-variable">task</span><span class="hljs-variable">Ablation</span> <span class="hljs-variable">study</span>：消融实验，移除 <span class="hljs-variable">Model</span> 的部分<span class="hljs-string">&quot;feature&quot;</span>（控制变量法），对比研究模型的性能<span class="hljs-variable">FPS</span>：每秒传输帧数，<span class="hljs-variable">frames</span> <span class="hljs-variable">per</span> <span class="hljs-variable">second</span><span class="hljs-built_in">Fine</span><span class="hljs-operator">-</span><span class="hljs-variable">tune</span>：微调，<span class="hljs-built_in">Fine</span> <span class="hljs-variable">tune</span> <span class="hljs-variable">a</span> <span class="hljs-variable">network</span><span class="hljs-variable">Ground</span> <span class="hljs-variable">truth</span>：真实值<span class="hljs-variable">Feature</span> <span class="hljs-variable">map</span>：特征图，一般指<span class="hljs-variable">CNN</span>中卷积层的输出<span class="hljs-variable">Pipline</span>：流水线，论文中用其表示（翻译）方法<span class="hljs-variable">or</span>模型的框架<span class="hljs-variable">SOTA</span>：<span class="hljs-variable">State</span><span class="hljs-operator">-</span><span class="hljs-variable">of</span><span class="hljs-operator">-</span><span class="hljs-variable">the</span><span class="hljs-operator">-</span><span class="hljs-variable">art</span>，译为：最先进的、最高水平<span class="hljs-built_in">Off</span><span class="hljs-operator">-</span><span class="hljs-variable">the</span><span class="hljs-operator">-</span><span class="hljs-variable">shelf</span>：译作：现成的、已经实现过的<span class="hljs-variable">Without</span> <span class="hljs-variable">bells</span> <span class="hljs-variable">and</span> <span class="hljs-variable">whistles</span>：表示没有花里胡哨的东西<span class="hljs-operator">/</span>方法<span class="hljs-variable">Warm</span> <span class="hljs-variable">up</span>：热身，由于网络初始化的参数一般是随机的，故用一个小的学习率先训练几个<span class="hljs-variable">epoch</span>，防止一开始使用较大的学习率不稳定光谱（<span class="hljs-variable">Spectrum</span>）：复色光经过分光成为单色光，经成像系统得到按波长或者频率依次排列的光学图像多光谱（<span class="hljs-variable">Multispectrum</span>）：同时获取多个光学频谱波段（大于<span class="hljs-number">3</span>个），在可见光基础上向红外、紫外两个方向扩展高光谱（<span class="hljs-variable">Hyperspectrum</span>）：包含成百上千的波段，可以捕获和分析一片空间区域内“逐点”的光谱<span class="hljs-variable">Embedding</span>：在深度学习中利用线性或非线性转换，对复杂的数据进行自动特征抽取，并将其<span class="hljs-variable">features</span>表示为向量形式，以便于输入到网络中进行处理。这个过程被称之为<span class="hljs-string">&quot;Embedding&quot;</span><span class="hljs-variable">BN</span><span class="hljs-punctuation">(</span><span class="hljs-variable">Batch</span> <span class="hljs-variable">Normalization</span><span class="hljs-punctuation">)</span>：像深度学习模型输入数据时，要对<span class="hljs-variable">data</span>进行归一化操作，如均值为<span class="hljs-number">0</span>、方差为<span class="hljs-number">1</span>的规范化处理，否则过大的特征会“淹没”小特征。这种情况不仅会在输入模型时出现，也会在层与层中存在，因为随着数据的逐级传播，经过损失函数（如<span class="hljs-variable">Softmax</span>）后会使得特征之间的差异变大，逐渐累积会对最终结果造成较大的影响。所以需要对层间数据也进行规范化，<span class="hljs-variable">BN</span>就是在两个隐藏层之间对数据在<span class="hljs-variable">Batch</span>方向进行<span class="hljs-built_in">Norm</span>处理，并且最后加入了<span class="hljs-built_in">Scale</span> <span class="hljs-variable">and</span> <span class="hljs-variable">Shift</span>操作，以提高网络对<span class="hljs-built_in">Norm</span>的学习能力。<span class="hljs-variable">LN</span><span class="hljs-punctuation">(</span><span class="hljs-variable">Layer</span> <span class="hljs-variable">Normalization</span><span class="hljs-punctuation">)</span>：与<span class="hljs-variable">BN</span>不同之处在于，<span class="hljs-variable">LN</span>是在数据的<span class="hljs-variable">Channel</span>方向进行<span class="hljs-built_in">Norm</span>归一化操作。<span class="hljs-variable">BN</span>是对一个<span class="hljs-variable">batch</span>的数据的对应位置上所有的<span class="hljs-variable">feature</span>进行归一化，而<span class="hljs-variable">LN</span>是对每个<span class="hljs-variable">sample</span>进行归一化。在三维视觉任务的情形下，可以理解为：<span class="hljs-variable">BN</span>对每一张图片对应位置的像素做<span class="hljs-built_in">Norm</span>处理，<span class="hljs-variable">LN</span>则是对单幅图像的整体做<span class="hljs-built_in">Norm</span>。但通常在数据传入<span class="hljs-variable">Model</span>前会进行数据的归一化处理，因此通常不会再使用<span class="hljs-variable">LN</span>。</code></pre></div><p>下面附上朋友博客的两张关于BN和LN的图，链接：<ahref="https://emil-jiang.github.io"class="uri">https://emil-jiang.github.io</a></p><p><img src="/img/stage1/bn.png" alt="Batch Norm" /> <imgsrc="/img/stage1/ln.png" alt="Layer Norm" /></p><p><font size=4 color="blue">深度学习基本术语（补充）：</font></p><p>Batch：批，指使用训练集中的一小部分样本对模型权重进行一次反向传播的参数更新，这一小部分样本被称为“一批数据”，即一个batch。</p><p>Epoch：时代、纪元，使用训练集的全部数据对模型进行一次完整训练（前向计算+反向传播），称之为“<strong>一代</strong>训练”，即一个epoch。</p><p>Iteration：迭代，使用一个batch的数据对模型进行一次参数更新的过程，被称为“<strong>一次</strong>训练”，即一次iteration。</p><blockquote><p>换算关系：Number of Batches = TrainingSet Size <spanclass="math inline">\(\div\)</span> Batch Size.</p></blockquote><p>如CIFAR10数据集有50000张训练图片，10000张测试图片。现在选择Batch_size= 256对模型进行训练。则：</p><ul><li>每个epoch要训练的图片数量：50000</li><li>训练集具有的batch个数：50000 / 256 = 195 (余80) + 1 = 196</li><li>每个epoch需要完成的batch个数：196</li><li>每个epoch具有的iteration个数：196</li><li>每个epoch中模型权重更新的次数：196</li><li>训练10代后，模型权重更新的次数：196 <spanclass="math inline">\(\times\)</span> 10 = 1960</li><li>最后一批数据（batch）的样本数：80</li><li>每一代训练（epoch）用的都是同一训练集的数据，但对模型的更新不同</li></ul><p>迭代次数与epoch数密切相关。随着epoch数量的增加，权重更新迭代的次数增多，模型会由欠拟合（underfitting）状态，逐渐过渡到正常拟合状态，最后到达过拟合（overfitting）状态。epoch的设置一般与数据集的多样化程度有关，数据多样化程度越高，epoch越大。</p><p>论文中常见的缩写符号：</p><div class="code-wrapper"><pre><code class="hljs applescript">w/ : <span class="hljs-keyword">with</span>（有），一般在消融实验的图表中，进行对照w/o : <span class="hljs-keyword">without</span>（没有），一般在消融实验的图表中，进行对照w.r.t : <span class="hljs-keyword">with</span> respect <span class="hljs-keyword">to</span>的缩写，是“关于、谈及”的意思i.e. : [<span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span>, <span class="hljs-keyword">in</span> other <span class="hljs-built_in">words</span>] 源自拉丁语，译为：也就是、即etc. : [<span class="hljs-keyword">and</span> so forth, <span class="hljs-keyword">and</span> others, <span class="hljs-keyword">and</span> other things, <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">rest</span>, <span class="hljs-keyword">and</span> so <span class="hljs-keyword">on</span>, <span class="hljs-keyword">and</span> such,      <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> like] et cetera的缩写，可追溯至拉丁语，意思是“等等”，用于列举事物的末尾s.t. : subject <span class="hljs-keyword">to</span>的简写，译为：受...的约束e.g. : [<span class="hljs-keyword">for</span> example, <span class="hljs-keyword">for</span> instance, such <span class="hljs-keyword">as</span>]      源自拉丁语，英译：<span class="hljs-keyword">for</span> example / <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> sake <span class="hljs-keyword">of</span> example，中译：举个例子、例如cf. : 衍生自拉丁语，类似于<span class="hljs-keyword">reference</span>，表示“比较、查阅、参考”之意et al. : [<span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> others, <span class="hljs-keyword">and</span> co-workers] 也是“等等”的意思，多用于人物之后vanilla : 原意为“香草、香草味的”，引申含义是“普通的、原始的”，或“毫无特色的”viz. : vidilicet, 译：即、就是。要把其前面的单词所包含的项目全部罗列出来才用这个缩写，      与上述缩写词写法（<span class="hljs-string">&quot;i.e.,&quot;</span>、<span class="hljs-string">&quot;e.g.,&quot;</span>等）不同，其后面不用逗号。      同：namely, <span class="hljs-keyword">to</span> wit, <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">say</span>, more precisely, more particularly, etc.</code></pre></div><h3 id="距离度量">距离度量</h3><div class="code-wrapper"><pre><code class="hljs arcade">欧氏距离（Euclidean <span class="hljs-built_in">Distance</span>）：两点连线长度城区距离（曼哈顿距离，Manhattan <span class="hljs-built_in">Distance</span>）：直角移动距离，不涉及对角线棋盘距离（切比雪夫距离，Chebyshev <span class="hljs-built_in">Distance</span>）：沿某个轴的距离最大值汉明距离（Hamming <span class="hljs-built_in">Distance</span>）：比较两等长二进制串不同值的个数余弦相似度（Cosine Similarity）：两向量夹角余弦表示距离，与内积有关</code></pre></div><p>范数：</p><p>1.Norm of vector:</p><figure><img src="/img/stage2/norm_vector.png" alt="向量的范数" /><figcaption aria-hidden="true">向量的范数</figcaption></figure><p>2.Norm of matrix:</p><p>若 <span class="math inline">\(A = (a_{ij})_{m \times n}\)</span>，则矩阵的诱导范数（算子范数）为：</p><p>p-范数：<span class="math inline">\(\Vert A \Vert _p =\mathop{max}\limits_{x \neq 0} \frac{\Vert Ax \Vert _p}{\Vert x \Vert_p}\)</span></p><p>L1范数（列和的最大值）：<span class="math inline">\(\Vert A \Vert_1 =\mathop{max}\limits_{1\le j \le n} \sum\limits_{i=1}^{m} \vert a_{ij}\vert\)</span></p><p>无穷范数（行和的最大值）：<span class="math inline">\(\Vert A\Vert_\infty = \mathop{max}\limits_{1\le i \le m} \sum\limits_{j=1}^{n}\vert a_{ij} \vert\)</span></p><p>L2范数（谱范数，当A为方阵时）：<span class="math inline">\(\Vert A\Vert_2 = \sqrt{\lambda_{max} (A^TA)}\)</span></p><p>矩阵<span class="math inline">\(A_{m \timesn}\)</span>的元范数（元素p-范数）：<span class="math inline">\(\Vert A\Vert _p = (\sum\limits_{i=1}^{m} \sum\limits_{j=1}^{n} \vert a_{ij}\vert ^p)^{\frac{1}{p}}\)</span></p><p>注：不要把矩阵元 p-范数与诱导 p-范数混淆。</p><p>对p = 2的元范数，称为弗罗贝尼乌斯范数（Frobeniusnorm）或希尔伯特-施密特范数（Hilbert–Schmidtnorm），不过后面这个术语通常只用于希尔伯特空间。Frobenius-norm可用不同的方式定义：<span class="math display">\[ \Vert A \Vert _F =\sqrt{\sum\limits_{i=1}^{m} \sum\limits_{j=1}^{n} \vert a_{ij} \vert ^2}= \sqrt{trace(A^{*} \cdot A)} = \sqrt{\sum\limits_{i=1}^{min\{m,n\}}\sigma _i^2} \]</span> 其中<spanclass="math inline">\(A^{*}\)</span>是<spanclass="math inline">\(A\)</span>的共轭转置，<spanclass="math inline">\(\sigma _i\)</span>是<spanclass="math inline">\(A\)</span>的奇异值，<spanclass="math inline">\(trace()\)</span>是迹函数。</p><p>Schaten范数出现于当元p-范数应用于一个矩阵的奇异值向量时。如果奇异值记做<spanclass="math inline">\(\sigma _i\)</span>，则Schatten p-范数定义为：<span class="math display">\[ \Vert A \Vert _F =\bigg(\sum\limits_{i=1}^{min\{m,n\}} \sigma _i^p \bigg)^{\frac{1}{p}}\]</span></p><p>TV范数：Total Variation，一种常用的正则项（距离度量），参考文章：<ahref="https://www.zhihu.com/question/47162419">如何理解全变分Distance</a></p><p>范数的等价需要一致范数的知识点，详情可以参考：<ahref="https://blog.csdn.net/qiuchangyong/article/details/101041583">各种矩阵范数总结</a></p><h3 id="常用损失函数">常用损失函数</h3><h4 id="average">1.Average</h4><p>平均策略，包括算术平均和加权平均。</p><p><span class="math inline">\(F(x,y) = \alpha _1 I_1(x,y) + \alpha _2I_2(x,y)\)</span></p><h4 id="norm">2.Norm</h4><p>Normalization，规范化，如L1-norm、L2-norm等，参考上面“距离度量”栏目内容。</p><p>Regularization，正则化，用于降低模型的复杂度，防止过拟合（Overfitting）问题。</p><p>L1正则主要用于特征选择，使其稀疏化，得到更多的零参数，<spanclass="math inline">\(R = \sum\limits_i{\vert w_{i} \vert}\)</span></p><p>L2正则主要用于求得更小的解（参数），防止过拟合，<spanclass="math inline">\(R = \sum\limits_i{\vert w_{i} \vert^2}\)</span>（平方惩罚力度更大）</p><h4 id="mse-rmse-and-mae">3.MSE, RMSE and MAE</h4><p>Mean Square Error，均方误差MSE，又称L2损失，<spanclass="math inline">\(Loss = \dfrac{1}{n} \sum\limits_{i = 1}^n (y_i -f(x_i))^2\)</span></p><p>Root Mean Square Error，均方根误差RMSE，<spanclass="math inline">\(Loss = \Big(\dfrac{1}{n} \sum\limits_{i = 1}^n(y_i - f(x_i))^2 \Big)^{\frac{1}{2}}\)</span></p><p>Mean Absolute Error，绝对值误差MAE，又称L1损失，<spanclass="math inline">\(Loss = \sum\limits_{i = 1}^n \vert y_i -f(x_i)\vert\)</span></p><h4 id="kl散度">4.KL散度</h4><p>Kullback-Leibler divergence，也叫相对熵：relativeentropy，用于衡量概率分布之间的距离。</p><p><span class="math inline">\(Loss = \sum\limits_{i = 1}^n Y_i \cdot\log(\dfrac{Y_i}{F(x_i)})\)</span></p><h4 id="交叉熵">5.交叉熵</h4><p>Cross Entropy：Loss = <span class="math inline">\(-\sum\limits_{i =1}^{n} Y_i \log F(x_i)\)</span></p><p>交叉熵损失函数刻画了模型实际输出概率与期望分布概率之间的相似程度，交叉熵的值越小，说明两个概率分布越接近。在二分类任务中存在正负样本不均衡问题时常用交叉熵作为损失函数（也称为对数损失函数），卷积神经网络在进行影像识别任务中最常使用的分类损失函数也是交叉熵损失函数，可以避免梯度消散问题。</p><p>激活函数建议搭配：tanh（双曲正切函数）、sigmoid函数（钻石函数）、ReLU函数（rectifiedlinearunit，修正线性单元）、Softmax函数（Logistic的扩展，适用于多分类任务）。</p><p>tanh(x) = <span class="math inline">\(\dfrac{e^x - e^{-x}}{e^x +e^{-x}}\)</span>，Sigmoid(x) = <span class="math inline">\(\dfrac{1}{1 +e^{-x}}\)</span>，Relu(x) = <spanclass="math inline">\(\max(0,x)\)</span>，Softmax(x) = <spanclass="math inline">\(\dfrac{e^{x_i}}{\sum\limits_{i}e^{x_i}}\)</span></p><h4 id="对数似然">6.对数似然</h4><p>对数似然（likelihood）损失：<span class="math inline">\(L =-\dfrac{1}{n} \sum\limits_{i = 1}^n [y_i \log(p_i) + (1 - y_i) \log(1 -p_i)]\)</span></p><p>合页损失Hinge Loss：<span class="math inline">\(L = \max(0, \1-yf(x))\)</span></p><p>Huber Loss：<span class="math inline">\(L = \begin{cases}\frac{1}{2}(y - f(x))^2 \qquad \qquad \vert y - f(x)\vert \leq \delta \\\delta \vert y - f(x) \vert - \frac{1}{2}\delta ^2 \qquad \vert y -f(x)\vert &gt; \delta \end{cases}\)</span></p><h4 id="psnr">7.PSNR</h4><p>Peak Signal to Noise Ratio，峰值信噪比PSNR，<spanclass="math inline">\(L_{PSNR} = 10\log(\dfrac{f_{max}^2}{L_{MSE}})\)</span></p><h4 id="perceptual-loss">8.Perceptual Loss</h4><p>感知损失，即图像感知相似度指标：Learned Perceptual Image PatchSimilarity（LPIPS），该值越低，表示两张图像越相似。该损失是一个深度学习模型，输入为图像，输出感知相似性分数。</p><h4 id="ssim">9.SSIM</h4><p>SSIM是一种衡量图像结构相似性的算法，结合了图像的亮度，对比度和结构三方面对图像质量进行测量。SSIM的公式如下:</p><p><span class="math inline">\(SSIM(x,y) = [L(x,y)]^{\alpha} \cdot[C(x,y)]^{\beta} \cdot [S(x,y)]^{\gamma}\)</span></p><p>L(x,y)是亮度部分：</p><p><span class="math inline">\(L(x,y) = \dfrac{2\mu _x\mu _y + C_1}{\mu_x^2 + \mu _y^2 + C_1}\)</span></p><p>C(x,y)是对比度部分：</p><p><span class="math inline">\(C(x,y) = \dfrac{2\sigma _x\sigma _y +C_2}{\sigma _x^2 + \sigma _y^2 + C_2}\)</span></p><p>S(x,y)是结构部分：</p><p><span class="math inline">\(L(x,y) = \dfrac{\sigma _{xy} +C_3}{\sigma _x\sigma _y + C_3}\)</span></p><p>式子中，<span class="math inline">\(\mu _x\)</span>与<spanclass="math inline">\(\mu _y\)</span>是图像的像素平均值，<spanclass="math inline">\(\sigma _x\)</span>和<spanclass="math inline">\(\sigma _y\)</span>是图像的像素标准差，<spanclass="math inline">\(\sigma _{xy}\)</span>是图像x和y的协方差，<spanclass="math inline">\(C_1\)</span>、<spanclass="math inline">\(C_2\)</span>、<spanclass="math inline">\(C_3\)</span>是常数，防止分母等于0。一般情况下，<spanclass="math inline">\(\alpha = \beta = \gamma = 1\)</span>，<spanclass="math inline">\(C_2 = 2\times C_3\)</span>，则有：</p><p><span class="math inline">\(SSIM(x,y) = \dfrac{(2\mu _x\mu _y +C_1)}{(\mu _x^2 + \mu _y^2 + C_1)}\cdot \dfrac{(2\sigma _{xy} +C_2)}{(\sigma _x^2 + \sigma _y^2 + C_2)}\)</span></p><h4 id="tv损失">10.TV损失</h4><p>详见上面“距离度量”栏目范数部分所附链接。</p><h3 id="图片格式">图片格式</h3><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JPEG，静态图像压缩标准，压缩比越高，质量越差</span><span class="hljs-keyword"></span><span class="hljs-keyword">JPG，与JPEG类似，相当于简化版，去除了相机的拍照参数等</span><span class="hljs-keyword"></span>PNG，无损压缩，位图片格式GIF，静态、动态图像，如动图、表情包TIFF，无失真压缩，占用空间较大TGA，兼顾 <span class="hljs-keyword">BMP </span>图像的质量与 <span class="hljs-keyword">JPEG </span>的体积<span class="hljs-keyword">BMP，位图 </span><span class="hljs-keyword">Bitmap，不采用压缩，占用空间大</span><span class="hljs-keyword"></span>SVG，二维矢量图形格式RAW，经 CMOS 或 CCD 图像感应器将捕捉到的光信号转换为数字信号的原始数据HDR，高动态范围图像，High-Dynamic Range，记录了照明信息</code></pre></div><h3 id="拓扑结构">拓扑结构</h3><p>什么是拓扑结构？</p><p>所谓“拓扑”，就是把实体抽象成与其大小、形状无关的“点”，把连接实体的线路抽象成“线”，进而以图的形式来表达这些点与线的关系。这个图被称为拓扑结构图，表示的关系是拓扑结构。</p><div class="code-wrapper"><pre><code class="hljs">几何结构：强调点与线构成的形状及大小，考察点、线（甚至面）的位置关系。拓扑结构：注重点、线之间的连接关系。</code></pre></div><p>例子：梯形、矩形、平行四边形、圆具有不同的形状，因此属于不同的几何结构，但是组成它们的点、线连接关系是一样的，因此具有相同的拓扑结构（环形结构）。</p><p>在计算机网络中，我们把计算机、终端、通信处理机等设备抽象成点，把连接这些设备的通信线路抽象成线，其构成的拓扑叫网络拓扑结构，反应网络的结构关系。</p><div class="code-wrapper"><pre><code class="hljs">几种常见的网络拓扑结构：总线型、星型、环型、树型、网状型等。</code></pre></div><p><a href="https://zhuanlan.zhihu.com/p/451069548?utm_id=0"title="什么是拓扑结构？">详情点击此处查看</a></p><h3 id="线性代数基础知识">线性代数基础知识</h3><h4 id="矩阵的正定和负定">矩阵的正定和负定</h4><p>矩阵Q正定的充要条件：<br /> (1) Q所有的特征值大于0 <br /> (2)Q各阶顺序主子式都大于0 <br /> (3) Q各阶主子式都大于0 <br /> (4)存在非奇异矩阵G，使得 <span class="math inline">\(Q = GG^T\)</span></p><p>矩阵Q半正定（正半定）的充要条件：<br /> (1) Q所有的特征值大于等于0<br /> (2) Q各阶主子式都大于等于0 <br /> (3) 存在矩阵G，使得 <spanclass="math inline">\(Q = GG^T\)</span></p><p>矩阵Q负定的充要条件：<br /> (1) Q所有的特征值小于0 <br /> (2)Q奇数阶顺序主子式都小于0，偶数阶顺序主子式都大于0 <br /> (3)Q奇数阶主子式都小于0，偶数阶主子式都大于0 <br /> (4)存在非奇异矩阵G，使得 <span class="math inline">\(-Q = GG^T\)</span></p><p>矩阵Q半负定（负半定）的充要条件：<br /> (1) Q所有的特征值小于等于0<br /> (2) Q奇数阶主子式都小于等于0，偶数阶主子式都大于等于0 <br /> (3)存在矩阵G，使得 <span class="math inline">\(-Q = GG^T\)</span></p><p>关于更基础的一些概念：主子式、顺序主子式、余子式、代数余子式、伴随矩阵、方向导数与梯度等内容，自行回顾学习！</p><h4 id="奇异非奇异矩阵">奇异、非奇异矩阵</h4><p>讨论非奇异矩阵和奇异矩阵的前提：矩阵A是n阶方阵。</p><p>矩阵A可逆（非奇异）的判别方法（满足下列充要条件之一）：<br /> (1)<span class="math inline">\(det(A) = \vert A \vert \neq 0\)</span><br /> (2) <span class="math inline">\(Rank(A) = n\)</span> 即满秩<br /> (3) <span class="math inline">\(A\)</span> 的所有特征值都不等于0<br /> (4) <span class="math inline">\(A\)</span>可以表示成若干个初等矩阵的乘积（初等矩阵是可逆的）</p><p>矩阵A奇异的判别方法（满足下列条件之一）：<br /> (1) <spanclass="math inline">\(\vert A \vert = 0\)</span> <br /> (2) <spanclass="math inline">\(Rank(A) &lt; n\)</span> 非满秩</p><p>非奇异矩阵就是可逆矩阵（满秩矩阵）。在数学上，“奇异”(singular)一词被用来形容破坏了某种优良性质的数学对象。对于矩阵来说，“可逆”是一个好的性质，表示该矩阵包含了其所能容纳的所有可用信息（不存在某几个行/列向量是线性相关的），即满秩。奇异矩阵行列式值为0，不可逆，等价于某个线性变换退化了，即变换之后有部分东西丢失了。</p><p>PS(PostScript): <div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>的充分条件是<span class="hljs-selector-tag">B</span>（<span class="hljs-selector-tag">B</span>是<span class="hljs-selector-tag">A</span>的充分条件，条件是<span class="hljs-selector-tag">B</span>，结论是<span class="hljs-selector-tag">A</span>），说明有了<span class="hljs-selector-tag">B</span>就一定有<span class="hljs-selector-tag">A</span>（充分性），即由条件<span class="hljs-selector-tag">B</span>可以推导出结论<span class="hljs-selector-tag">A</span>。<span class="hljs-selector-tag">A</span>的必要条件是<span class="hljs-selector-tag">B</span>（<span class="hljs-selector-tag">B</span>是<span class="hljs-selector-tag">A</span>的必要条件，即<span class="hljs-selector-tag">B</span>是必要的），说明没有<span class="hljs-selector-tag">B</span>就一定没有<span class="hljs-selector-tag">A</span>，因为<span class="hljs-selector-tag">B</span>是必要的（要作为结论），所以由<span class="hljs-selector-tag">A</span>可以推导出<span class="hljs-selector-tag">B</span>。</code></pre></div></p><p>Reference: <ahref="https://zhuanlan.zhihu.com/p/334822347">矩阵可逆的几个充要条件</a></p><h4 id="特征值与特征向量">特征值与特征向量</h4><p>定义：<span class="math inline">\(Ax = \lambda x\)</span>，其中 <spanclass="math inline">\(A\)</span> 是矩阵，<spanclass="math inline">\(\lambda\)</span> 是特征值（也叫本征值），非零向量<span class="math inline">\(x\)</span> 是特征向量。<spanclass="math inline">\(A \cdot x\)</span> 表示用矩阵对向量 <spanclass="math inline">\(x\)</span>进行一次线性变换（可以是拉伸+旋转，也可以只是拉伸或者只是旋转），而这种转换的效果就是一个常数<span class="math inline">\(\lambda\)</span> 与向量 <spanclass="math inline">\(x\)</span>的乘积（说明只进行了拉伸）。换句话说，就是对一个特定的矩阵 <spanclass="math inline">\(A\)</span> 来说，总存在一些特定方向的向量 <spanclass="math inline">\(x\)</span>，使得 <spanclass="math inline">\(Ax\)</span> 和 <spanclass="math inline">\(x\)</span>的方向一样（未发生变化），只有长度改变了。这个长度的变化就是特征值的几何含义。</p><p>我们通常求特征值和特征向量就是为了求出在笛卡尔坐标系中，该矩阵能使哪些向量（当然是特征向量）只发生拉伸，使其发生拉伸的程度如何（特征值大小）。如果把矩阵看作运动，那么特征值就是运动的速度，特征向量是运动的方向。特征向量在一个矩阵的作用下作伸缩运动，伸缩的幅度由特征值确定（缩放因子）。旋转矩阵是没有实数特征向量和特征值的。这样做的意义在于，看清一个矩阵在哪些方面能产生最大的效果，并根据所产生的每个特征向量（一般研究特征值最大的那几个）进行分类讨论，可以作为主成分进行研究、减少计算量、降维等。</p><p>附：笛卡尔坐标系：正交坐标系，比如直角坐标系（坐标轴互相垂直）。笛卡尔空间中，任何一个点的位置由数轴上对应的坐标设定。</p><h4 id="极大线性无关组">极大线性无关组</h4><h5 id="线性相关与线性无关">线性相关与线性无关</h5><p>在一个线性空间中，如果一组向量 <span class="math inline">\(a_1, a_2,\cdots, a_s\)</span> 是线性相关的，那么存在一组不全为0的数 <spanclass="math inline">\(k_1, k_2, \cdots, k_s\)</span> ，使得 <spanclass="math inline">\(k_1a_1 + k_2a_2 + \cdots + k_sa_s = 0\)</span>成立。</p><p>如果 <span class="math inline">\(a_{j \ (j=1,2,\ldots,s)}\)</span>线性无关，则 <span class="math inline">\(k_1a_1 + k_2a_2 + \cdots +k_sa_s = 0\)</span> 成立：当且仅当所有的 <spanclass="math inline">\(k_{j \ (j=1,2,\ldots,s)} = 0\)</span>。</p><h5 id="极大线性无关组-1">极大线性无关组</h5><p>设A是一个n维向量组，如果从A中取出s个向量 <spanclass="math inline">\(a_1, a_2,\cdots, a_s\)</span>组成向量组，该向量组线性无关，且对于A中的其他任意向量b，都有 <spanclass="math inline">\(a_1, a_2, \cdots, a_s, b\)</span>线性相关，那么向量组 <span class="math inline">\(a_{j \(j=1,2,\ldots,s)}\)</span>是矩阵（向量组）A的一个极大线性无关组，简称极大无关组。</p><h4 id="矩阵的秩">矩阵的秩</h4><p>小时候老师总是告诉我们：要有n个方程才能解出n个未知数。上了大学以后，我们知道这句话其实是不严谨的。如果你想确定的解出这n个未知数，只有n个方程是不够的，这n个方程必须都是“有用的”，也就是线性无关的才行，否则就会有某几个方程式表达重复（无用）的信息，相当于只是换了衣服而已，实质上还是同一个方程式，自然就无法求解其对应的未知元。这些真正有用的方程式个数就是（系数）矩阵的秩。从这个角度，我们可以更好地理解什么是矩阵的秩（Rank）。</p><p>矩阵的秩，是矩阵中极大线性无关组的向量个数，也就是以此矩阵的元素作为系数的方程组中，线性无关的方程个数。从另一个角度说，秩是矩阵变换以后的空间维度，代表这个矩阵实际包含的信息量的多少。我们可以回顾一下初等变换的过程：对矩阵的行列式作初等行变换时，线性相关的向量（行）会被消去（成为0），即不含有用信息。</p><p>线性代数，主要就是研究n元1次线性方程组（某个问题）解的存在性（有没有答案？）和解的唯一性（答案是否只有一个？）。如果存在解，如何找到这个解或者所有解？一般的含有n个未知数和m个方程的非齐次线性方程组可以表示如下：<span class="math display">\[ \begin{cases}a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n = b_1 \\a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n = b_2 \\\qquad \qquad \qquad \quad \vdots \\a_{m1}x_1 + a_{m2}x_2 + \cdots + a_{mn}x_n = b_m \\\end{cases} \]</span></p><p>若 <span class="math inline">\(n\le m\)</span> ，则有以下结论：</p><p>1）当方程组的系数矩阵A的秩：Rank(A) 与方程组增广矩阵 (A, b)的秩：Rank(A, b) 相等，并且都等于未知元个数 n 时，方程组具有唯一解；</p><p>2）当方程组 Rank(A) = Rank(A, b) &lt; n 时，方程组有无穷多个解；</p><p>3）当方程组 Rank(A) &lt; Rank(A, b) 时，无解。</p><p>结论(1)很好理解，方程组里所有方程式互不冲突，m =n，信息一一对应。结论(2)，方程组里所有方程互不冲突，但是 m &lt;n，存在自由变量可以随意取值（约束不够），因此具有无穷多解。结论(3)，存在多个方程式有冲突，信息有互斥的成分，存在"0 = c" 的现象，自然无法求解。</p><p>另外，根据克拉默法则：</p><p>1）当系数矩阵A的行列式值：det(A) = 0时，线性方程组（齐次或非齐次）要么有无穷多解，要么无解。</p><p>2a）对于齐次线性方程组（<span class="math inline">\(b_i =0\)</span>）来说，det(A)不等于0时，只有零解；det(A)等于0时，有0解和非0解。</p><p>2b）对非齐次方程组（上式）来说，det(A)不等于0时，有唯一解；det(A)等于0时，有无穷多解或没有解。</p><p>参考：<ahref="https://www.zhihu.com/question/21605094">如何理解矩阵的秩？</a></p><h4 id="矩阵的行列式和迹">矩阵的行列式和迹</h4><p>矩阵（方阵）A的迹：trace(A)，是矩阵A所有特征值之和。对 <spanclass="math inline">\(n \times n\)</span>的方阵A而言，迹等于A所有主对角线上的元素之和。</p><p>矩阵（n阶方阵）A的行列式（determinant）的值：det(A)，是方阵A全部特征值的乘积。行列式描述的是一个线性变换对欧几里得空间（线性的，可以用加法和数乘表示空间中所有元素；内积空间，可以用内积表示空间向量的角度信息（一定是赋范空间）；维度有限）中“体积”造成的影响。因为特征值是在特征向量方向上放缩的程度，可以认为特征值构成了特征空间的“骨”，类似于多面体的“边”、“高”等信息，当这些特征值相乘时，可以粗略的类比为体积的概念。</p>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔系列5：数码</title>
    <link href="/2023/11/25/NumericalCode/"/>
    <url>/2023/11/25/NumericalCode/</url>
    
    <content type="html"><![CDATA[<p>正在施工中……</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>functional</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔系列4：ICT</title>
    <link href="/2023/11/25/ICT/"/>
    <url>/2023/11/25/ICT/</url>
    
    <content type="html"><![CDATA[<h3 id="显示器接口">显示器接口</h3><ol type="1"><li>VGA接口</li></ol><blockquote><p>采用模拟协议，常用于老式显示器。目前不常用了，像一个四圆角梯形。</p></blockquote><figure><imgsrc="https://pica.zhimg.com/80/v2-9260a9e7bb2d44713e0976a8ac2ee667_1440w.webp?source=2c26e567"title="VGA接口" alt="VGA接口" /><figcaption aria-hidden="true">VGA接口</figcaption></figure><ol start="2" type="1"><li>DVI接口</li></ol><blockquote><p>有很多种类，算是VGA到HDMI的过渡产物。</p></blockquote><figure><imgsrc="https://pica.zhimg.com/80/v2-5dd3c4951a6a5c178e773deb1ba6b422_1440w.webp?source=2c26e567"title="DVI-D接口" alt="DVI-D接口" /><figcaption aria-hidden="true">DVI-D接口</figcaption></figure><ol start="3" type="1"><li>HDMI接口</li></ol><blockquote><p>音视频同时传输，支持高动态范围HDR成像，很常用，像带两个弯角的矩形。</p></blockquote><figure><imgsrc="https://picx.zhimg.com/80/v2-50888e26e96dafd6b0b5df25451923b9_1440w.webp?source=2c26e567"title="HDMI接口" alt="HDMI接口" /><figcaption aria-hidden="true">HDMI接口</figcaption></figure><ol start="4" type="1"><li>DP接口</li></ol><blockquote><p>DP(Digital Port)，也很常用，是HDMI的竞争对手，有很大的发展前景。</p></blockquote><figure><imgsrc="https://picx.zhimg.com/80/v2-3c1c4109ffc3f017bfdea221a49b77ca_1440w.webp?source=2c26e567"title="DP接口" alt="DP接口" /><figcaption aria-hidden="true">DP接口</figcaption></figure><h3 id="dns">DNS</h3><p>DNS(Domain NameSystem，域名系统)，用于域名解析，是因特网上作为域名和IP地址互相映射的一个分布式数据库，能让用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。</p><p><a href="https://zhuanlan.zhihu.com/p/186028919"title="什么是DNS？">点击查看详情</a></p><h3 id="路由器相关">路由器相关</h3><h4 id="直连">直连</h4><p>用一根网线连接两台主机的网口，可以相互发送和接收数据。<div class="code-wrapper"><pre><code class="hljs">多台主机通信怎么办？</code></pre></div></p><h4 id="集线器">集线器</h4><p>集线器(HUB)，将网线集结起来，实现初级的网络互通，工作在物理层，半双工通信。同时可以将信号放大后再传输以扩大传输距离。<div class="code-wrapper"><pre><code class="hljs 1c">集线器以广播形式以<span class="hljs-string">&quot;泛红转发&quot;</span>来发送数据，无法分辨具体的主机。</code></pre></div></p><h4 id="交换机">交换机</h4><p>交换机(Switch)，在集线器原有功能上，增加了自动寻址能力和交换作用，通过学习MAC地址（MAC地址表），查找对应的端口号，建立临时交换路径进行收发数据，工作在数据链路层，全双工通信。<div class="code-wrapper"><pre><code class="hljs">要求交换机端口上所有主机在同一个子网中。不同网段的主机怎么通信？</code></pre></div></p><h4 id="路由器">路由器</h4><p>路由器(Router)，连接不同类型的网络并能选择数据传输的IP路径，充当网关的角色，能在多网络互联环境中建立灵活的连接，工作在网络层。<div class="code-wrapper"><pre><code class="hljs arduino">家里拉了一条宽带（一条网线，现在多为光纤），只能一个人享受上网。如果要多设备连接网络，或者享受无线上网(<span class="hljs-built_in">WiFi</span>)，那么就需要安装路由器实现IP地址分配、网络共享和无线网使用（无线路由器），甚至进行网络加速（增强）。</code></pre></div></p><h4 id="猫">猫</h4><p>猫(Modem)，即光猫，调制解调器，进行光电转换。为了取代之前慢速的电话线上网，目前运营商多采用光纤传输，利用高速的光信号（会被限速，按你交的钱让你使用相应的带宽）进行数据传输。光信号无法直接被设备利用，经过光猫，将其转换为数字信号，即可被设备使用。</p><h4 id="ipmac地址">IP/MAC地址</h4><p>IP(InternetProtocol)，即互联网协议地址，为互联网上每一个网络和每一台主机配置唯一的逻辑地址，与物理地址区分。</p><p>IP地址分为IPv4和IPv6，IPv4使用32位（4字节）地址，IPv6地址长度为128位。最初设计互联网络时，为了便于寻址和层次化构造网络，每个IP地址包括两个标识码（ID），也就是网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。以IPv4地址为例，IP地址分为：1、公有地址(Publicaddress)，我们通过公有IP地址是可以实现直接访问因特网的。2、私有地址(Privateaddress)，分为五类：A类、B类、C类、D类、E类。其中，A、B、C类私有地址是由InternetNIC公司在全球范围内统一分配的，D、E类为特殊地址。<div class="code-wrapper"><pre><code class="hljs dns"><span class="hljs-keyword">A</span>类IP地址(适用于大型网络)的网络的标识(网络ID)长度为<span class="hljs-number">8</span>位，主机标识(主机ID)长度为<span class="hljs-number">24</span>位，它的范围：<span class="hljs-number">1.0.0.1</span>到<span class="hljs-number">127.255.255.254</span>；B类IP地址(适用于中型网络)的网络ID为<span class="hljs-number">16</span>位，主机ID长度为<span class="hljs-number">16</span>位，它的范围：<span class="hljs-number">128.0.0.1</span>-<span class="hljs-number">191.255.255.254</span>；C类IP地址(适用于小型网络)网络ID为<span class="hljs-number">24</span>位，主机ID长度为<span class="hljs-number">8</span>位，它的范围：<span class="hljs-number">192.0.0.1</span>-<span class="hljs-number">223.255.255.254</span>；D类地址被叫做多播地址(multicast address)，即组播地址，它的范围：<span class="hljs-number">224.0.0.0</span>到<span class="hljs-number">239.255.255.255</span>；E类地址主要用于Internet试验和开发，它的范围：<span class="hljs-number">240.0.0.0</span>~<span class="hljs-number">255.255.255.255</span></code></pre></div></p><p>MAC地址（Media Access ControlAddress）的全称叫做媒体访问控制地址，也称作局域网地址、以太网地址或者物理地址。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。MAC地址共48位（6个字节），前24位由IEEE（电气和电子工程师协会）决定如何分配，后24位由实际生产该网络设备的厂商自行制定。</p><p>OSI模型（Open System Interconnection ReferenceModel），是一种概念模型，是一个标准，一个试图使各种计算机在世界范围内互连为网络的标准框架。<div class="code-wrapper"><pre><code class="hljs armasm">第一层：物理层（Physical Layer），它是提供物理链路、传递电信号或光信号用的在局域网上传输比特流，它负责管理计算机通信设备和网络媒体之间的互通包括针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等第二层：数据链路层（<span class="hljs-meta">Data</span> Link Layer），负责网络寻址、错误侦测和改错当表头和表尾被加至数据包时，会形成帧（数据帧：<span class="hljs-meta">data</span> frame）而且此层还负责MAC地址第三层：网络层（Network Layer），决定数据的路径选择（数据选路）和转寄将网络表头（NH）加至数据包，以形成分组网络表头包含了网络数据，例如：<span class="hljs-built_in">IP</span>地址第四层：传输层（Transport Layer），它会建立一个安全通道，以防数据丢失端到端之间的连接建立，把传输表头（TH）加至数据以形成数据包传输表头包含了所使用的协议等发送信息，例如：传输控制协议（TCP）第五层：会话层（Session Layer），负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接第六层：表达层（Presentation Layer），将信息数据进行加密，及数据的转化信息数据经过加密、转换、压缩，转换为能与接收者的系统格式兼容并适合传输的格式第七层：应用层（Application Layer），起调用的作用提供为应用软件而设的接口，设置与另一应用软件之间的通信例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3.HTML.等</code></pre></div></p><p>IP地址与MAC地址的区别：1、IP地址应用于OSI模型的网络层，而MAC地址应用在OSI模型的数据链路层。2、地址长度、设计理念不同、分配依据不同。3、IP地址未必都不一样，与地理区域等有关。MAC地址只和硬件设备有关。</p><p>IP地址的提出，主要是为了减少广播的数量，可以智能学习目标地址在哪个网卡。</p><p><a href="https://www.zhihu.com/question/21546408"title="有了 IP 地址，为什么还要用 MAC 地址？">点击查看详情</a></p><h3 id="存储">存储</h3><p><a href="https://zhuanlan.zhihu.com/p/166633984"title="存储技术入门详解">点击跳转：存储技术入门详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔系列3：生活常识</title>
    <link href="/2023/11/25/Informal%20Essay%2003/"/>
    <url>/2023/11/25/Informal%20Essay%2003/</url>
    
    <content type="html"><![CDATA[<h3 id="常见亲属称谓">常见亲属称谓</h3><p>父亲的哥哥</p><blockquote><p>伯父、伯伯、大爷（~~~伯母、大娘）</p></blockquote><p>父亲的弟弟</p><blockquote><p>叔叔（~~~婶婶）</p></blockquote><p>父亲的姐妹</p><blockquote><p>姑姑（~~~姑父/夫）</p></blockquote><p>母亲的兄弟</p><blockquote><p>舅舅（~~~舅妈）</p></blockquote><p>母亲的姐妹</p><blockquote><p>姨（~~~姨夫/父）</p></blockquote><p>父亲之父</p><blockquote><p>爷爷（祖父）</p></blockquote><p>父亲之母</p><blockquote><p>奶奶（祖母）</p></blockquote><p>母亲之父</p><blockquote><p>姥爷、外公、外爷（外祖父）</p></blockquote><p>母亲之母</p><blockquote><p>姥姥、外婆（外祖母）</p></blockquote><p>爷爷的姐妹</p><blockquote><p>姑奶（~~~姑爷）</p></blockquote><p>爷爷的兄弟</p><blockquote><p>爷爷</p></blockquote><p>奶奶的姐妹</p><blockquote><p>姨奶（~~~姨爷）</p></blockquote><p>奶奶的兄弟</p><blockquote><p>舅爷（~~~舅奶）</p></blockquote><p>兄弟的子女辈叫自己的称谓：</p><blockquote><p>自己男：自己作为弟--叫叔；自己作为兄--叫伯（大爷~大娘）</p></blockquote><blockquote><p>自己女：叫姑</p></blockquote><p>姐妹的子女辈叫自己的称谓：</p><blockquote><p>自己男：叫舅，舅妈也叫妗(jin)子</p></blockquote><blockquote><p>自己女：叫姨</p></blockquote><h3 id="名酒记">名酒记</h3><p>中国新老八大名酒： <div class="code-wrapper"><pre><code class="hljs">茅台  汾酒  泸州老窖（特曲）古井贡酒  五粮液  董酒剑南春  洋河大曲  西凤酒</code></pre></div> 安徽酒： <div class="code-wrapper"><pre><code class="hljs">古井贡酒  口子窖  高炉家酒  文王贡酒迎驾贡酒  金种子  宣酒  皖酒  金坛子酒店小二酒  沙河王  明光酒  ···</code></pre></div></p><h3 id="处方药和非处方药">处方药和非处方药</h3><p>无论处方药还是非处方药，都必须经过国家食品药品监督管理局（CFDA）的批准才能上市，包装盒上必须注明国药准字。</p><div class="code-wrapper"><pre><code class="hljs gcode">国际上通用 Rx <span class="hljs-comment">(拉丁文Recipe，请求)</span>表示处方药，用 OTC <span class="hljs-comment">(Over The Counter，可以在柜台上买到的)</span>表示非处方药。包装盒上只有国药准字，没有Rx或OTC标识的，为处方药。</code></pre></div><p>非处方药又分为甲、乙两类，在包装盒正面分别用红色OTC、绿色OTC标识。</p><p>乙类非处方药一般不需要医生或药师的指导，消费者可以自行购买，看说明书使用即可，风险较低。</p><p>使用区别：</p><blockquote><p>处方药（无标识或Rx），医生处方，需要仔细阅读说明书并在医师指导下使用（服用）。</p></blockquote><blockquote><p>非处方药（红色或绿色OTC），医生处方、药师指导或自我诊断用，仔细阅读说明书并按照说明书或药师指导下使用。</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/27355994?utm_id=0"title="你会识别处方药和非处方药吗？">点击此处查看详情</a></p><h3 id="静电现象">静电现象</h3><h4 id="加油站能否使用手机">加油站能否使用手机？</h4><p>美国一个科普电视节目《流言终结者》通过实验的方式，对“手机是否会意外引爆加油”这一命题进行了验证。他们找了一片空旷的地方制作了一个能控制环境因素的大爆炸室，然后把汽油以汽化的形式输送到室内，最后放入一只手机，并拨通该手机。实验结果是室内油气未被引燃。但是手机虽然被拨通了，却没有被接通。因此该实验无法证明手机在接通的情况下能否引燃油气。</p><p>据相关资料显示，正常待机时的手机内部电流只有10mA，当接打手机时，处于工作状态时的手机内部电流可以增大至2.3A~3A，并可能产生电火花，容易引发火灾。</p><p>所以理论上，在加油站内使用手机是有可能引燃油气的。而这种情况不发生就是零，一旦发生就是百分之百。虽然在现实中发生的概率极低，但小心驶得万年船，尽量不要在加油站禁区内使用手机，谁知道什么时候1.3的油气混合比就碰上静电火花了呢。</p><p>据东南大学网络空间安全学院副教授宋宇波解释，现实生活中我们操作手机，手机本身它的发射功率是有限制的，那么它的最大功率是远远达不到会产生电火花的这种情况的，现在我们的手机基本上都是触摸式的智能手机，这种手机相较于老式手机，使用起来是更加安全的，因为它并不会有一些机械式的操作，所以产生电火花的可能性就更小了。</p><p>照这么看来，手机确实不该背这个锅。所以，到底是什么引爆了加油站呢？</p><p>据悉，五成以上的加油站爆炸，是发生在加油的过程中回到车上时，因坐垫和衣服摩擦产生静电电荷，下车时若附在身体上的电荷先碰到了打开的油箱附近，因此产生的放电火花可能会致命，导致爆炸。</p><p>若在油枪附近产生放电火花时，记住别把油枪拿出来，因为油箱能局限住汽油；别让汽油流在地面或者路面上。尽量后退，并立刻通知加油站。</p><p>据不完全统计，国内加油站的火灾大概有70%是由静电引发的，而衣服、毛发、干燥的空气都可能摩擦产生静电。加油前先释放身体上的静电，才是头等大事。</p><h4 id="静电的产生">静电的产生</h4><p>静电是电荷在物质系统中的不平衡分布产生的现象。用毛皮摩擦琥珀、丝绸摩擦玻璃棒等方法均能使物体带电。物体带电后，电荷会保持在物体上，除非被其他物体移走，所以称之为“静电”。静电与电流不同，后者是电荷在导体中的定向移动产生的电学现象。带电物体往往具有吸起轻小物体（比如纸屑）的性质。</p><p>使物体带上电荷叫做“起电”。组成物质的原子由带正电的原子核和带负电的电子组成。正常情况下，物体中正负电荷电量相等，对外不显示出电性，即不带电。在一定的外部作用下（比如摩擦），物体得到或失去一定数量的电子，使物体内部正负电荷电量不相等，物体就会对外呈现电性，即带电。</p><p>静电积累之后，由于不同物体电势不同，电荷通过瞬间电流发生转移的过程称为放电。冬季手和金属之间的火花、闪电等现象都属于放电。</p><p>干燥的空气降低了物体表面的导电性，使得静电更容易产生和累积。因此，消除静电的最简单方法就是使用空气加湿器，提高空气的相对湿度可以增强空气的导电性，有利于物体上的静电经过空气被导走。使用离子发生器也能达到相同的效果。</p><h4 id="绝缘体的静电感应">绝缘体的静电感应</h4><p>绝缘体也有静电感应的现象，这就是带电物体能吸引小纸片的原因。在绝缘体中，电子被原子束缚着，不能在物体中自由移动；但是在原子内可以移动一点点。如果把带正电的物体靠近绝缘体，则每一个原子中的电子都会被吸引而稍微移动一点，而原子核则会被排斥，而往相反的方向移动一点。这种现象称为极化。由于这时物体中的负电荷离外面的带电物体较近，而正电荷则距离较远，将导致吸引力比排斥力大一点点。这个现象是微观的，但因为有那么多的原子，加起来效果就很明显了，足以使较轻的物体（如小纸片）被吸引。</p><h4 id="静电为什么会产生电火花">静电为什么会产生电火花？</h4><p>电火花就是放电路径，在空气中就是正负极之间的空气被电场电离产生离子，然后电流通过这些离子流动。之所以发出光线是因为被电离的空气带有能量，这些能量以光的形式散发出来。产生热是因为焦耳定律：导体中流过电流时产生的热量等于电阻乘以电流的平方。</p><p>空气或其他气体介质被击穿会产生有颜色的放电现象，颜色来源于气体被击穿后产生的等离子体。</p><p>闪电，俗称雷电，一般是专指对流层大气放电的现象，是静电放电现象的一种。当空气作为一种介质时，空气中的各种微粒互相碰撞和摩擦便会使该空气介质两面的正负电荷的量持续积累，这时加于该空气介质的电压也会同时增加，当局部电压达到当时条件下空气的击穿电压时，该空气介质的局部便会发生电击穿而持续成为等离子体，使电流能够通过原本绝缘的空气。这时通过空气的电流也会将空气急剧加热，使空气膨胀而产生雷声。</p><p>闪电的电流很大，其峰值一般能达到几万安培，但是其持续的时间很短，一般只有几十微秒。由于持续时间短，闪电输送的能量相对不大，不过闪电的功率却可以很大。在夏季的潮湿的天气下，丰富的水分子会令该空气介质所要求的击穿电压降低，因此较易发生闪电，而冬季下雪时也是同一情况。概括而言，当某介质的击穿电压因该介质的性质改变而下降，便有较大机会发生放电现象。</p><h3 id="燃油汽车和电动汽车">燃油汽车和电动汽车</h3><p>本文参考：<ahref="https://zhuanlan.zhihu.com/p/23707840">知乎-石红生-汽车分类</a></p><p>电动汽车，简单说就是以电能作为能源供给，电动机作为动力引擎的汽车。英文：ElectricVehicle，电动汽车，涵盖了各种带电动特性的汽车。基本上配置了电动机的汽车都可以统称为EV。</p><h4 id="纯电车-bev">纯电车: BEV</h4><p>Battery ElectricVehicle，电池动力汽车。一般指纯电动汽车，即只有电池提供能源供给，只有电动机提供动力，驱动汽车前行。</p><p>这类车型可以实现行驶过程完全零排放。纯电动汽车一般配置较大容量的电池，并提供交流慢充和直流快充两种充电接口。因为这类车型只能依靠电池提供能量，基于目前电池性能仍需改进和充电基础设施较少，纯电动车型会给车主带来较大的里程焦虑，说简单点就是总担心车在半路上没电了。</p><p>代表车型：特斯拉系列，蔚来汽车，威马汽车，小鹏汽车，日产聆风，宝马i3，比亚迪e6、e5、秦EV、唐EV，北汽EV系列、EU系列，奇瑞艾瑞泽5e，江淮iEV系列，上汽ERX5、Ei5、E50等。</p><p><imgsrc="https://pic3.zhimg.com/v2-c1548bedc81e4fca267ad666abe3cc82_r.jpg" /></p><h4 id="油电混合动力汽车-hev">油电混合动力汽车: HEV</h4><p>Hybrid ElectricVehicle，混合电动汽车，也称非插电混动车。一般指由燃油和电池提供能源、燃油发动机和电动机提供动力的汽车。</p><p>这种车型一般电池容量较小，不提供充电接口，电池的能量通过汽车运行过程中的能量回收进行充电。该车型的电动机功率也不大，在起步、加速等场景辅助燃油发动机提供动力。因为有了电动机的辅助，得以充分发挥电动机的大扭矩优势，在起步和加速过程中的整体效率得到提升，并使车辆整体油耗下降。因为依赖燃油提供能量，没有里程焦虑。</p><p>代表车型：丰田普瑞斯，丰田雷凌，丰田卡罗拉等。</p><p><imgsrc="https://pic1.zhimg.com/v2-906abbb0af4c82dd2024abef41652dc8_r.jpg" /></p><h4 id="插电式混动车-phev">插电式混动车: PHEV</h4><p>Plug-in Hybrid ElectricVehicle，即插电式混合动力汽车。顾名思义，PHEV的车载动力电池可以通过插座进行充电，也可以通过燃油发动机充电。</p><p>这种车的能量提供由电池和燃油提供，动力提供由燃油发动机和电动机提供。不同的汽车厂商在PHEV上对于电池的容量、电机的数量和功率配置有较大差异，也形成了不同的整车风格和特点。</p><p>这类车型可以通过电机，燃油机的介入算法形成多种驱动组合。比如纯电动模式，纯燃油机模式，电机加燃油机混合模式等。另外，PHEV进可攻，退可守，在充电方便、电量充足时，可以用纯电动方式行驶，节能减排还降低用车成本。在电量不足或充电不便时，可用传统的燃油行驶，远行亦无忧。还有些车型，比如比亚迪唐，配置了前后两个电机，很容易实现四轮驱动。</p><p>代表车型：比亚迪秦、唐、汉、宋系列，上汽荣威系列，领克PHEV系列等。</p><p><imgsrc="https://pic2.zhimg.com/v2-aff299f0d2c16688efee60e8a690efe5_r.jpg" /></p><h4 id="增程式混动车-erev">增程式混动车: EREV</h4><p>Extended-Range ElectricVehicle，增程式电动汽车。通过燃油发电，给电池充电，电动机驱动汽车行驶。</p><p>电机驱动，有电动汽车的良好特性。可以配置较小容量的电池，重量小、成本低。电池可以通过插座充电，也可以通过汽车行驶过程中的燃油发动机进行充电。EREV因为可以通过燃油发电，所以也没有里程焦虑。这类车同时具有电动车的驾驶体验和燃油车的补能体验，在当前纯电车的续航和补能体验无法媲美燃油车的情况下，是一种不错的均衡方案。</p><p>代表车型：理想ONE，宝马i3增程版，岚图FREE增程版，问界M5，零跑C11增程版，哪吒S增程版，自游家NV增程版等。</p><p><imgsrc="https://pic3.zhimg.com/v2-60e13fd3fb97d08d8d351962391f402e_r.jpg" /></p><h4 id="燃料电池汽车-fcv">燃料电池汽车: FCV</h4><p>Fuel CellVehicle，燃料电池汽车。通过燃料的化学能转化为电能，提供行驶所需的能量，并由电动机驱动汽车行驶。目前主要的燃料类型为：氢。</p><p>燃料电池的能量补充是通过加燃料的方式，因此时间和加油相近，可以快速完成。另外燃料电池能量转换过程效率高，无噪音，无污染物排出。然而，燃料电池汽车目前最大的困难是燃料获取难，燃料储存和运输难，添加站点少。</p><p>代表车型：丰田Mirai，本田Clarity等。</p><p><imgsrc="https://pic3.zhimg.com/v2-2202a71d60133919940e1aabb9231f76_r.jpg" /></p><h4 id="one-more-thing">One more thing</h4><p>还有一种分类方式：由于当下的混动汽车经过多年的发展，混合动力系统已经逐步实现了发动机、电动机和变速箱一体化的结构，形成了集成化混合动力综合系统。混合动力系统以动力传输路线分类，可分为串联式（SHEV）、并联式（PHEV）和混联式（PSHEV）三种。至于更详尽的内容请君自行搜索查阅。</p><p><imgsrc="https://pic3.zhimg.com/v2-cb9f3292eccc095f54344c7bc427023e_r.jpg" /></p><h3 id="杂谈索引">杂谈索引</h3><h4 id="航空航天">航空航天</h4><p><ahref="https://www.zhihu.com/question/19803751/answer/734389720">航空和航天的区别是什么？</a></p><h4 id="寺庙">寺庙</h4><p><ahref="https://zhuanlan.zhihu.com/p/214181716">“寺”和“庙”的区别是什么？</a></p><h4 id="历史">历史</h4><p><ahref="https://zhuanlan.zhihu.com/p/125707505">抗日战争大事件时间线总览</a></p><p><ahref="https://zhuanlan.zhihu.com/p/424398180">红军长征：人类历史上的奇迹</a></p><p><ahref="https://zhuanlan.zhihu.com/p/548302086">“左/右”的概念：左派&amp;右派、左倾&amp;右倾、左翼&amp;右翼</a></p><p><ahref="https://zhuanlan.zhihu.com/p/93660186">红军、八路军、新四军、野战军、解放军有何区别？</a></p><h4 id="军衔警衔">军衔警衔</h4><p><ahref="https://zhuanlan.zhihu.com/p/588498038">中华人民共和国军衔制</a></p><p><ahref="https://zhuanlan.zhihu.com/p/363757099">中国警察警衔及对应级别详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>common</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔系列2：地理 · 省会篇</title>
    <link href="/2023/11/25/Informal%20Essay%2002/"/>
    <url>/2023/11/25/Informal%20Essay%2002/</url>
    
    <content type="html"><![CDATA[<h3 id="省份直辖市-简称-首都省会">省份/直辖市-简称-首都（省会）</h3><div class="code-wrapper"><pre><code class="hljs">北京市-京-北京  天津市-津-天津  上海市-沪-上海  重庆市-渝-重庆黑龙江省-黑-哈尔滨  吉林省-吉-长春  辽宁省-辽-沈阳  内蒙古自治区-蒙-呼和浩特新疆维吾尔族自治区-新-乌鲁木齐  西藏自治区-藏-拉萨  甘肃省-甘-兰州青海省-青-西宁  陕西省-陕-西安  宁夏回族自治区-宁-银川  河南省-豫-郑州河北省-冀-石家庄  安徽省-皖-合肥  山西省-晋-太原  湖南省-湘-长沙湖北省-鄂-武汉  江苏省-苏-南京  四川省-蜀-成都  贵州省-黔-贵阳云南省-云-昆明  广西壮族自治区-桂-南宁  广东省-粤-广州  山东省-鲁-济南浙江省-浙-杭州  江西省-赣-南昌  福建省-闽-福州  海南省-琼-海口香港特别行政区-港-香港  澳门特别行政区-澳-澳门  台湾省-台-台北</code></pre></div><h3 id="行政区划分">行政区划分</h3><p>省级行政区：23个省，5个自治区，4个直辖市，2个特别行政区，共计34个省级行政区。</p><p>地级行政区：地级市（含省会）、地区、自治州、盟。</p><p>县级行政区：县（包括县级市、自治县、旗、自治旗）、市辖区、特区、林区。</p><p>乡级行政区：街道办事处、镇、乡（包括民族乡、苏木）、县辖区。</p><p>村级：居民委员会、村民委员会。</p><p>PS：根据中华人民共和国宪法，人民代表大会是中国最高权利机关，各级人民代表大会选举各级人民政府作为行政机关。所以严格来说，只有拥有政府和人大的级别才算行政区划，没有的就不算。因此，地区、盟、街道办事处、村民委员会、居民委员会均不是行政区划，其中村民委员会、居民委员会是基层群众自治组织，地区、盟、街道办事处是上级政府的派出机构。相应的，地区和盟下辖的县级行政区，实际上直接属于上级行政区（省、自治区），街道办事处下辖的村委会和居委会也同样直接隶属于县、县级市、市辖区。</p><h3 id="中国地理区域">中国地理区域</h3><p>行政大区是在中国建国初期设置的，是当年位于省级之上的行政区划。当时为了便于管理，政府将全国划分为六大行政区：华北（北京）、东北（沈阳）、华东（上海）、中南（武汉）、西南（重庆）、西北（西安）。</p><p>中国七大地理区域：华东地区、华南地区、华北地区、华中地区、东北地区、西南地区、西北地区。</p><p><a href="https://zhuanlan.zhihu.com/p/107971624?utm_source=weibo"title="点击此处查看你不知道的中国各种地理区域划分！">⪧中国地理划分⪦</a></p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>common</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔系列1：朝代更迭史</title>
    <link href="/2023/11/25/Informal%20Essay%2001/"/>
    <url>/2023/11/25/Informal%20Essay%2001/</url>
    
    <content type="html"><![CDATA[<h3 id="夏朝">夏朝</h3><p>大禹 ---------- 桀</p><h3 id="商朝">商朝</h3><p>成汤 ---------- 商纣王</p><h3 id="周朝">周朝</h3><p>分封诸侯，是中国历史上最长的朝代，从西周【周武王】到东周【周平王】，终于【郝王】。</p><div class="code-wrapper"><pre><code class="hljs">东周时期分为春秋、战国春秋五霸：齐 晋 楚 秦 宋战国七雄：秦 韩 赵 魏 楚 燕 齐诸子百家也在这一时期</code></pre></div><h3 id="秦国">秦国</h3><p>始皇帝：嬴政 ---------- 胡亥</p><div class="code-wrapper"><pre><code class="hljs">奴隶社会的终结，封建社会的开始，提出并实行郡县制</code></pre></div><h4 id="楚汉之争">楚汉之争</h4><p>项羽 VS 刘邦</p><h3 id="西汉">西汉</h3><p>始于汉高祖：刘邦</p><h4 id="新朝">新朝</h4><p>王莽篡汉，成立新朝</p><h3 id="东汉">东汉</h3><p>光武帝刘秀 ---------- 汉献帝刘协</p><h3 id="三国">三国</h3><p>曹魏（曹操）、蜀汉（刘备）、孙吴（孙权）</p><h3 id="西晋">西晋</h3><p>司马炎（司马昭之子）建立</p><h4 id="东晋-五胡十六国-南北朝">东晋 五胡十六国 南北朝</h4><p>乱世时期</p><h3 id="隋朝">隋朝</h3><p>隋文帝杨坚 ---------- 隋炀帝杨广</p><h3 id="唐朝">唐朝</h3><p>唐高祖李渊 ---------- 唐景宗李柷</p><blockquote><p>开元盛世：玄宗李隆基</p></blockquote><blockquote><p>贞观之治：太宗李世民</p></blockquote><h4 id="五代十国">五代十国</h4><p>乱世时期</p><h3 id="北宋">北宋</h3><p>宋太祖赵匡胤 ---------- 宋钦宗赵恒（宋徽宗赵佶之子）</p><h4 id="辽">辽</h4><p>实为北宋前由耶律阿保机建立</p><h4 id="金">金</h4><p>完颜阿骨打建立，灭辽、北宋，亡于南宋和蒙古</p><h3 id="南宋">南宋</h3><p>宋高宗赵构（亦为徽宗之子）建立</p><h3 id="元朝">元朝</h3><p>忽必烈建立</p><div class="code-wrapper"><pre><code class="hljs">成吉思汗建立蒙古政权，算元朝的前身元朝是首次由少数民族建立的朝代</code></pre></div><h3 id="明朝">明朝</h3><p>明太祖朱元璋 ---------- 末代皇帝崇祯（朱由检）</p><h3 id="清朝">清朝</h3><p>由清太宗皇太极改国号为清 ———— 顺治皇帝爱新觉罗•福临一统 ————末代皇帝宣统帝（溥仪）</p><div class="code-wrapper"><pre><code class="hljs">努尔哈赤建立的是后金（称汗），不算清帝</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>common</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="/2023/11/24/Markdown/"/>
    <url>/2023/11/24/Markdown/</url>
    
    <content type="html"><![CDATA[<h3 id="一标题">一、标题</h3><p>在文字前加井号 # 表示标题，共支持六级标题。</p><p><strong>注：几乎所有语法符号后要跟个空格再接内容</strong></p><p>示例： <div class="code-wrapper"><pre><code class="hljs clean"># 一级标题## 二级标题### 三级标题···以此类推···</code></pre></div></p><h3 id="二文字与排版">二、文字与排版</h3><ul><li><p><strong>加粗</strong>文本前后各两个*或者两个_是加粗，如**文本**</p></li><li><p><em>斜体</em> 文本前后各一个*或者一个_是倾斜，如*文本*</p></li><li><p><strong><em>斜体加粗</em></strong> 文本前后各三个 *</p></li><li><p><del>删除线</del> 前后各两个 ~</p></li><li><p><mark>文本高亮</mark>HTML标签&lt;mark&gt;可以对文本进行高亮显示，写法：&lt;mark&gt;文本&lt;/mark&gt;</p></li><li><p><font color="purple">字体颜色与大小</font> 可以通过&lt;fontsize=4 color="blue"&gt;文本&lt;/font&gt;的形式进行自定义。size可设置为1-7，浏览器默认是3。</p></li></ul><p>注：以上不加空格</p><p>更多细节戳此处查看：<ahref="https://blog.csdn.net/heimu24/article/details/81189700">Markdown进阶：更改字体、颜色、大小、背景色、图片显示</a>。</p><ul><li>换行 &lt;br/&gt; (&lt;br&gt;···&lt;/br&gt;)</li></ul><p>可以内嵌Html语法，例如：段落&lt;p&gt;&lt;/p&gt;(可能不加结束标签也可，但不要依赖这种做法！)、链接&lt;ahref="URL名"&gt;显示内容&lt;/a&gt;、图片&lt;img src="URL名" width="宽度"height="高度" /&gt;等</p><ul><li><p>空格 $~~~$（长空） 或者在$圈定的里面（公式区）写入\（短空）</p></li><li><p>引用 在引用的文字前加一个或多个 &gt; 即可，适应屏幕</p></li></ul><p>效果：</p><blockquote><p>引用1</p></blockquote><blockquote><blockquote><p>引用2</p></blockquote></blockquote><ul><li>分割线 用三个及以上的 * 或 - 单独成行</li></ul><hr /><ul><li><p>列表</p><ul><li><p>无序列表 用 * 或 - 或 + 都行，后接空格</p></li><li><p>有序列表 数字加点 <div class="code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> list1<span class="hljs-bullet">2.</span> list2</code></pre></div></p></li><li><p>嵌套列表 上下两级之间敲两个空格即可</p></li></ul></li><li><p>代码块 (``````)用括号中的反引号将需要标注的块区域包起来，三个就行，但是自动补全机制写六个更省事（不加括号，自成一行）</p><p>单行代码：前后各用一个 ` 就行</p><p>代码块： <div class="code-wrapper"><pre><code class="hljs">这里是代码块</code></pre></div> 单行代码： <code>这里是单行代码</code></p><p>支持语法高亮，在首行 ` 后紧跟着写相应语言即可，如python</p></li><li><p>脚注用方括号[]和^可以构成一个脚注，可在后方写注释，注释显示在文末</p><p>脚注写法：[^1] <br/> 注释写法：[^1]: Content</p><p>效果：脚注<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="这是一个脚注^_^">[1]</span></a></sup></p></li></ul><h3 id="三插入超链接和图片">三、插入超链接和图片</h3><ol type="1"><li><p>[超链接名] (超链接地址 "超链接title") 示例：[百度](http://baidu.com)</p></li><li><p>![图片名] (图片地址 "图片title") 图片名为下标</p></li><li><p><URL名> 可点击的链接，也可填入Email地址</p></li></ol><p>注：名和地址之间中间不加空格，title可不加<br>title与地址间空一格，内容在鼠标悬停于超链接或图片上时显示</br></p><p>当图片保存在本地路径Blog_repo/themes/fluid/source/img时，<br>引用图片地址为：/img/.../<font color="purple">Image_name</font></br></p><h3 id="四表格">四、表格</h3><p>用管道符 | 来分隔各列，用 ------ (多个) 来创建（隔开）表头。</p><p>示例： <div class="code-wrapper"><pre><code class="hljs gherkin">|<span class="hljs-string"> theHead1 </span>|<span class="hljs-string"> theHead2 </span>|<span class="hljs-string"> theHead3 </span>|<span class="hljs-string"> theHead4 </span>||<span class="hljs-string"> -------- </span>|<span class="hljs-string"> :------- </span>|<span class="hljs-string"> -------: </span>|<span class="hljs-string"> :------: </span>||<span class="hljs-string"> 内容1 </span>|<span class="hljs-string"> 内容2 </span>|<span class="hljs-string"> 内容3 </span>|<span class="hljs-string"> 内容4 </span>||<span class="hljs-string"> 内容1 </span>|<span class="hljs-string"> 内容2 </span>|<span class="hljs-string"> 内容3 </span>|<span class="hljs-string"> 内容4 </span>|</code></pre></div></p><table><thead><tr class="header"><th>theLongHead1</th><th style="text-align: left;">theLongHead2</th><th style="text-align: right;">theLongHead3</th><th style="text-align: center;">theLongHead4</th></tr></thead><tbody><tr class="odd"><td>内容1</td><td style="text-align: left;">内容2</td><td style="text-align: right;">内容3</td><td style="text-align: center;">内容4</td></tr><tr class="even"><td>内容1</td><td style="text-align: left;">内容2</td><td style="text-align: right;">内容3</td><td style="text-align: center;">内容4</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs gherkin">|<span class="hljs-string"> 1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 3 </span>|<span class="hljs-string"> 4 </span>||<span class="hljs-string"> ---- </span>|<span class="hljs-string"> :---- </span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :---: </span>||<span class="hljs-string"> 超长的内容1 </span>|<span class="hljs-string"> 超长的内容2 </span>|<span class="hljs-string"> 超长的内容3 </span>|<span class="hljs-string"> 超长的内容4 </span>||<span class="hljs-string"> 超长的内容1 </span>|<span class="hljs-string"> 超长的内容2 </span>|<span class="hljs-string"> 超长的内容3 </span>|<span class="hljs-string"> 超长的内容4 </span>|</code></pre></div><table><thead><tr class="header"><th>1</th><th style="text-align: left;">2</th><th style="text-align: right;">3</th><th style="text-align: center;">4</th></tr></thead><tbody><tr class="odd"><td>超长的内容1</td><td style="text-align: left;">超长的内容2</td><td style="text-align: right;">超长的内容3</td><td style="text-align: center;">超长的内容4</td></tr><tr class="even"><td>超长的内容1</td><td style="text-align: left;">超长的内容2</td><td style="text-align: right;">超长的内容3</td><td style="text-align: center;">超长的内容4</td></tr></tbody></table><p>在分隔行的连字符 - 左侧、右侧或两侧可以加冒号 :使得该列内容左对齐、右对齐或居中显示，默认（不加冒号时）左对齐。</p><h3 id="扩展语法">扩展语法</h3><h4 id="任务列表语法">任务列表语法</h4><p>短横杠 - 加方括号 [ ] （都有空格） <br/> 选择（复选框）则用 x替换方括号中的空格：[x]</p><p>效果：</p><ul class="task-list"><li><label><input type="checkbox"checked="" />这是一个复选框</label></li><li><label><input type="checkbox" />这是一个普通任务项</label></li></ul><h4 id="注意事项">注意事项</h4><p>使用hexo-renderer-pandoc渲染器，卸载了hexo自带的marked渲染器后，有些Markdown语法格式与LaTex语法格式冲突，因此需要注意以下几点：</p><ol type="1"><li>不要在代码块(`划定的区域)中插入公式，会无法解析/渲染</li><li>引用&gt;时，或者用其他符号如任务列表语法-[]、标题#时，最好单独成行，前、后各空一行，LaTex对“吃”空格/行</li><li>使用公式要在Front-matter中指定："math: true"</li><li>有脚注时，要在文末空个两行，防止脚注紧贴正文，正文格式会影响脚注的显示格式(注释会在文章最后显示)</li><li>空一行及以上，渲染结果就是内容之间间隔一行；换行渲染后仅相当于空格；可用&lt;br/&gt;来换行</li><li>不要在$后面随意加空格(插入公式时)</li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这是一个脚注^_^<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>auxiliary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/24/HelloWorld/"/>
    <url>/2023/11/24/HelloWorld/</url>
    
    <content type="html"><![CDATA[<p>This is my first article.</p><p>In order to create my own blog, I studied for several days, andfinally achieved initial results.</p><hr /><p>I've been studying for days to create a blog of my own, and I'mfinally getting there.</p><p>This shows that it is very important to learn English well.</p>]]></content>
    
    
    <categories>
      
      <category>Default</category>
      
    </categories>
    
    
    <tags>
      
      <tag>foreword</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
