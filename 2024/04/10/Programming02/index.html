

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/planet.png">
  <link rel="icon" href="/img/planet.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zenitsu">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++与C语言的区别 C++是C语言的超集（但网上很多文章说这是不对的），这意味着几乎所有的C程序都可以在C++编译器中编译和运行。然而，C++引入了许多新的概念和特性，使得两种语言在一些关键点上有显著的区别。以下是C和C++的一些主要区别。 面向对象编程：C++支持面向对象编程（OOP），包括类、对象、继承、封装、多态等特性。这使得C++更适合大型软件项目，因为OOP可以提高代码的重用性和可">
<meta property="og:type" content="article">
<meta property="og:title" content="码农日记 · 贰">
<meta property="og:url" content="https://afly36-swordsman.github.io/2024/04/10/Programming02/index.html">
<meta property="og:site_name" content="Mark | Learning &amp; Routine">
<meta property="og:description" content="C++与C语言的区别 C++是C语言的超集（但网上很多文章说这是不对的），这意味着几乎所有的C程序都可以在C++编译器中编译和运行。然而，C++引入了许多新的概念和特性，使得两种语言在一些关键点上有显著的区别。以下是C和C++的一些主要区别。 面向对象编程：C++支持面向对象编程（OOP），包括类、对象、继承、封装、多态等特性。这使得C++更适合大型软件项目，因为OOP可以提高代码的重用性和可">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://afly36-swordsman.github.io/img/stage2/006.jpg">
<meta property="og:image" content="https://afly36-swordsman.github.io/img/stage2/007.jpg">
<meta property="og:image" content="https://afly36-swordsman.github.io/img/stage2/008.jpg">
<meta property="og:image" content="https://afly36-swordsman.github.io/img/stage2/010.jpg">
<meta property="article:published_time" content="2024-04-10T13:52:25.975Z">
<meta property="article:modified_time" content="2025-03-23T03:28:16.260Z">
<meta property="article:author" content="Zenitsu">
<meta property="article:tag" content="study">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://afly36-swordsman.github.io/img/stage2/006.jpg">
  
  
  
  <title>码农日记 · 贰 - Mark | Learning &amp; Routine</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"afly36-swordsman.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":40,"cursorChar":"✨","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>M.E.Mark&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/taiji.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">码农日记 · 贰</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-10 21:52" pubdate>
          2024.04.10 21:52
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          28k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          35 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">码农日记 · 贰</h1>
            
              <p class="note note-info">
                
                  
                    Last updated on March 23, 2025 am
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="c与c语言的区别">C++与C语言的区别</h2>
<p>C++是C语言的超集（但网上很多文章说这是不对的），这意味着几乎所有的C程序都可以在C++编译器中编译和运行。然而，C++引入了许多新的概念和特性，使得两种语言在一些关键点上有显著的区别。以下是C和C++的一些主要区别。</p>
<p>面向对象编程：C++支持面向对象编程（OOP），包括类、对象、继承、封装、多态等特性。这使得C++更适合大型软件项目，因为OOP可以提高代码的重用性和可读性。C语言是一种过程性语言，没有这些特性。</p>
<p>STL（Standard Template
Library）：C++提供了STL，这是一套强大的模板类和模板函数的库，包括列表、向量、队列、栈、关联数组等。这些可以大大提高开发效率。C语言没有内置的数据结构库。</p>
<p>异常处理：C++提供了异常处理机制，可以更优雅地处理错误情况。C语言处理错误通常依赖于函数返回值。</p>
<p>构造函数和析构函数：C++支持构造函数和析构函数，这些特殊的函数允许对象在创建和销毁时执行特定的代码。C语言没有这个概念。</p>
<p>运算符重载：C++允许运算符重载（本质上仍是函数的重载），这意味着开发者可以更改已有运算符的行为，或者为用户自定义类型添加新的运算符。C语言不支持运算符重载。</p>
<p>例如，如果我们要创建一个复数类并对其进行算术运算，C++的面向对象和运算符重载特性就非常有用。我们可以定义一个复数类，然后重载+、-、*运算符以执行复数的加法、减法和乘法。这样，我们就可以像处理内置类型一样处理复数对象。反观C语言，我们需要定义结构体来存储复数，并且需要写一堆函数来处理复数的加法、减法和乘法，很不方便。</p>
<h2 id="c和java的核心区别">C++和Java的核心区别</h2>
<p>C++和Java都是广泛使用的编程语言，但它们在设计理念、功能和用途上有很大的不同。以下是C++和Java的几个核心区别：</p>
<p>运行环境：Java是一种解释型语言，它的代码在JVM（Java虚拟机）上运行，这使得Java程序可以在任何安装有JVM的平台上运行，实现了“一次编写，到处运行”的理念。而C++是一种编译型语言，其代码直接编译成目标机器的机器码运行，因此需要针对特定平台编译。</p>
<p>内存管理：Java有自动内存管理和垃圾回收机制，程序员不需要直接管理内存。而在C++中，程序员需要手动进行内存的分配和释放，这提供了更大的控制力，但同时也增加了内存泄漏的风险。</p>
<p>面向对象编程：Java是一种纯面向对象的编程语言，所有的代码都需要包含在类中。与此不同，C++支持面向对象编程，但它也允许过程式编程（兼容C）。</p>
<p>错误处理：Java使用异常处理机制进行错误处理，而C++既支持异常处理，也支持通过返回值进行错误处理（C的机制）。</p>
<p>多线程：Java内置了对多线程的支持，而C++在C++11标准之后才引入了对多线程的支持。</p>
<p>性能：因为C++的代码直接编译为机器码，所以它通常比Java程序运行得更快。但是，Java的跨平台能力和内置的垃圾回收机制使其在开发大型企业级应用时更具优势。</p>
<p>例如，如果你正在开发一个需要直接访问硬件，或者需要高性能数学计算的应用（比如游戏、图形渲染、科学计算），C++可能是一个更好的选择。而如果你正在开发一个大型的企业级web应用，Java的跨平台能力、内置的垃圾回收和强大的类库可能会更有优势。</p>
<h2 id="编译型和解释型的区别">编译型和解释型的区别</h2>
<p>原文链接：<a
target="_blank" rel="noopener" href="https://blog.csdn.net/DaJian35/article/details/81368548">一文了解编译型语言和解释型语言之区别</a>。</p>
<p>编译型语言的定义：编译型语言首先是将源代码编译生成机器指令，再由机器运行机器码（二进制）。</p>
<p>解释型语言的定义：解释型语言的源代码不是直接翻译成机器指令，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。</p>
<p>打个比方：</p>
<p>编译型相当于用中英文词典（翻译器）将一本英文书一次性翻译（编译）成一本中文书，以后查看直接就是中文了。可想而知，以后读书（运行）会非常非常方便。C、C++都是编译型语言，在执行前一定要先编译一下，通过编译器去生成一个类似
.exe 的二进制文件。如果发现语法错误，就会发出编译不通过的提示。</p>
<p>解释型相当于用中英文词典（翻译器）将一本英文书读一段翻译一段（解释）变成中文。以后查看时还是需要重新翻译。这样效率会低一些，必须依赖解释器，但是跨平台性好，只要有解释器就可以运行代码。像Matlab、Python等都是一边执行一边解释的语言，解释是一句一句的翻译，从而不需要预先进行编译，所以称之为解释型语言。</p>
<p>扩展：编译型和解释型的定义是对立存在的，但也可以在一个语言中同时存在。比如
java 语言同时兼有编译型和解释型两种特点。整个流程如下：</p>
<p>将源代码（.java 文件）编译生成字节码（.class 文件），再通过 JVM（java
虚拟机）运行生成机器指令，由机器运行机器码。注意，此处生成机器语言的操作是解释型，每次运行都要重新解释。因此，此处表明
java 是解释型语言。</p>
<p>但是，部分 JVM（java 虚拟机）有一种 JIT（Just in
time）机制，能够将部分已经解释（“翻译”）的常用机器指令保存起来。下次不需要重新解释这部分了，直接运行即可。此时
java 是编译型语言。</p>
<p>关于移植性：</p>
<p>编译性语言例如C语言：用C语言开发了程序后，需要通过编译器把程序编译成机器语言（即计算机识别的二进制文件，因为不同的计算机操作系统可能不同，识别的二进制文件也是不同的），所以C语言程序进行移植后，要重新编译。</p>
<p>解释性语言例如Java语言：Java程序首先通过编译器编译成.class文件，如果在Windows平台上运行，则通过Windows平台上的Java虚拟机（JVM）进行解释。如果运行在Linux平台上，则通过Linux平台上的Java虚拟机进行解释执行。所以说能跨平台，前提是平台上必须要有相匹配的JVM。如果没有JVM，则不能进行跨平台。</p>
<h2 id="c变量的声明和定义">C++变量的声明和定义</h2>
<p>在C++中，变量的声明和定义是两个不同的概念。</p>
<p>声明是告诉编译器某个变量的存在，以及它的类型。声明并不分配存储空间。例如，外部变量的声明<code>extern int a;</code>，这里只是告诉编译器有一个类型为int的变量a存在，具体的a在哪里定义的，编译器此时并不知道。</p>
<p>定义是声明的延伸，除了声明变量的存在和类型以外，还分配了存储空间。例如，<code>int a;</code>就是一个定义，编译器在这里为a分配了足够的存储空间来存储一个整数。</p>
<p>在C++中，一个变量可以被声明多次，但只能被定义一次。例如，我们可以在多个文件中声明同一个变量，但只能在一个文件中定义它。如果在多个地方定义同一个变量，编译器会报错。</p>
<p>举个例子，假设我们正在编写一个大型程序，这个程序有一个全局变量需要在多个文件中使用。我们可以在一个文件中定义这个变量，然后在其他需要使用这个变量的文件中声明它。这样，所有的文件都可以访问到这个变量，但只有一个文件（定义它的那个文件）负责管理它的存储空间。</p>
<h2 id="静态链接和动态链接">静态链接和动态链接</h2>
<p>静态链接和动态链接是两种不同的程序链接方式，它们主要的区别在于链接的时间和方式。</p>
<p>静态链接：在静态链接中，所有代码（包括程序本身的代码和它依赖的库的代码）都会在编译时期被合并为一个可执行文件。这个可执行文件包含了程序运行所需的所有信息，因此它不依赖于任何外部的库文件。静态链接的优点是部署简单，因为不需要额外的依赖，只需要一个文件就可以运行。缺点是可执行文件通常会比动态链接的大，因为它包含了所有需要的代码，而且如果库更新，程序需要重新编译和链接。</p>
<p>动态链接：在动态链接中，程序的代码和它依赖的库的代码被分开。程序的可执行文件只包含了程序本身的代码和一些标记，这些标记表示程序在运行时需要链接到哪些库。当程序运行时，操作系统会负责加载这些库并进行链接。动态链接的优点是可执行文件更小，因为它不包含库的代码，而且多个程序可以共享同一份库，节省内存。此外，如果库更新，只需要替换库文件，程序无需重新编译和链接。缺点是部署稍微复杂一些，因为需要确保运行环境中有所需的库文件。</p>
<p>例如，假设我们有一个程序，它使用了一个数学库。如果我们静态链接这个库，那么所有的数学函数都会被包含在我们的可执行文件中，我们可以将这个文件复制到任何地方运行。如果我们动态链接这个库，那么我们的可执行文件就会小得多，但如果我们想在另一台机器上运行这个程序，我们就需要确保那台机器上也安装了这个数学库。</p>
<h2 id="宏定义函数和typedef">宏定义、函数和typedef</h2>
<h3 id="宏定义和函数">宏定义和函数</h3>
<p>宏定义（#define）和函数是两种常见的在C++中编写代码的方式，但它们有一些重要的区别：</p>
<p>编译阶段：宏定义是在预处理阶段展开的，而函数是在编译阶段处理的。这意味着使用宏定义的代码在编译前就已经被预处理器替换掉了，而函数在编译阶段会生成对应的函数调用。</p>
<p>类型检查：函数在编译时会进行类型检查，而宏定义不会。这可能会导致宏定义在使用时出现错误，而在编译阶段并不会被发现。</p>
<p>效率：由于宏定义在预处理阶段就被替换，因此它没有函数调用的开销（如堆栈操作），所以在某些情况下可能更快。然而，过度使用宏定义可能会导致编译后的代码体积增大，因为每次使用宏都会插入一份宏的代码副本。</p>
<p>封装：函数提供了更好的封装，使得代码更易于阅读和维护。而宏定义由于其替换性质，可能会在复杂的表达式中产生不易察觉的错误。</p>
<h3 id="宏定义和typedef">宏定义和typedef</h3>
<p>宏定义 #define
在预处理期间将宏展开，并替换宏定义中的代码。预处理器只进行简单的文本替换，不涉及类型检查。宏定义可以用来替换数据类型、值或者代码。宏定义没有作用域限制，只要在宏定义之后的地方，就可以使用宏，通常用于定义常量、简单的表达式或简单的代码片段。宏定义不支持模板，因此不能用于定义模板类型别名。</p>
<p>typedef
是一种类型定义关键字，用于为现有类型创建新的名称（别名）。与宏定义不同，typedef
是在编译阶段处理的，有更严格的类型检查。typedef 遵循 C++
的作用域规则，可以受到命名空间、类等结构的作用域限制，通常用于定义复杂类型的别名，使代码更易读和易于维护。typedef
可以与模板结合使用，但在 C++11 之后，推荐使用 using
关键字定义模板类型别名。</p>
<h2 id="c文件操作">C++文件操作</h2>
<h3 id="文件和文件流对象">文件和文件流对象</h3>
<figure>
<img src="/img/stage2/006.jpg" srcset="/img/loading.gif" lazyload alt="文件和文件流对象" />
<figcaption aria-hidden="true">文件和文件流对象</figcaption>
</figure>
<h3 id="文本文件和二进制文件的读写">文本文件和二进制文件的读写</h3>
<figure>
<img src="/img/stage2/007.jpg" srcset="/img/loading.gif" lazyload alt="文本文件和二进制文件的读写操作" />
<figcaption
aria-hidden="true">文本文件和二进制文件的读写操作</figcaption>
</figure>
<h3 id="文件定位eof和字符串流">文件定位、EOF和字符串流</h3>
<figure>
<img src="/img/stage2/008.jpg" srcset="/img/loading.gif" lazyload alt="文件定位、EOF和字符串流" />
<figcaption aria-hidden="true">文件定位、EOF和字符串流</figcaption>
</figure>
<h3 id="二进制和文本的区别">二进制和文本的区别</h3>
<p>用文本码形式输出的数据是与字符一一对应的，一个字节代表一个字符，可以直接在屏幕上显示或打印出来。这种方式使用方便，比较直观，便于阅读，便于对字符逐个进行输入输出。但一般占用存储空间较多，而且要花费时间转换。</p>
<p>用二进制形式输出数值，可以节省外存空间，而且不需要转换时间，但一个字节并不对应一个字符，不能直接显示文件中的内容。如果在程序运行过程中有些中间结果数据暂时保存在磁盘文件中，以后又需要输入到内存，这时用二进制文件保存是最合适的。如果是为了能显示和打印以供阅读，则应按文本形式输出。此时得到的是文本文件，它的内容可以直接在显示屏上观看。</p>
<h3 id="综合应用">综合应用</h3>
<p>学校要输入5位学生的信息，将他们的信息存到磁盘文件中，并将第1、3、5位学生数据读入程序显示。第3位学生录入信息有误，需要对其进行修改后存入磁盘文件的原来位置。最后，从磁盘文件读取5位学生的信息并显示。</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> &#123;  <span class="hljs-comment">// 结构体</span>
    <span class="hljs-type">int</span> num;
    <span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];
    <span class="hljs-type">float</span> score;
&#125;;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 定义结构体数组存入学生的信息</span>
    student stu[<span class="hljs-number">5</span>] = &#123;
        <span class="hljs-number">1001</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">97</span>,
        <span class="hljs-number">1002</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">85.5</span>,
        <span class="hljs-number">1008</span>, <span class="hljs-string">&quot;王六&quot;</span>, <span class="hljs-number">54.5</span>,
        <span class="hljs-number">1004</span>, <span class="hljs-string">&quot;三体人&quot;</span>, <span class="hljs-number">73</span>,
        <span class="hljs-number">1005</span>, <span class="hljs-string">&quot;秦始皇&quot;</span>, <span class="hljs-number">99.3</span>
    &#125;;
    <span class="hljs-comment">// 用 fstream 类定义输入输出二进制文件流对象 iofile</span>
    <span class="hljs-function">fstream <span class="hljs-title">iofile</span><span class="hljs-params">(<span class="hljs-string">&quot;D:/Others/Afly/Temporary/file.txt&quot;</span>, ios::in|ios::out|ios::binary)</span></span>;
    <span class="hljs-keyword">if</span>(!iofile) &#123;
        <span class="hljs-comment">// 标准错误流 cerr 不经过缓冲区直接向显示器输出错误信息</span>
        cerr &lt;&lt; <span class="hljs-string">&quot;open error!&quot;</span> &lt;&lt; endl;
        <span class="hljs-built_in">abort</span>();  <span class="hljs-comment">// 不进行任何清理工作，直接终止程序</span>
    &#125;

    <span class="hljs-comment">// 向磁盘文件写入5个学生的信息</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++) &#123;
        <span class="hljs-comment">// 将 &amp;stu[i] 作为开头指向的 sizeof(stu[i]) 字节的信息写入 iofile 流对象对应的磁盘文件中</span>
        iofile.<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span>*)&amp;stu[i], <span class="hljs-built_in">sizeof</span>(stu[i]));
    &#125;
    student stud[<span class="hljs-number">5</span>];  <span class="hljs-comment">// 存放从磁盘文件中读入的数据</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i+=<span class="hljs-number">2</span>) &#123;
        <span class="hljs-comment">// 利用 seekg 函数将文件指针从开头向后移动 i*sizeof(stud[i]) 个字节，定位到索引i的位置</span>
        iofile.<span class="hljs-built_in">seekg</span>(i*<span class="hljs-built_in">sizeof</span>(stud[i]), ios::beg);
        <span class="hljs-comment">// 将 iofile 对应文件中大小为 sizeof(stud[0]) 的（3个）数据读入 &amp;stud 指向的内存中</span>
        iofile.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;stud[i/<span class="hljs-number">2</span>], <span class="hljs-built_in">sizeof</span>(stud[<span class="hljs-number">0</span>]));
        <span class="hljs-comment">// 输出第1、3、5位学生的信息</span>
        cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个学生: &quot;</span> &lt;&lt; stud[i].num &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stud[i].name &lt;&lt; <span class="hljs-string">&quot; &quot;</span>
        &lt;&lt; stud[i].score &lt;&lt; endl;
    &#125;
    cout &lt;&lt; endl;

    <span class="hljs-comment">// 修改第3位学生的信息</span>
    stud[<span class="hljs-number">2</span>].num = <span class="hljs-number">1003</span>;
    stud[<span class="hljs-number">2</span>].name = <span class="hljs-string">&quot;王者荣耀&quot;</span>;  <span class="hljs-comment">// 会报错，字符数组不允许这样赋值</span>
    <span class="hljs-built_in">strcpy</span>(stud[<span class="hljs-number">2</span>].name, <span class="hljs-string">&quot;王者荣耀&quot;</span>);  <span class="hljs-comment">// 正确</span>
    stud[<span class="hljs-number">2</span>].score = <span class="hljs-number">60</span>;

    <span class="hljs-comment">// 定位第3位学生的信息存储位置</span>
    iofile.<span class="hljs-built_in">seekp</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">sizeof</span>(stud[<span class="hljs-number">2</span>]), ios::beg);
    <span class="hljs-comment">// 把第3位学生修改后的信息存入磁盘文件中（更新数据）</span>
    iofile.<span class="hljs-built_in">write</span>((<span class="hljs-type">char</span>*)&amp;stud[<span class="hljs-number">2</span>], <span class="hljs-built_in">sizeof</span>(stud[<span class="hljs-number">2</span>]));
    iofile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::beg);  <span class="hljs-comment">// 重新定位文件开头</span>
    
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++) &#123;
        <span class="hljs-comment">// 读取5个学生的信息</span>
        iofile.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;stu[i], <span class="hljs-built_in">sizeof</span>(stu[i]));
        <span class="hljs-comment">// 打印输出</span>
        cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个学生: &quot;</span> &lt;&lt; stud[i].num &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stud[i].name &lt;&lt; <span class="hljs-string">&quot; &quot;</span>
        &lt;&lt; stud[i].score &lt;&lt; endl;
    &#125;
    iofile.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 关闭文件</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>
<p>注意：编码方式不同可能会导致乱码问题。</p>
<h2 id="c泛型编程-模板">C++泛型编程: 模板</h2>
<p>泛型（generic
type）就是不使用具体数据类型（如int、double、float等），而是使用一种通用类型来进行程序设计，泛泛的描述一下数据，相当于一种占位符，这个方法可以大规模的减少程序代码的编写量。使用泛型进行编程就叫泛型编程。总之，泛型也是一种数据类型，是用来代替所有类型的“通用类型”。在C++中，泛型的实现就是模板（Template）。</p>
<h3 id="模板的基础">模板的基础</h3>
<p>模板是C++实现参数化多态的工具，是一个比较新的重要特性。模板有两类：函数模板、类模板。使用模板可以为函数或类声明一种“一般模式”，使得类中的某些数据成员或成员函数的参数、返回值可取任意类型。具体的类型在调用函数或者定义对象时确定。模板可以实现类型的参数化，即把类型定义为参数，从而实现代码的可重用性。如果类的数据成员类型不能确定时，就必须将此类声明为模板，代表这一类的类。</p>
<p>模板就是把功能相似、仅数据类型不同的函数或类设计为通用的函数模板或类模板（蓝图），提供给用户。像函数重载，需要写很多个不同参数类型或个数的函数，而定义模板，只需要写一个，大大提高代码重用率。而且函数模板也可以重载。</p>
<p><font color="purple">传入不同的模板参数，函数模板会生成不同的模板函数，类模板则生成不同的模板类。</font></p>
<p>模板定义以关键字 template 开始，后接模板参数列表，用 "&lt;&gt;"
括起来。template
标志着模板声明的开始，告诉C++编译器要声明模板了，不能随便报错。</p>
<p>模板形参类型的关键字有两个：typename、class。这两个类型关键字的作用完全一样，typename
的引入主要是想区分函数模板和类模板，一般约定：typename
用于函数模板的创建，class
用于类模板的创建。实际上，二者完全可以相互替换。</p>
<h3 id="函数模板">函数模板</h3>
<p>函数模板就是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟类型（通用类型参数）来代表。</p>
<p>函数模板是一种模板，是模板函数的抽象，定义中要用到通用类型参数；模板函数是实实在在的函数，是函数模板的实例，具有程序代码，占用内存空间，是实际存在的。在调用函数模板时，编译系统会根据实参的类型取代模板中的虚拟类型，从而生产相应的具体模板函数，然后实现功能。</p>
<p>函数模板不允许自动类型转换，而普通函数可以，比如在普通函数中，若存在较小的数据类型和较大的数据类型同时参与运算时，小的会自动（隐式的）转为大的，例如
bool、char 可以转为
int。C++编译器优先考虑普通函数，如果普通函数不匹配，或者说函数模板更匹配实参数据类型，那么才选择模板。函数模板可以隐式实例化，也可以显式实例化。如果要限定编译器使用模板而不使用普通函数，那么需要显式实例化。</p>
<p>使用示例：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 定义模板</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fswap</span><span class="hljs-params">(T&amp; x, T&amp; y)</span> </span>&#123;
    T temp;
    temp = x; x = y; y = temp;
&#125;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 参数名 T 在不同模板间可以重复使用</span>
<span class="hljs-function">T <span class="hljs-title">fadd</span><span class="hljs-params">(T a, T b)</span> </span>&#123;
    <span class="hljs-keyword">return</span> a+b;
&#125;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fadd</span><span class="hljs-params">(T1 a, T2 b)</span> </span>&#123;  <span class="hljs-comment">// 模板的重载</span>
    <span class="hljs-keyword">return</span> a+b;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">6</span>; <span class="hljs-type">char</span> z = <span class="hljs-string">&#x27;a&#x27;</span>;
    <span class="hljs-type">float</span> m = <span class="hljs-number">3.5</span>, n = <span class="hljs-number">6.7</span>;

    <span class="hljs-built_in">fadd</span>(x, y);  <span class="hljs-comment">// 11</span>
    <span class="hljs-built_in">fadd</span>(m, n);  <span class="hljs-comment">// 10.2</span>

    <span class="hljs-comment">// 已经重载了混合类型数据计算的加法函数</span>
    <span class="hljs-built_in">fadd</span>(x, m);  <span class="hljs-comment">// 若没有 fadd(T1 a, T2 b) 函数会报错: 不允许为同一个模板类型形参指定两种不同的类型</span>
    <span class="hljs-built_in">fadd</span>(z, y);  <span class="hljs-comment">// 若没有 fadd(T1 a, T2 b) 函数会报错: 因为函数模板不能实现自动类型转换</span>
    <span class="hljs-built_in">fswap</span>(&amp;x, &amp;y);  <span class="hljs-comment">// 错误: 实参赋给形参时, 左右值类型不匹配, 赋值失败</span>

    <span class="hljs-built_in">fswap</span>(x, y);  <span class="hljs-comment">// 隐式调用, 自动数据类型推导</span>
    <span class="hljs-built_in">fswap</span>&lt;<span class="hljs-type">int</span>&gt; (x, y);  <span class="hljs-comment">// 显式类型调用 (实例化)</span>
    fswap&lt;&gt; (x, y);  <span class="hljs-comment">// 显式调用模板</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* 还可以这样定义函数模板 */</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">fadd</span><span class="hljs-params">(T a, <span class="hljs-type">int</span> b)</span> </span>&#123;  <span class="hljs-comment">// 形参类型可由用户自定义</span>
    <span class="hljs-keyword">return</span> a+b;
&#125;</code></pre></div>
<h3 id="类模板的使用">类模板的使用</h3>
<p>类模板的定义和使用与函数模板类似。</p>
<p>类模板的参数可以是类型参数（由关键字typename或class修饰的参数，如
T），也可以是非类型参数（某些内置类型，如int
a）。注意：非类型形参在模板定义的内部是常量，且只能是整型、指针和引用。比如
int、double&amp;、float* 是可以的，但 double、string
等不行。调用非类型模板形参的实参必须是常量表达式（能在编译时计算出结果），全局对象的地址、const
类型变量、sizeof() 结果都是常量表达式，可以作为实参。</p>
<p>若全局域有变量名与类模板中的模板参数名相同，那么该变量会被隐藏。模板参数名不能是类中成员的名字，同一个模板参数名在模板参数表中只能出现一次。不同的类模板声明中，模板参数名可以重复使用。</p>
<p>类模板形参列表中 class T 是形参，实参值被提供给 T
后，系统将会根据实参的具体类型创建一个模板类，该类是真实存在的，这个过程叫类模板的实例化。函数模板的实例化是编译程序在处理函数调用时自动完成的，而类模板的实例化须由程序员在程序中显式的指定。</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;  <span class="hljs-comment">// 定义模板</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Compare</span>(T a, T b) &#123;  <span class="hljs-comment">// 模板内定义数据成员</span>
        c_x = a; c_y = b;
    &#125;
    <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (c_x &gt; c_y) ? c_x : c_y;
    &#125;
    <span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    T c_x, c_y;
&#125;;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;  <span class="hljs-comment">// 在类模板外定义成员函数</span>
T Compare&lt;T&gt;::<span class="hljs-built_in">min</span>() &#123;
    <span class="hljs-keyword">return</span> (c_x &lt; c_y) ? c_x : c_y;
&#125;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> size = <span class="hljs-number">1</span>&gt;  <span class="hljs-comment">// 缺省参数 (指定缺省值/默认值, 是常量)</span>
<span class="hljs-keyword">class</span> Myclass1 &#123;
<span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 无构造函数, 仅作为例子</span>
    T <span class="hljs-built_in">func</span>(T a) &#123;
        <span class="hljs-keyword">return</span> a + size;
    &#125;
&#125;;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> size&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass2</span> &#123;  <span class="hljs-comment">// size 在该类中是个常量</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">T <span class="hljs-title">func</span><span class="hljs-params">(T a)</span> </span>&#123;
        <span class="hljs-keyword">return</span> a + size;
    &#125;
&#125;;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-function">Compare&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>)</span></span>;  <span class="hljs-comment">// 必须显式指定形参类型进行类模板的实例化</span>
    cmp.<span class="hljs-built_in">max</span>();  <span class="hljs-comment">// 返回: 7</span>
    cmp.<span class="hljs-built_in">min</span>();  <span class="hljs-comment">// 返回: 5</span>
    Myclass1&lt;<span class="hljs-type">int</span>&gt; mc1;  <span class="hljs-comment">// size 取默认值: 1</span>
    cout &lt;&lt; mc1.<span class="hljs-built_in">func</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出: 6 (5 + 1)</span>
    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>; <span class="hljs-type">const</span> <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;
    Myclass2&lt;<span class="hljs-type">int</span>, x&gt; mc2;  <span class="hljs-comment">// 错误: x 不是常量</span>
    Myclass2&lt;<span class="hljs-type">int</span>, y&gt; mc2;  <span class="hljs-comment">// 正确, y 是常量</span>
    Myclass2&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; mc2;  <span class="hljs-comment">// 正确, 2 是常量 (字面量)</span>
    cout &lt;&lt; mc2.<span class="hljs-built_in">func</span>(<span class="hljs-number">8</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出: 10 (8 + 2)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; 
&#125;</code></pre></div>
<h3 id="模板的特化">模板的特化</h3>
<p>模板参数在某种特定类型下的具体实现叫模板的特化，有时也叫模板的具体化（我个人认为这个名字不好，模板实例化又何尝不是一种具体化呢？）。</p>
<p>模板特化分别包括：函数模板的特化和类模板的特化。</p>
<p>函数模板的特化，发生在函数模板需要对某些类型进行特别处理的时候。看下面这个例子：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-comment">/* 常见类型如 int char double 等数据的比较 */</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(T a, T b)</span> </span>&#123;
    <span class="hljs-keyword">return</span> (a == b);
&#125;
<span class="hljs-comment">/* 对 char* 类型字符串进行比较, 就需要对函数模板进行特化 */</span>
<span class="hljs-keyword">template</span> &lt;&gt;  <span class="hljs-comment">// 特化标志</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(<span class="hljs-type">char</span>* t1, <span class="hljs-type">char</span>* t2)</span> </span>&#123;  <span class="hljs-comment">// 写法 1</span>
<span class="hljs-type">bool</span> <span class="hljs-built_in">comp</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-type">char</span>* t1, <span class="hljs-type">char</span>* t2) &#123;  <span class="hljs-comment">// 写法 2</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(t1, t2) == <span class="hljs-number">0</span>);  <span class="hljs-comment">// 等于 0 表示两字符串相同</span>
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">/* 字符串比较测试 */</span>
    string s1 = <span class="hljs-string">&quot;123&quot;</span>, s2 = <span class="hljs-string">&quot;123&quot;</span>;
    cout &lt;&lt; (s1 == s2) &lt;&lt; endl;  <span class="hljs-comment">// 1</span>
    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello&quot;</span>, str2[] = <span class="hljs-string">&quot;hello&quot;</span>;
    <span class="hljs-comment">// str1、str2 代表数组地址, 下面写法表示将两个地址进行比较, 而不是对数组中字符串比较</span>
    cout &lt;&lt; (str1 == str2) &lt;&lt; endl;  <span class="hljs-comment">// 0</span>

    <span class="hljs-comment">// 利用特化的函数模板进行实例化, 以实现特殊的要求</span>
    cout &lt;&lt; <span class="hljs-built_in">comp</span>(str1, str2) &lt;&lt; endl;  <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>
<p>同理，类模板中需要对某些类型进行特别处理时，可以使用类模板的特化。需要注意的是，进行类模板的特化时，需要特化所有的（涉及通用类型参数的）成员变量和成员函数。</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Comp</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fun</span><span class="hljs-params">(T a, T b)</span> </span>&#123;
        <span class="hljs-keyword">return</span> (a == b);
    &#125;
&#125;;

<span class="hljs-comment">/* 下面这种定义, 是比较规范的, 不会漏掉某些数据成员 */</span>
<span class="hljs-keyword">template</span> &lt;&gt;  <span class="hljs-comment">// 特化标志</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Comp</span>&lt;<span class="hljs-type">char</span>*&gt; &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> *t1, <span class="hljs-type">char</span> *t2)</span> </span>&#123;
        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(t1, t2) == <span class="hljs-number">0</span>);
    &#125; 
&#125;;
<span class="hljs-comment">/* 下面这种定义是简化写法, 涉及通用类型参数(T)的数据成员已被全部特化, 也是可行的 */</span>
<span class="hljs-keyword">template</span> &lt;&gt;  <span class="hljs-comment">// 特化标志</span>
<span class="hljs-type">bool</span> Comp&lt;<span class="hljs-type">char</span>*&gt;::<span class="hljs-built_in">fun</span>(<span class="hljs-type">char</span>* t1, <span class="hljs-type">char</span>* t2) &#123;
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">strcmp</span>(t1, t2) == <span class="hljs-number">0</span>);
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello&quot;</span>;
    <span class="hljs-type">char</span> str2[] = <span class="hljs-string">&quot;hello&quot;</span>;
    Comp&lt;<span class="hljs-type">int</span>&gt; c1; Comp&lt;<span class="hljs-type">char</span>*&gt; c2;
    c1.<span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 返回: 0</span>
    c2.<span class="hljs-built_in">fun</span>(str1, str2);  <span class="hljs-comment">// 返回: 1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>
<p>如果只想对类模板中的某些通用类型参数进行特化，并非对其全部的通用类型参数进行特化，那么可以使用类模板的<font color="purpleblack">偏特化</font>，也叫部分特化。例如：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; ... &#125;;

<span class="hljs-comment">/* 仅对 T2 进行特化 */</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>&gt;  <span class="hljs-comment">// 这里必须要列出未特化的模板参数: T1</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;T1, <span class="hljs-type">int</span>&gt;  <span class="hljs-comment">// A 的后面要列出全部模板参数, 并指定特化的类型: 指定 int 为 T2 的特化类型</span>
&#123; ... &#125;;</code></pre></div>
<h2 id="java-接口vs抽象类">Java: 接口vs抽象类</h2>
<h3 id="抽象类abstract-class">抽象类(abstract class)</h3>
<p>类，由 class 定义。类是对事物的抽象，表示这个对象是什么。</p>
<p>由于多态的存在，每个子类都可以覆写父类的方法，例如：</p>
<div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; … &#125;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; … &#125;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; … &#125;
&#125;</code></pre></div>
<p>从 Person 类派生的 Student 和 Teacher 都可以重写 run() 方法。如果父类
Person 的 run() 方法没有实际意义，能否去掉该方法的方法体？</p>
<p>答案是：可以。如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写（重写）它，那么，可以把父类的方法声明为抽象方法。</p>
<p>如果一个 class
定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用
abstract
修饰。因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract
class）。使用 abstract 修饰的类就是抽象类。</p>
<p>抽象类是类的抽象。我们无法实例化一个抽象类（因为它太过于抽象了，没有“实例”，只有“概念”）。因此，抽象类只能被继承。抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错（抽象类中的抽象方法没有方法体，子类如果还不去重写实现这个方法，那抽象类不就成了摆设么）。因此，抽象方法实际上相当于定义了某种“规范”。</p>
<p>例如，Person 类定义了抽象方法 run()，那么，在实现子类 Student
的时候，就必须覆写 run() 方法：</p>
<div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();
        p.run();
    &#125;
&#125;

<span class="hljs-comment">// 抽象类</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;Student.run&quot;</span>);
    &#125;
&#125;</code></pre></div>
<p>当我们定义了抽象类 Person，以及具体的 Student、Teacher
子类的时候，我们可以通过抽象类 Person
类型去引用具体的子类的实例，即父类型引用指向子类型对象（这不就是多态么），其好处不言自明。</p>
<div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-type">Person</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();
<span class="hljs-type">Person</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();

<span class="hljs-comment">// 我们对其进行方法调用，并不关心Person类型变量的具体子类型</span>
s.run();
t.run();

<span class="hljs-comment">// 若引用的是一个新的子类，我们仍然不关心新的子类是如何实现run()方法的</span>
<span class="hljs-type">Person</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();
e.run();</code></pre></div>
<p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为<strong>面向抽象编程</strong>。</p>
<p>面向抽象编程的本质就是：上层代码只定义规范（例如：abstract class
Person），不需要子类就可以实现业务逻辑（正常编译），具体的业务逻辑由不同的子类实现，调用者并不关心子类是如何实现的。</p>
<p>有抽象方法的类叫抽象类，抽象类中也可以存在非抽象方法（有具体的实现）。</p>
<h3 id="接口interface">接口(Interface)</h3>
<p>接口，由 interface
定义。接口是对动作/行为的抽象，表示这个对象能做什么。</p>
<p>接口是抽象类的变体，是比抽象类还要抽象之物。接口中所有的方法都是抽象方法。因为接口定义的所有方法默认都是
<code>public abstract</code>
的，所以这两个修饰符不需要写出来，故而也称作隐式抽象。</p>
<p>接口当然也无法实例化，接口中定义的方法需要由类去实现，当一个具体的类去实现一个接口时，需要使用
implements 关键字。一个类可以实现多个接口。</p>
<div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; run&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;
    &#125;
&#125;

<span class="hljs-comment">// 接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;
    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;
&#125;</code></pre></div>
<p>一个 interface 可以继承自另一个 interface。interface 继承自 interface
使用 extends，它相当于扩展了接口的方法。</p>
<div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;
&#125;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hello</span> &#123;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;
    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;
&#125;</code></pre></div>
<p>此时，Person 接口继承自 Hello 接口，因此，Person
接口现在实际上有3个抽象方法签名，其中一个来自继承的 Hello 接口。</p>
<p>在接口中，可以定义 default 方法，实现类可以不必重写 default
方法。</p>
<div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>);
        p.run();
    &#125;
&#125;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;
    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
        System.out.println(getName() + <span class="hljs-string">&quot; run&quot;</span>);
    &#125;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
    &#125;

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;
    &#125;
&#125;</code></pre></div>
<p>当我们需要给接口新增一个方法时，会涉及到修改全部子类，因为所有子类都要重写接口中的方法。如果新增的是
default
方法，那么子类就不必全部修改，只需要在需要重写的地方去重写新增方法即可。这就是使用
default 方法的目的所在。</p>
<p>需要注意的是，接口的 default
方法和抽象类的普通方法（非抽象方法）是有所不同的。接口没有实例字段，故
default 方法无法访问实例字段，而抽象类的普通方法可以访问实例字段。</p>
<p>接口中可以定义的字段默认且只能是 <code>public static final</code>
类型，即静态常量。</p>
<p>扩展：从 Java 8
开始，接口中可以包含默认方法和静态方法，这些方法具有方法体。从 Java 9
开始，接口允许包含私有方法。</p>
<h3 id="接口和抽象类的区别">接口和抽象类的区别</h3>
<p>接口可以多继承，而且一个类可以实现多个接口。但类（抽象类当然也是类）不能多继承，类只能单继承，不过可以取巧：多重继承。</p>
<p>接口用来表示行为、动作，类多用来表示属性。比如，男人、女人是两个类，抽象类可以描述为：人。男人、女人（人）总要吃东西的，狗、鸡也要吃东西，“吃东西”这个行为可以定义成接口，由类去实现。</p>
<p>一个子类继承了某个父类，那么就具备了其父类的属性（继承过来的），也包括一些方法。该子类也可以拥有新的方法（行为能力），此时可以通过接口进行新功能的实现。</p>
<p>抽象类的功能比接口多一些，但是抽象类定义的代价也较高，每个类只能继承一个抽象类。因此在这个父类中，必须包含其所有子类的大部分共性。对于接口而言，接口只针对某一个动作的描述，且可以在一个类中实现多个接口，因此扩展性极强。</p>
<h2 id="字段">字段</h2>
<h3 id="何为字段">何为字段</h3>
<p>在 Java
类中，字段（Fields）是用于存储对象状态的变量。它们描述了对象的特征或属性。</p>
<p>字段可以是基本数据类型（如整数、字符、布尔值等）或其他类的对象（引用数据类型）。通过定义字段，类可以持有和操作对象的数据。</p>
<p>Java中的字段可以分为两类：</p>
<ul>
<li>实例字段（Instance
Fields），每个对象都有自己独有的实例字段副本，用于存储对象特定的状态和属性。</li>
<li>静态字段（Static
Fields），静态字段属于类本身，被该类的所有实例共享，用于存储类级别的共享数据。</li>
</ul>
<p>字段通过访问修饰符控制访问权限，用于数据存储、对象间通信和数据封装。字段是一种变量，用于存储数据。它们可以在类的任何方法中使用，并在对象的整个生命周期中保持存在。</p>
<p>字段用于描述和记录对象的状态，通过修改字段的值，我们可以改变对象的状态，从而影响对象的行为和属性（数据成员）。</p>
<h3 id="static-and-final">static and final</h3>
<p>static
修饰符用于将类的成员变量或方法与类本身相关联，而不是与类的实例相关联，所有该类的对象共享同一个静态变量。</p>
<p>final 修饰符用于将类、方法或变量的值锁定，防止它们被更改。</p>
<ul>
<li>用 final
修饰的变量一旦赋值后，不能再更改。这种变量通常被称为常量。如果是对象类型的
final 变量，引用本身不能改变，但对象的内部状态可以改变。</li>
<li>用 final
修饰的方法不能被子类重写（override）。这在需要确保方法逻辑不被修改时非常有用。</li>
<li>用 final 修饰的类不能被继承。这可用于防止类的设计被改变。</li>
</ul>
<h2 id="python-模块和包">Python: 模块和包</h2>
<p>模块（Module）是最基本的代码组织单元，它是一个包含 Python
代码的文件，通常以 .py
扩展名结尾。模块可以包含函数、类、变量以及其他模块可以使用的任何东西，即一个
Python 文件中包含的东西。使用 import
导入模块，如：<code>import math</code>。</p>
<p>包（Package）是模块的容器，用于组织相关的模块。包通常是一个目录，其中包含一个特殊的
<strong>init</strong>.py
文件，这个文件可以为空，也可以包含初始化代码。包内可以放入一些模块（.py文件）。包也可以包含子包。若要导入包
settings 中的 size 模块，可用：<code>import settings.size</code>。</p>
<div class="code-wrapper"><pre><code class="hljs capnproto"><span class="hljs-keyword">from</span> xxx <span class="hljs-keyword">import</span> zzz  <span class="hljs-comment"># zzz与xxx位于同一层级目录</span>
<span class="hljs-keyword">from</span> .xxx <span class="hljs-keyword">import</span> zzz  <span class="hljs-comment"># 同上</span>
<span class="hljs-keyword">from</span> ..xxx <span class="hljs-keyword">import</span> zzz  <span class="hljs-comment"># xxx在zzz的上级目录中</span>
<span class="hljs-keyword">from</span> ...xxx <span class="hljs-keyword">import</span> zzz  <span class="hljs-comment"># xxx在zzz的上上级目录中</span></code></pre></div>
<p>第三方库（Library）是由外部开发者创建的一组相关的模块或包，用于扩展
Python 的功能，如：NumPy、Pandas 等。第三方库通常需要单独安装，可以使用
pip（Python 的包管理器）来安装，也可以用
conda（Anaconda项目开发的开源包管理系统和环境管理器）安装。安装后，可以通过导入相应的模块或包来使用库的功能。</p>
<h2 id="os篇进程的并发与同步">OS篇：进程的并发与同步</h2>
<p>操作系统（Operating
System，OS）是整个计算机系统的管理和控制中心。</p>
<h3 id="操作系统os的含义">操作系统（OS）的含义</h3>
<p><font color="purple">从计算机系统设计者的角度看</font>，OS
是由一系列程序模块组成的一个大的系统管理程序，它依据设计者设计的各种管理和调度策略，合理地组织计算机的工作流程，从而提高计算机资源（处理器CPU、缓存Cache、内存Memory、数据通路等）的利用效率。由此可认为，OS
是计算机软硬件资源的管理和控制程序。</p>
<p>调度策略包括先来先服务调度算法（First Come First Service,
FCFS）、最短作业优先调度算法（Shortest Job First,
SJF）、高响应比优先调度算法（Highest Response Ratio Next,
HRN）、优先级调度算法（Priority Scheduling / Highest Priority First,
HPF）、时间片轮转调度法（Round Robin, RR）等。</p>
<p><font color="red">从用户角度看</font>，配上 OS
的计算机是一台比裸机功能更强、使用更方便简单的智能机。也即，OS
是用户与计算机系统之间的一个接口，用户通过它来使用计算机。它向用户及其程序提供了一个良好的使用计算机的环境，通过用户态和核心态（内核态）两种模式的切换保护自身免受应用程序的损害，同时使得计算机系统变得容易维护、安全可靠、容错能力强、更加有效。</p>
<p>所谓裸机，是只包括冯诺依曼模型中的基本结构：中央处理机（即CPU，包括运算器和控制器）、存储器、输入设备和输出设备，不增加任何扩充的计算机。</p>
<p>从上面两个角度可以总结出，设计 OS
的目的有两个：一个是使用户方便、简单地使用计算机系统，另一个是使计算机系统能高效可靠地运转。</p>
<h3 id="进程和线程">进程和线程</h3>
<p>进程是为了描述操作系统中各种并发活动而引入的。<strong>进程（Process）</strong>是操作系统最基本、最重要的概念之一，是
OS
进行系统资源分配的基本单位。进程是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。</p>
<p>通俗来说，进程就是程序的一次执行过程。程序是静态的概念，可以作为一种软件资源长期保存。而进程是动态的，它把程序作为自己的运行实体，没有程序也就没有进程。进程是动态的产生、变化和消亡的，拥有自己的生命周期。进程控制块（Process
Control Block, PCB）或进程描述符（Process Descriptor,
PD）是进程存在的唯一标识，它包含系统管理进程所需的全部信息。</p>
<p>进程的生命周期：</p>
<p><img src="/img/stage2/010.jpg" srcset="/img/loading.gif" lazyload /></p>
<p>现代 OS
为了提高系统的并发程度，引入了线程的概念。<strong>线程（Thread）</strong>是处理机调度的基本对象。线程又称为迷你进程，或者说轻型进程。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，需要较大的时空开销，限制了并发程度的进一步提高。为减少进程切换的开销，把进程作为资源分配单位和调度单位这两个属性分开处理（这是进程刚被提出时的定位），即进程还是作为资源分配的基本单位，但是不作为调度的基本单位（很少调度或切换），把调度执行与切换的责任交给线程，即线程成为独立调度的基本单位。线程比进程更容易（更快）创建，也更容易撤销。</p>
<p>举个例子：进程是拥有资源的基本单位，而且还能够进行独立调度，这就犹如一个背着粮草的士兵，这必然会造成士兵执行命令（战斗）的速度。所以一个简单想法就是：分配两个士兵执行同一个命令（携带粮草战斗）：一个负责携带所需粮草随时供给，另一个负责执行战斗。这就是线程的思想。一个线程也由一个线程控制块描述，它包含系统管理线程所需的全部信息。</p>
<p><strong>区别</strong>：进程在逻辑上表示 OS
必须做的一个任务，线程表示完成这个任务的许多可能的子任务。线程是进程中的一个可执行实体，一个进程至少有一个线程，也可以有多个线程。每个进程拥有一个独立的存储空间，用来装入由若干代码段和数据段组成的实体，此外它还包含一些打开的文件。进程之间一般互不影响。一个进程的多个线程共享该进程拥有的所有资源，因此线程的上下文切换要比进程快得多。但由于资源共享，安全性就会降低，多进程比多线程可能更加安全。</p>
<h3 id="进程间的并发控制信号量机制">进程间的并发控制：信号量机制</h3>
<p>进程间的互斥是由资源共享导致的，比如两个异步进程都要执行文件打印，但打印机只有一台。</p>
<p>引入两个概念：临界资源（Critical
Resource），是一次仅允许一个进程使用的系统中的一些共享资源，包括慢速的硬设备（如打印机等），也包括软件资源（如共享变量、共享文件、各种队列等）。临界区（Critical
Section），是并发进程访问临界资源的那段必须互斥执行的程序段。</p>
<p>要保证程序在临界区的互斥执行，就不能让两个（或多个）进程同时在他们的临界区内执行，并且临界区之外的进程不可以阻止其他进程进入临界区。信号量（Semaphore）机制是荷兰学者
Dijkstra
于1965年提出的一种可以正确管理各并发进程对计算机系统中的共享资源的互斥使用和协作同步关系的同步机制。</p>
<p>信号量（用 s
表示）表示系统共享资源的物理实体，操作系统利用信号量的状态对进程和资源进行管理。信号量
s 用一个数据结构表示：</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">semaphore</span> &#123;
    <span class="hljs-type">int</span> value;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span> *list;
&#125;s;</code></pre></div>
<p>其中，value 表示该类资源的可用数量，list
是等待使用该类资源的进程排队队列的头指针。对信号量 s 的操作只允许执行
P、V
原语操作（原子操作，表示不可分割（不可中断）的操作，即要么全做，要么全不做）。P、V
源自荷兰语，翻译过来分别是 test、increment，分别表示测试和增加之意。</p>
<p>P 操作：<code>P(s)</code>，表示将信号量 s.value 的值减1。若减1后
s.value 的值为0，说明临界区内无进程，则执行 P
操作的进程继续执行。若减1后为负，则执行 P
操作的进程变为阻塞状态，并进入与该信号量有关的 list
所指队列中等待，之后转处理机调度。P 操作相当于申请资源。</p>
<p>V 操作：<code>V(s)</code>，表示将信号量 s.value 的值加1。若加1后
s.value 的值大于0，说明执行 V
操作的进程在临界区内正常完成了程序的执行过程，本进程继续前进。若加1后仍小于或等于0，则执行
V 操作的进程从与该信号量有关的 list
所指队列中释放一个进程，使其由阻塞态变为就绪态，之后本进程继续执行或者转处理机调度。V
操作相当于释放资源。</p>
<p>注：有些资料用了 wait(s) 和 signal(s) 分别取代 P(s) 和 V(s)
操作。</p>
<p>在实际操作中，引入互斥信号量 mutex
并赋初值：1。任何欲进入临界区执行的进程，必须先对 mutex 执行 P
操作，即将 mutex 的值减1。若减1后 mutex 为0，表示临界资源空闲，执行 P
操作的进程可以进入临界区执行。若减1后 mutex
为负值，说明已有进程正在临界区执行，那么本进程（执行 P
操作的进程）必须等待，直到临界区空闲为止。这样，利用信号量就可以方便解决临界区的互斥执行，从而让进程更好的同步协作。</p>
<h3 id="信号量案例展示">信号量案例展示</h3>
<p>本节由计算机中的两个经典问题为引，用伪代码的形式对进程之间并发、同步产生的互斥问题进行解读。</p>
<h4
id="案例1生产者和消费者问题the-producer-consumer-problem">案例1：生产者和消费者问题（The
Producer-Consumer Problem）</h4>
<p>计算机中进程之间的同步问题可以一般化为生产者和消费者问题。运行中的进程释放一个资源时，可将其看作生产者。而当其申请使用一个资源时，可看作消费者。例如对数据计算后打印的任务，计算进程可看作被打印数据的生产者，又可看作空缓冲区的消费者；而打印进程可看作被打印数据的消费者，也可看作空缓冲区的生产者。</p>
<p>用信号量解决这个问题，需要定义以下信号量：</p>
<ul>
<li>互斥信号量
mutex，控制生产者和消费者互斥使用缓冲区（避免打印混乱）</li>
<li>同步信号量
empty，指示空缓冲区的可用数量，制约生产者进程输送数据</li>
<li>同步信号量
full，指示装满数据的缓冲区个数，制约消费者进程取用数据</li>
<li>送、取数据（产品）的指针变量 i、j</li>
<li>临时变量 x、y，表示送、取的数据（产品）</li>
</ul>
<p>共享环形缓冲区问题描述：</p>
<div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> mutex, empty, full;
mutex=<span class="hljs-number">1</span>; empty=k; full=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 赋初值，缓冲区大小为k</span>
<span class="hljs-type">int</span> array[k];  <span class="hljs-comment">// 定义缓冲区</span>
<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 定义缓冲区送取产品的指针</span>
<span class="hljs-type">int</span> x, y;
parbegin
    producer: begin
        produce a product to x;
        <span class="hljs-built_in">P</span>(empty);  <span class="hljs-comment">// 申请一个空缓冲 (empty -= 1)</span>
        <span class="hljs-built_in">P</span>(mutex);  <span class="hljs-comment">// 申请进入缓冲区</span>
        array[i] = x;  <span class="hljs-comment">// add the product to buffer</span>
        i = (i+<span class="hljs-number">1</span>) mod k;  <span class="hljs-comment">// 以环形方式更新送产品的指针</span>
        <span class="hljs-built_in">V</span>(full);  <span class="hljs-comment">// 释放一个产品 (full += 1)</span>
        <span class="hljs-built_in">V</span>(mutex);  <span class="hljs-comment">// 退出缓冲区</span>
        ...
    end
    consumer: <span class="hljs-function">begin</span>
<span class="hljs-function">        <span class="hljs-title">P</span><span class="hljs-params">(full)</span></span>;  <span class="hljs-comment">// 申请一个产品，产品数-1</span>
        <span class="hljs-built_in">P</span>(mutex);  <span class="hljs-comment">// 申请进入缓冲区</span>
        y = array[j];  <span class="hljs-comment">// take a product from buffer</span>
        j = (j+<span class="hljs-number">1</span>) mod k;  <span class="hljs-comment">// 更新取产品的指针</span>
        <span class="hljs-built_in">V</span>(empty);  <span class="hljs-comment">// 释放一个空缓冲</span>
        <span class="hljs-built_in">V</span>(mutex);  <span class="hljs-comment">// 退出缓冲区</span>
        ...
    end
parend</code></pre></div>
<p>无论是生产者进程还是消费者进程，P
操作的顺序相当重要。如果把生产者进程中的两个 P
操作的次序交换，那么当缓冲区满时，生产者欲向缓冲区放产品时，将在
P(empty)
上等待，但它已获得了使用缓冲区的权力。若此后，消费者欲取产品，申请使用缓冲区会失败，便会在
P(mutex)
上等待。这会导致生产者等待消费者取走产品，但消费者却在等待生产者释放缓冲区的相互等待状况，造成系统发生死锁现象。</p>
<h4
id="案例2读者与写者问题the-readers-writers-problem">案例2：读者与写者问题（The
Readers-Writers Problem）</h4>
<p>一个文件可能要被多个进程共享。为了保证读写的正确性和文件的一致性，要求当有读者进程读文件时，允许多读者同时读，但不允许任何写者进程写；当有写者进程写时，既不允许其他任何写者进程写，也不允许任何读者进程读。</p>
<p>设置信号量：</p>
<ul>
<li>互斥信号量
rw_ww_mutex，用于实现读写进程互斥和写写进程互斥地访问共享文件</li>
<li>计数器变量 readcount，记录同时进行读的读者进程数</li>
<li>互斥信号量 rr_mutex，用于控制读者进程互斥地修改计数器 readcount</li>
</ul>
<p>实现读者优先的问题描述：</p>
<div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> rw_ww_mutex=<span class="hljs-number">1</span>, rr_mutex=<span class="hljs-number">1</span>;
<span class="hljs-type">int</span> readcount=<span class="hljs-number">0</span>;
parbegin
    reader: begin  <span class="hljs-comment">// 读者进程</span>
        <span class="hljs-comment">/* 开启阅读 */</span>
        <span class="hljs-built_in">P</span>(rr_mutex);  <span class="hljs-comment">// 申请对读者计数+1</span>
        <span class="hljs-keyword">if</span>(readcount==<span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 第一个读者申请文件的阅读使用权，此后若有其他的写文件进程则必须等待</span>
            <span class="hljs-built_in">P</span>(rw_ww_mutex);
        &#125;
        readcount += <span class="hljs-number">1</span>;
        <span class="hljs-built_in">V</span>(rr_mutex);  <span class="hljs-comment">// 第一个读者已经计数完成，就要释放对 readcount 的使用权</span>
        ...
        <span class="hljs-comment">/* 完成阅读，准备退出 */</span>
        <span class="hljs-built_in">P</span>(rr_mutex);  <span class="hljs-comment">// 读完退出时，申请对读者计数-1</span>
        readcount -= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(readcount==<span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 若退出的是最后一位读者，应开放该文件的使用权（写者方能使用）</span>
            <span class="hljs-built_in">V</span>(rw_ww_mutex);
        &#125;
        <span class="hljs-built_in">V</span>(rr_mutex);
        ...
    end
    writer: begin  <span class="hljs-comment">// 写者进程</span>
        ...
        <span class="hljs-built_in">P</span>(rw_ww_mutex);  <span class="hljs-comment">// 申请写文件</span>
        &lt;-- 向文件写数据 --&gt;
        <span class="hljs-built_in">V</span>(rw_ww_mutex);  <span class="hljs-comment">// 释放文件的使用权</span>
        ...
    end
parend</code></pre></div>
<h3 id="并发进程新的同步机制管程">并发进程新的同步机制：管程</h3>
<p>使用信号量往往涉及大量的 P、V
操作，这会给用户编程造成较大负担，很容易出错，且程序的易读性差、查错纠错困难，不利于修改和维护。</p>
<p>管程（Monitor）提供了一种高级的同步原语，它将共享资源和对资源的操作封装在一个单元中，并提供了对这个单元的访问控制机制。使用管程进行编程更加简单，使用方便，且容易控制。</p>
<p>Hansan 和 Hoare
在1973年提出了管程，基本思想是将共享变量以及对共享变量进行的所有操作过程集中在一个模块中。Hansan
对管程的定义是：管程是关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块。管程与C++中的类相似，它隐含了代表资源的内部表示，向外提供的只是为各方法规定的操作特性。管程保证任何时候最多只有一个进程执行管程中的代码。并发进程在请求和释放共享资源时调用管程，从而提供了互斥机制，保证管程数据的一致性。</p>
<p>一个管程包括以下四个主要部分：</p>
<ul>
<li>共享变量：管程中包含了共享的变量或数据结构，多个线程或进程需要通过管程来访问和修改这些共享资源。</li>
<li>互斥锁（Mutex）：互斥锁是管程中的一个关键组成部分，用于确保在同一时间只有一个线程或进程可以进入管程。一旦一个线程或进程进入管程，其他线程或进程必须等待，直到当前线程或进程退出管程。</li>
<li>条件变量（Condition
Variables）：条件变量用于实现线程或进程之间的等待和通知机制。当一个线程或进程需要等待某个条件满足时（比如某个共享资源的状态），它可以通过条件变量进入等待状态。当其他线程或进程满足了这个条件时，它们可以通过条件变量发送信号来唤醒等待的线程或进程。</li>
<li>管程接口（对管程进行操作的函数）：这是一组操作共享资源的接口或方法。这些接口定义了对共享资源的操作，并且在内部实现中包含了互斥锁和条件变量的管理逻辑。其他线程或进程通过调用这些接口来访问共享资源，从而确保了对共享资源的有序访问。</li>
</ul>
<p>管程的数据只能由该管程的过程存取，不允许进程和其他管程直接存取。当一个进程进入管程执行它的一个过程时，如果因某种原因而被阻塞，应立即退出该管程，否则就会阻塞其他进程进入管程，从而导致系统死锁。管程内的条件变量
c 和两个操作条件变量的同步原语 wait(c) 和 signal(c)
提供了同步机制，可以防止系统死锁，保证各进程间的有序协作。</p>
<p><code>wait(c)</code>：执行 wait(c) 的进程将自己阻塞在条件变量 c
的相应等待队列中。在阻塞前，检查有无等待进入该管程的进程。若无，阻塞自己并释放管程的互斥使用权；若有，则唤醒第一个等待者进程，以便其进入该管程。</p>
<p><code>signal(c)</code>：执行 signal(c) 的进程检查条件变量 c
的相应等待队列。如果队列为空，则该进程继续；如果不为空，唤醒 c
队列中第一个等待者进程，以便其重新进入该管程。</p>
<p>需要注意的是，不管是信号量机制，还是管程机制，都属于进程间的低级通信。除了低级通信，还有进程的高级通信，即进程采用操作系统提供的多种通信方式，如消息缓冲、信箱、管道和共享主存区等实现的通信。当进程通过消息缓冲进行数据交换时，以消息为单位把通信内容直接或间接地发送给对方，这是进程利用系统提供的一组命令实现的。操作系统隐藏了通信的实现细节，大大简化了通信编程的复杂性，因而得到广泛应用。</p>
<h3 id="管程案例展示">管程案例展示</h3>
<p>下面是用管程描述生产者和消费者共享环形缓冲区（循环队列）问题的一个示例。</p>
<div class="code-wrapper"><pre><code class="hljs arduino">Monitor prod_conshow &#123;  <span class="hljs-comment">// Producer-Consumer Demonstration</span>
    <span class="hljs-type">char</span> buffer[N];  <span class="hljs-comment">// 具有N个元素的环形缓冲区</span>
    <span class="hljs-type">int</span> k;  <span class="hljs-comment">// 缓冲区中产品的个数</span>
    <span class="hljs-type">int</span> next_empty, next_full;  <span class="hljs-comment">// 送、取产品的指针</span>
    condition non_empty, non_full;  <span class="hljs-comment">// 条件变量</span>
    define put, get;  <span class="hljs-comment">// 本管程内定义的过程（或函数）说明（即：名字表）</span>
    <span class="hljs-function">use <span class="hljs-title">wait</span><span class="hljs-params">()</span>, <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 本管程内引用的外部模块的过程说明</span>
    <span class="hljs-comment">/* 向缓冲区送产品的过程 */</span>
    <span class="hljs-function">procedure <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">char</span> product)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(k==N) &#123;
            <span class="hljs-comment">// 缓冲区已满，调用者（生产者）进程阻塞等待（退出至 non_full 队列）</span>
            <span class="hljs-built_in">wait</span>(non_full);
        &#125;
        buffer[next_empty] = product;
        k += <span class="hljs-number">1</span>;  <span class="hljs-comment">// 可用产品数+1</span>
        next_empty = (next_empty + <span class="hljs-number">1</span>) % N;  <span class="hljs-comment">// 环形更新</span>
        <span class="hljs-comment">// 唤醒等待取产品的消费者进程（在 non_empty 队列中）</span>
        <span class="hljs-built_in">signal</span>(non_empty);
    &#125;
    <span class="hljs-comment">/* 从缓冲区取产品的过程 */</span>
    <span class="hljs-function">procedure <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span> goods)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 缓冲区空，调用者（消费者）进程阻塞等待（退出至 non_empty 队列）</span>
            <span class="hljs-built_in">wait</span>(non_empty);
        &#125;
        goods = buffer[next_full];
        k -= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 可用产品数-1</span>
        next_full = (next_full + <span class="hljs-number">1</span>) % N;
        <span class="hljs-comment">// 唤醒等待送产品的生产者进程（在 non_full 队列中）</span>
        <span class="hljs-built_in">signal</span>(non_full);
    &#125;
    <span class="hljs-comment">/* 初始化 */</span>
    &#123;
        k = <span class="hljs-number">0</span>; next_empty = <span class="hljs-number">0</span>; next_full = <span class="hljs-number">0</span>;
    &#125;
&#125;

<span class="hljs-comment">/* 调用管程的相应过程实现进程同步 */</span>
producer: &#123;
    <span class="hljs-type">char</span> item;
    &lt;-- produce an item --&gt;
    prod_conshow.<span class="hljs-built_in">put</span>(item);
&#125;
consumer: &#123;
    <span class="hljs-type">char</span> item;
    prod_conshow.<span class="hljs-built_in">get</span>(item);
    &lt;-- consume the item --&gt;
&#125;</code></pre></div>
<p>C++代码实现：</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Monitor</span> &#123;
<span class="hljs-keyword">private</span>:
    queue&lt;<span class="hljs-type">int</span>&gt; buffer;               <span class="hljs-comment">// 共享的缓冲区</span>
    <span class="hljs-type">int</span> maxSize;                     <span class="hljs-comment">// 缓冲区的最大容量</span>
    mutex mtx;                       <span class="hljs-comment">// 互斥锁</span>
    condition_variable bufferFull;   <span class="hljs-comment">// 缓冲区满的条件变量</span>
    condition_variable bufferEmpty;  <span class="hljs-comment">// 缓冲区空的条件变量</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 构造函数，初始化缓冲区大小</span>
    <span class="hljs-built_in">Monitor</span>(<span class="hljs-type">int</span> size) : <span class="hljs-built_in">maxSize</span>(size) &#123;&#125;

    <span class="hljs-comment">// 生产者进程的方法</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-type">int</span> item)</span> </span>&#123;
        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;  <span class="hljs-comment">// 锁定互斥锁</span>
        <span class="hljs-comment">// 如果缓冲区已满，则生产者等待</span>
        <span class="hljs-keyword">while</span> (buffer.<span class="hljs-built_in">size</span>() == maxSize) &#123;
            bufferFull.<span class="hljs-built_in">wait</span>(lock);  <span class="hljs-comment">// 释放锁并等待，直到被通知（唤醒）</span>
        &#125;
        buffer.<span class="hljs-built_in">push</span>(item);  <span class="hljs-comment">// 将数据添加到缓冲区</span>
        cout &lt;&lt; <span class="hljs-string">&quot;Produced item: &quot;</span> &lt;&lt; item &lt;&lt; endl;  <span class="hljs-comment">// 给用户提示</span>
        bufferEmpty.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// 通知一个消费者，缓冲区中有产品可拿走消费</span>
    &#125;
 
    <span class="hljs-comment">// 消费者进程的方法</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;  <span class="hljs-comment">// 锁定互斥锁</span>
        <span class="hljs-comment">// 如果缓冲区为空，则消费者等待</span>
        <span class="hljs-keyword">while</span> (buffer.<span class="hljs-built_in">empty</span>()) &#123;
            bufferEmpty.<span class="hljs-built_in">wait</span>(lock);  <span class="hljs-comment">// 释放锁并等待，直到被通知（唤醒）</span>
        &#125;
        <span class="hljs-type">int</span> item = buffer.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">// 从缓冲区取出数据</span>
        buffer.<span class="hljs-built_in">pop</span>();
        cout &lt;&lt; <span class="hljs-string">&quot;Consumed item: &quot;</span> &lt;&lt; item &lt;&lt; endl;
        bufferFull.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// 通知一个生产者，缓冲区中有空位可添加数据</span>
        <span class="hljs-keyword">return</span> item;
    &#125;
&#125;;
 
<span class="hljs-function">Monitor <span class="hljs-title">monitor</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 创建 Monitor 类的实例并指定缓冲区大小为5</span>
<span class="hljs-comment">// 生产者线程函数</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;
        monitor.<span class="hljs-built_in">produce</span>(i);
        <span class="hljs-comment">// 模拟耗时：生产间隔是500ms，即线程休眠500毫秒</span>
        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));
    &#125;
&#125;
<span class="hljs-comment">// 消费者线程函数</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;
        <span class="hljs-type">int</span> item = monitor.<span class="hljs-built_in">consume</span>();
        <span class="hljs-comment">// 模拟耗时：消费间隔是800ms，即线程休眠800毫秒</span>
        this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">800</span>));
    &#125;
&#125;
<span class="hljs-comment">// 在主函数中，创建并启动生产者线程和消费者线程，然后等待它们完成</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 创建新线程，这个新线程与主线程（通常是 main 函数所在的线程）会并行执行</span>
    <span class="hljs-function">thread <span class="hljs-title">producerThread</span><span class="hljs-params">(producer)</span></span>;
    <span class="hljs-function">thread <span class="hljs-title">consumerThread</span><span class="hljs-params">(consumer)</span></span>;
    <span class="hljs-comment">// 等待线程完成，确保 producerThread 线程执行完毕后才能执行下一个线程，否则各个线程执行程度不一比较混乱</span>
    <span class="hljs-comment">// 换句话说，join() 方法会阻塞当前线程（通常是主线程），保证主线程在所有子线程执行完毕后再继续执行（不会提前结束）</span>
    producerThread.<span class="hljs-built_in">join</span>();
    consumerThread.<span class="hljs-built_in">join</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>
<p>PS：在上面的C++例子中，不需要手动对互斥锁解锁，当进程的方法结束时，lock
对象离开其作用域后，若互斥锁 mutex 还处于锁定状态，那么在 unique_lock
对象的析构之时会自动解锁（对象被销毁了）。在某些循环中，用户或许需要使用
lock.unlock() 进行手动解锁。</p>
<h2 id="同步异步阻塞非阻塞">同步异步、阻塞非阻塞</h2>
<h3 id="同步与异步">同步与异步</h3>
<p>同步（synchronous）是指多个有相互之间一定联系的并发执行的进/线程，通过一定的机制，使之有序执行，从而使其总的运行结果符合预期。</p>
<p>异步（asynchronous）是指多个有相互之间一定联系的并发执行的进/线程，执行时相互之间没有约定一定的次序，各自运行。</p>
<h3 id="并行与并发">并行与并发</h3>
<p>并行（parallellism）是指两个及以上个进/线程在同一时刻（时间点）同时执行。</p>
<p>并发（concurrency）指两个及以上个进/线程在同一时间间隔（时间段）内同时执行，宏观上好像是“并行”，微观上还是交替执行的，只不过切换得非常快。</p>
<p>在宏观上，多个“同时”执行的进/线程，如果位于单处理机中执行，在微观上它们只能分时交替地执行。只有它们位于多处理机中执行，才可能存在微观上的同时执行，达到真正的并行。</p>
<h3 id="阻塞与挂起">阻塞与挂起</h3>
<p>阻塞（block）是指当前进程因操作系统分配的<strong>时间片用完之外</strong>的、因某<strong>资源没有满足</strong>的原因不能继续运行，从而交出当前
CPU
的使用权而暂停的一种状态。而当之前缺少的资源被满足之后，该进程将被解除阻塞从而恢复之前的运行状态。</p>
<p>挂起（suspend）是指当前进程发生了内存等共享资源的紧急不足，或者由于用户的意愿，现阶段不需要运行等原因，处于一种不接受操作系统调度的状态。阻塞与之的区别在于，当之前缺少的该资源被满足之后，处于阻塞状态的进程将被解除现在的暂停运行的状态，这个自动的过程是由操作系统设法完成的。但对于处于挂起状态的进程来说，当前暂停运行的状态不会被自动解除，除非用户主动对其进行激活。</p>
<h3 id="同步异步阻塞非阻塞-1">同步异步、阻塞非阻塞</h3>
<p>同步（Sync）、异步（Async）、阻塞（Blocking）、非阻塞（Non-Blocking）是一组容易被混淆的概念。</p>
<p><font color="red">阻塞是指进程在等待事件，暂时让出CPU；挂起是指进程被换出到外存，等待激活。在讨论阻塞/非阻塞时，我们一般不区分“阻塞”和“挂起”，因为对进/线程而言，阻塞和挂起都是失去CPU、无法运行的状态。</font></p>
<p>内核层面的同步IO、异步IO、阻塞IO和非阻塞IO与程序层面的关注点不同，结果也不同。在处理IO的时候，阻塞和非阻塞都是同步IO，只有使用了特殊的API才是异步IO。</p>
<p>网络IO接口调用，分为<strong>数据就绪阶段</strong>和<strong>数据读写阶段</strong>。</p>
<p>根据系统IO操作的就绪状态，数据就绪阶段可分为阻塞和非阻塞两种模式。阻塞是指调用IO的线程在没有数据（或数据未准备好）时会被挂起；非阻塞则不会改变当前线程的状态，而是直接返回一个值，通过返回值判断任务完成进度。</p>
<p>同步和异步是在数据读写阶段根据应用程序与内核的交互方式划分的。同步表示A向B请求调用一个网络IO接口时，数据读写都是由请求方A自己完成（不管是阻塞还是非阻塞，比如read()和recv()函数）；异步表示A向B请求调用一个网络IO接口时，向B传入请求的事件以及事件发生时通知的方式，然后A可以继续处理其他逻辑，当B监听到事件处理完成后，会用事先约定好的通知方式通知A处理结果。</p>
<p>异步IO一般只与非阻塞结合使用，因为异步阻塞效率效率太低，无实际意义。</p>
<p>下文讨论的是程序层面的概念，A：调用方，B：被调用方。</p>
<h4 id="跨进程调用">跨进程调用</h4>
<p>当用来描述一个跨进程调用（例如操作系统的I/O操作，或者B/S的Socket请求），同步指跨进程调用返回结果的方式，阻塞指被调用方准备结果时的进程状态（<strong>阻塞指被调用方</strong>）。</p>
<p><strong>同步阻塞</strong>：A发送请求之后一直等待响应（同步）。B的结果不能马上准备好（例如需要进行一个IO操作，但不能马上等到返回结果），就一直等到有返回结果后，才响应A，B进程在此期间不能进行其他工作（阻塞）。</p>
<p><strong>同步非阻塞</strong>：A发送请求之后，一直等待响应（同步）。B处理请求时进行的IO操作如果不能马上得到结果，先立即返回一个值，然后去做其他事情（非阻塞）。但是由于没有得到请求处理结果，不响应A，A就一直等待。当IO操作完成以后，将完成状态和结果通知B，B再响应A，A进入下一次请求过程。（实际不应用，B都去做别的事情了A还在等B？！）</p>
<p><strong>异步阻塞</strong>：A向B请求后，不会一直等待B的响应，可以继续其他工作（异步）。B处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应A，B进程在此期间不能进行其他操作（阻塞）。（实际不应用，A都去做别的事情了B还在守着A交代的事干等？！）</p>
<p><strong>异步非阻塞</strong>：A向B请求后，不会一直等待B的响应，可以继续其他工作（异步）。B处理请求时进行IO操作如果不能马上得到结果，也不等待数据完全准备好，而是马上返回一个值然后去做其他事情（非阻塞）。当IO操作完成以后，将完成状态和结果通知B，B再响应A。（效率最高）</p>
<h4 id="跨线程调用">跨线程调用</h4>
<p>当描述一个跨线程调用时，同步指跨线程调用返回结果的方式，阻塞指的是调用方等待数据返回时的线程状态（<strong>阻塞指调用方</strong>）。</p>
<p><strong>同步阻塞</strong>：A发送请求后一直等待响应，等待过程中线程挂起（不接受新任务）（阻塞）。B任务完成后返回结果，A再继续执行。</p>
<p><strong>同步非阻塞</strong>：A发送请求后不等待，线程立即可以接受新任务（非阻塞）。B的任务完成后返回结果，在此期间A通过轮训等方式不断检查结果。</p>
<p><mark>同步的实现方式：等待，或轮询。</mark></p>
<p><strong>异步阻塞</strong>：A发送请求后B立即返回一个值（异步），A会一直等待B的响应（A处于阻塞状态）。B的结果准备好后再通过回调等方式将结果发送给A，A再继续干活。（A没有必要阻塞，所以实际不应用）</p>
<p><strong>异步非阻塞</strong>：A发送请求后B立即返回一个值（异步），A不会一直等待B的响应，A的线程可以接受新任务（非阻塞）。B的结果准备好后再通过回调等方式将结果发送给A。</p>
<p><mark>异步的实现方式：回调函数，或通知。</mark></p>
<h4 id="参考文献">参考文献</h4>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/vitaviva/article/details/104127259">理解同步/异步/阻塞/非阻塞的区别</a></p>
<p><a
target="_blank" rel="noopener" href="https://imageslr.com/2019/block-non-blocking-sync-async.html"
title="有代码示例">详解阻塞非阻塞与同步异步</a></p>
<h2 id="设计模式">设计模式</h2>
<p>设计模式是在软件工程中被反复使用的一种解决方案的范式，它提供了一种通用且可重用的方法来解决常见的设计问题。以下是根据目的和范围对设计模式进行的分类：</p>
<h3 id="创建型模式creational-patterns">创建型模式(Creational
Patterns)</h3>
<p>这些模式提供了一种在创建对象时控制对象创建过程的方法。它们隐藏了创建逻辑的复杂性，以便于使用者可以更加专注于逻辑的实现。</p>
<ul>
<li>工厂模式 (Factory Method)</li>
<li>抽象工厂模式 (Abstract Factory)</li>
<li>单例模式 (Singleton)</li>
<li>建造者模式 (Builder)</li>
<li>原型模式 (Prototype)</li>
</ul>
<h3 id="结构型模式structural-patterns">结构型模式(Structural
Patterns)</h3>
<p>这些模式关注类和对象的组合，以及如何通过继承机制来扩展这些结构。</p>
<ul>
<li>适配器模式 (Adapter)</li>
<li>桥接模式 (Bridge)</li>
<li>组合模式 (Composite)</li>
<li>装饰器模式 (Decorator)</li>
<li>外观模式 (Facade)</li>
<li>享元模式 (Flyweight)</li>
<li>代理模式 (Proxy)</li>
</ul>
<h3 id="行为型模式behavioral-patterns">行为型模式(Behavioral
Patterns)</h3>
<p>这些模式关注对象之间的通信，以及如何通过交互来实现更大的功能。</p>
<ul>
<li>责任链模式 (Chain of Responsibility)</li>
<li>命令模式 (Command)</li>
<li>解释器模式 (Interpreter)</li>
<li>迭代器模式 (Iterator)</li>
<li>中介者模式 (Mediator)</li>
<li>备忘录模式 (Memento)</li>
<li>观察者模式 (Observer)</li>
<li>状态模式 (State)</li>
<li>策略模式 (Strategy)</li>
<li>模板方法模式 (Template Method)</li>
<li>访问者模式 (Visitor)</li>
</ul>
<h3 id="并发模式concurrency-patterns">并发模式(Concurrency
Patterns)</h3>
<p>这些模式关注如何管理多个线程或进程，以提高程序的性能和响应能力。</p>
<ul>
<li>生产者-消费者模式 (Producer-Consumer)</li>
<li>读写锁模式 (Read-Write Lock)</li>
<li>线程池模式 (Thread Pool)</li>
<li>双缓冲模式 (Double Buffer)</li>
</ul>
<h3 id="其他模式">其他模式</h3>
<p>这些模式不属于上述四大类别，但也非常重要。</p>
<ul>
<li>空对象模式 (Null Object)</li>
<li>标记接口模式 (Marker Interface)</li>
<li>类型对象模式 (Type Object)</li>
<li>依赖注入模式 (Dependency Injection)</li>
<li>服务定位器模式 (Service Locator)</li>
</ul>
<p>每种模式都有其特定的用途和适用场景，选择合适的模式可以帮助开发者构建出更加灵活、可维护和可扩展的软件系统。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Programming/" class="category-chain-item">Programming</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/study/" class="print-no-link">#study</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>码农日记 · 贰</div>
      <div>https://afly36-swordsman.github.io/2024/04/10/Programming02/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Zenitsu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>April 10, 2024</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Updated on</div>
          <div>March 23, 2025</div>
        </div>
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/28/Programming03/" title="开发者笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">开发者笔记</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/21/Programming01/" title="码农日记 · 壹">
                        <span class="hidden-mobile">码农日记 · 壹</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-left: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Programming"
        id="heading-e6f43c40ab1c07cd29e4e83e4ef6bf85" role="tab" data-toggle="collapse" href="#collapse-e6f43c40ab1c07cd29e4e83e4ef6bf85"
        aria-expanded="true"
      >
        Programming
        <span class="list-group-count">(6)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-e6f43c40ab1c07cd29e4e83e4ef6bf85"
           role="tabpanel" aria-labelledby="heading-e6f43c40ab1c07cd29e4e83e4ef6bf85">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2024/03/16/Coding/" title="Coding Corner"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Coding Corner</span>
        </a>
      
    
      
      
        <a href="/2024/07/28/Linux/" title="LinuxOS"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">LinuxOS</span>
        </a>
      
    
      
      
        <a href="/2024/07/28/Programming03/" title="开发者笔记"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">开发者笔记</span>
        </a>
      
    
      
      
        <a href="/2025/04/19/Programming04/" title="码农日记 · 叁"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">码农日记 · 叁</span>
        </a>
      
    
      
      
        <a href="/2024/03/21/Programming01/" title="码农日记 · 壹"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">码农日记 · 壹</span>
        </a>
      
    
      
      
        <a href="/2024/04/10/Programming02/" title="码农日记 · 贰"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">码农日记 · 贰</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">

  <div>
    <span id="timeDate">正在载入天数...</span>
    <span id="times">载入时分秒...</span>
    <script>
    var now = new Date();
    function createtime(){
        var grt= new Date("11/24/2023 11:30:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){
            hnum = "0" + hnum;
        }
        minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if(String(mnum).length ==1 ){
                  mnum = "0" + mnum;
        }
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){
                  snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = "🚀 for&nbsp"+dnum+"&nbspdays";  
        document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" + snum + "&nbspsec";
    }
    setInterval("createtime()",250);
    </script>
  </div>  

  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  

</div>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/custom.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>

</body>
</html>
